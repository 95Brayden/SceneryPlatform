{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\n/**\n * @module ol/render/canvas/style\n */\n\nimport Circle from '../../style/Circle.js';\nimport Fill from '../../style/Fill.js';\nimport Icon from '../../style/Icon.js';\nimport RegularShape from '../../style/RegularShape.js';\nimport Stroke from '../../style/Stroke.js';\nimport Style from '../../style/Style.js';\nimport Text from '../../style/Text.js';\nimport { BooleanType, ColorType, NumberArrayType, NumberType, StringType, newParsingContext } from '../../expr/expression.js';\nimport { buildExpression, newEvaluationContext } from '../../expr/cpu.js';\nimport { toSize } from '../../size.js';\n\n/**\n * @fileoverview This module includes functions to build styles for the canvas renderer.  Building\n * is composed of two steps: parsing and compiling.  The parsing step takes an encoded expression\n * and returns an instance of one of the expression classes.  The compiling step takes the\n * expression instance and returns a function that can be evaluated to return a literal value.  The\n * evaluator function should do as little allocation and work as possible.\n */\n\n/**\n * @typedef {import(\"../../style/flat.js\").FlatStyle} FlatStyle\n */\n\n/**\n * @typedef {import(\"../../expr/expression.js\").EncodedExpression} EncodedExpression\n */\n\n/**\n * @typedef {import(\"../../expr/expression.js\").ParsingContext} ParsingContext\n */\n\n/**\n * @typedef {import(\"../../expr/expression.js\").CallExpression} CallExpression\n */\n\n/**\n * @typedef {import(\"../../expr/cpu.js\").EvaluationContext} EvaluationContext\n */\n\n/**\n * @typedef {import(\"../../expr/cpu.js\").ExpressionEvaluator} ExpressionEvaluator\n */\n\n/**\n * @param {EvaluationContext} context The evaluation context.\n * @return {boolean} Always true.\n */\nfunction always(context) {\n  return true;\n}\n\n/**\n * This function adapts a rule evaluator to the existing style function interface.\n * After we have deprecated the style function, we can use the compiled rules directly\n * and pass a more complete evaluation context (variables, zoom, time, etc.).\n *\n * @param {Array<import('../../style/flat.js').Rule>} rules The rules.\n * @return {import('../../style/Style.js').StyleFunction} A style function.\n */\nexport function rulesToStyleFunction(rules) {\n  const parsingContext = newParsingContext();\n  const evaluator = buildRuleSet(rules, parsingContext);\n  const evaluationContext = newEvaluationContext();\n  return function (feature, resolution) {\n    evaluationContext.properties = feature.getPropertiesInternal();\n    evaluationContext.resolution = resolution;\n    return evaluator(evaluationContext);\n  };\n}\n\n/**\n * This function adapts a style evaluator to the existing style function interface.\n * After we have deprecated the style function, we can use the compiled rules directly\n * and pass a more complete evaluation context (variables, zoom, time, etc.).\n *\n * @param {Array<import('../../style/flat.js').FlatStyle>} flatStyles The flat styles.\n * @return {import('../../style/Style.js').StyleFunction} A style function.\n */\nexport function flatStylesToStyleFunction(flatStyles) {\n  const parsingContext = newParsingContext();\n  const length = flatStyles.length;\n\n  /**\n   * @type {Array<StyleEvaluator>}\n   */\n  const evaluators = new Array(length);\n  for (let i = 0; i < length; ++i) {\n    evaluators[i] = buildStyle(flatStyles[i], parsingContext);\n  }\n  const evaluationContext = newEvaluationContext();\n\n  /**\n   * @type {Array<Style>}\n   */\n  const styles = new Array(length);\n  return function (feature, resolution) {\n    evaluationContext.properties = feature.getPropertiesInternal();\n    evaluationContext.resolution = resolution;\n    for (let i = 0; i < length; ++i) {\n      styles[i] = evaluators[i](evaluationContext);\n    }\n    return styles;\n  };\n}\n\n/**\n * @typedef {function(EvaluationContext):Array<Style>} RuleSetEvaluator\n */\n\n/**\n * @typedef {Object} CompiledRule\n * @property {ExpressionEvaluator} filter The compiled filter evaluator.\n * @property {Array<StyleEvaluator>} styles The list of compiled style evaluators.\n */\n\n/**\n * @param {Array<import('../../style/flat.js').Rule>} rules The rules.\n * @param {ParsingContext} context The parsing context.\n * @return {RuleSetEvaluator} The evaluator function.\n */\nexport function buildRuleSet(rules, context) {\n  const length = rules.length;\n\n  /**\n   * @type {Array<CompiledRule>}\n   */\n  const compiledRules = new Array(length);\n  for (let i = 0; i < length; ++i) {\n    const rule = rules[i];\n    const filter = 'filter' in rule ? buildExpression(rule.filter, BooleanType, context) : always;\n\n    /**\n     * @type {Array<StyleEvaluator>}\n     */\n    let styles;\n    if (Array.isArray(rule.style)) {\n      const styleLength = rule.style.length;\n      styles = new Array(styleLength);\n      for (let j = 0; j < styleLength; ++j) {\n        styles[j] = buildStyle(rule.style[j], context);\n      }\n    } else {\n      styles = [buildStyle(rule.style, context)];\n    }\n    compiledRules[i] = {\n      filter,\n      styles\n    };\n  }\n  return function (context) {\n    /**\n     * @type {Array<Style>}\n     */\n    const styles = [];\n    let someMatched = false;\n    for (let i = 0; i < length; ++i) {\n      const filterEvaluator = compiledRules[i].filter;\n      if (!filterEvaluator(context)) {\n        continue;\n      }\n      if (rules[i].else && someMatched) {\n        continue;\n      }\n      someMatched = true;\n      for (const styleEvaluator of compiledRules[i].styles) {\n        const style = styleEvaluator(context);\n        if (!style) {\n          continue;\n        }\n        styles.push(style);\n      }\n    }\n    return styles;\n  };\n}\n\n/**\n * @typedef {function(EvaluationContext):Style} StyleEvaluator\n */\n\n/**\n * @param {FlatStyle} flatStyle A flat style literal.\n * @param {ParsingContext} context The parsing context.\n * @return {StyleEvaluator} A function that evaluates to a style.  The style returned by\n * this function will be reused between invocations.\n */\nexport function buildStyle(flatStyle, context) {\n  const evaluateFill = buildFill(flatStyle, '', context);\n  const evaluateStroke = buildStroke(flatStyle, '', context);\n  const evaluateText = buildText(flatStyle, context);\n  const evaluateImage = buildImage(flatStyle, context);\n  const evaluateZIndex = numberEvaluator(flatStyle, 'z-index', context);\n  const style = new Style();\n  return function (context) {\n    let empty = true;\n    if (evaluateFill) {\n      const fill = evaluateFill(context);\n      if (fill) {\n        empty = false;\n      }\n      style.setFill(fill);\n    }\n    if (evaluateStroke) {\n      const stroke = evaluateStroke(context);\n      if (stroke) {\n        empty = false;\n      }\n      style.setStroke(stroke);\n    }\n    if (evaluateText) {\n      const text = evaluateText(context);\n      if (text) {\n        empty = false;\n      }\n      style.setText(text);\n    }\n    if (evaluateImage) {\n      const image = evaluateImage(context);\n      if (image) {\n        empty = false;\n      }\n      style.setImage(image);\n    }\n    if (evaluateZIndex) {\n      style.setZIndex(evaluateZIndex(context));\n    }\n    if (empty) {\n      return null;\n    }\n    return style;\n  };\n}\n\n/**\n * @typedef {function(EvaluationContext):Fill} FillEvaluator\n */\n\n/**\n * @param {FlatStyle} flatStyle The flat style.\n * @param {string} prefix The property prefix.\n * @param {ParsingContext} context The parsing context.\n * @return {FillEvaluator?} A function that evaluates to a fill.\n */\nfunction buildFill(flatStyle, prefix, context) {\n  const evaluateColor = colorLikeEvaluator(flatStyle, prefix + 'fill-color', context);\n  if (!evaluateColor) {\n    return null;\n  }\n  const fill = new Fill();\n  return function (context) {\n    const color = evaluateColor(context);\n    if (color === 'none') {\n      return null;\n    }\n    fill.setColor(color);\n    return fill;\n  };\n}\n\n/**\n * @typedef {function(EvaluationContext):Stroke} StrokeEvaluator\n */\n\n/**\n * @param {FlatStyle} flatStyle The flat style.\n * @param {string} prefix The property prefix.\n * @param {ParsingContext} context The parsing context.\n * @return {StrokeEvaluator?} A function the evaluates to a stroke.\n */\nfunction buildStroke(flatStyle, prefix, context) {\n  const evaluateWidth = numberEvaluator(flatStyle, prefix + 'stroke-width', context);\n  const evaluateColor = colorLikeEvaluator(flatStyle, prefix + 'stroke-color', context);\n  if (!evaluateWidth && !evaluateColor) {\n    return null;\n  }\n  const evaluateLineCap = stringEvaluator(flatStyle, prefix + 'stroke-line-cap', context);\n  const evaluateLineJoin = stringEvaluator(flatStyle, prefix + 'stroke-line-join', context);\n  const evaluateLineDash = numberArrayEvaluator(flatStyle, prefix + 'stroke-line-dash', context);\n  const evaluateLineDashOffset = numberEvaluator(flatStyle, prefix + 'stroke-line-dash-offset', context);\n  const evaluateMiterLimit = numberEvaluator(flatStyle, prefix + 'stroke-miter-limit', context);\n  const stroke = new Stroke();\n  return function (context) {\n    if (evaluateColor) {\n      const color = evaluateColor(context);\n      if (color === 'none') {\n        return null;\n      }\n      stroke.setColor(color);\n    }\n    if (evaluateWidth) {\n      stroke.setWidth(evaluateWidth(context));\n    }\n    if (evaluateLineCap) {\n      const lineCap = evaluateLineCap(context);\n      if (lineCap !== 'butt' && lineCap !== 'round' && lineCap !== 'square') {\n        throw new Error('Expected butt, round, or square line cap');\n      }\n      stroke.setLineCap(lineCap);\n    }\n    if (evaluateLineJoin) {\n      const lineJoin = evaluateLineJoin(context);\n      if (lineJoin !== 'bevel' && lineJoin !== 'round' && lineJoin !== 'miter') {\n        throw new Error('Expected bevel, round, or miter line join');\n      }\n      stroke.setLineJoin(lineJoin);\n    }\n    if (evaluateLineDash) {\n      stroke.setLineDash(evaluateLineDash(context));\n    }\n    if (evaluateLineDashOffset) {\n      stroke.setLineDashOffset(evaluateLineDashOffset(context));\n    }\n    if (evaluateMiterLimit) {\n      stroke.setMiterLimit(evaluateMiterLimit(context));\n    }\n    return stroke;\n  };\n}\n\n/**\n * @typedef {function(EvaluationContext):Text} TextEvaluator\n */\n\n/**\n * @param {FlatStyle} flatStyle The flat style.\n * @param {ParsingContext} context The parsing context.\n * @return {TextEvaluator?} A function that evaluates to a text symbolizer.\n */\nfunction buildText(flatStyle, context) {\n  const prefix = 'text-';\n\n  // Currently, an Array<string> may be used for rich text support.  This doesn't\n  // work with our expression syntax where arrays of strings are interpreted as\n  // call expressions.  To support rich text, we could add a 'strings' operator\n  // where all the following arguments would be string values.\n  const evaluateValue = stringEvaluator(flatStyle, prefix + 'value', context);\n  if (!evaluateValue) {\n    return null;\n  }\n  const evaluateFill = buildFill(flatStyle, prefix, context);\n  const evaluateBackgroundFill = buildFill(flatStyle, prefix + 'background-', context);\n  const evaluateStroke = buildStroke(flatStyle, prefix, context);\n  const evaluateBackgroundStroke = buildStroke(flatStyle, prefix + 'background-', context);\n  const evaluateFont = stringEvaluator(flatStyle, prefix + 'font', context);\n  const evaluateMaxAngle = numberEvaluator(flatStyle, prefix + 'max-angle', context);\n  const evaluateOffsetX = numberEvaluator(flatStyle, prefix + 'offset-x', context);\n  const evaluateOffsetY = numberEvaluator(flatStyle, prefix + 'offset-y', context);\n  const evaluateOverflow = booleanEvaluator(flatStyle, prefix + 'overflow', context);\n  const evaluatePlacement = stringEvaluator(flatStyle, prefix + 'placement', context);\n  const evaluateRepeat = numberEvaluator(flatStyle, prefix + 'repeat', context);\n  const evaluateScale = sizeLikeEvaluator(flatStyle, prefix + 'scale', context);\n  const evaluateRotateWithView = booleanEvaluator(flatStyle, prefix + 'rotate-with-view', context);\n  const evaluateRotation = numberEvaluator(flatStyle, prefix + 'rotation', context);\n  const evaluateAlign = stringEvaluator(flatStyle, prefix + 'align', context);\n  const evaluateJustify = stringEvaluator(flatStyle, prefix + 'justify', context);\n  const evaluateBaseline = stringEvaluator(flatStyle, prefix + 'baseline', context);\n  const evaluatePadding = numberArrayEvaluator(flatStyle, prefix + 'padding', context);\n  const text = new Text({});\n  return function (context) {\n    text.setText(evaluateValue(context));\n    if (evaluateFill) {\n      text.setFill(evaluateFill(context));\n    }\n    if (evaluateBackgroundFill) {\n      text.setBackgroundFill(evaluateBackgroundFill(context));\n    }\n    if (evaluateStroke) {\n      text.setStroke(evaluateStroke(context));\n    }\n    if (evaluateBackgroundStroke) {\n      text.setBackgroundStroke(evaluateBackgroundStroke(context));\n    }\n    if (evaluateFont) {\n      text.setFont(evaluateFont(context));\n    }\n    if (evaluateMaxAngle) {\n      text.setMaxAngle(evaluateMaxAngle(context));\n    }\n    if (evaluateOffsetX) {\n      text.setOffsetX(evaluateOffsetX(context));\n    }\n    if (evaluateOffsetY) {\n      text.setOffsetY(evaluateOffsetY(context));\n    }\n    if (evaluateOverflow) {\n      text.setOverflow(evaluateOverflow(context));\n    }\n    if (evaluatePlacement) {\n      const placement = evaluatePlacement(context);\n      if (placement !== 'point' && placement !== 'line') {\n        throw new Error('Expected point or line for text-placement');\n      }\n      text.setPlacement(placement);\n    }\n    if (evaluateRepeat) {\n      text.setRepeat(evaluateRepeat(context));\n    }\n    if (evaluateScale) {\n      text.setScale(evaluateScale(context));\n    }\n    if (evaluateRotateWithView) {\n      text.setRotateWithView(evaluateRotateWithView(context));\n    }\n    if (evaluateRotation) {\n      text.setRotation(evaluateRotation(context));\n    }\n    if (evaluateAlign) {\n      const textAlign = evaluateAlign(context);\n      if (textAlign !== 'left' && textAlign !== 'center' && textAlign !== 'right' && textAlign !== 'end' && textAlign !== 'start') {\n        throw new Error('Expected left, right, center, start, or end for text-align');\n      }\n      text.setTextAlign(textAlign);\n    }\n    if (evaluateJustify) {\n      const justify = evaluateJustify(context);\n      if (justify !== 'left' && justify !== 'right' && justify !== 'center') {\n        throw new Error('Expected left, right, or center for text-justify');\n      }\n      text.setJustify(justify);\n    }\n    if (evaluateBaseline) {\n      const textBaseline = evaluateBaseline(context);\n      if (textBaseline !== 'bottom' && textBaseline !== 'top' && textBaseline !== 'middle' && textBaseline !== 'alphabetic' && textBaseline !== 'hanging') {\n        throw new Error('Expected bottom, top, middle, alphabetic, or hanging for text-baseline');\n      }\n      text.setTextBaseline(textBaseline);\n    }\n    if (evaluatePadding) {\n      text.setPadding(evaluatePadding(context));\n    }\n    return text;\n  };\n}\n\n/**\n * @typedef {function(EvaluationContext):import(\"../../style/Image.js\").default} ImageEvaluator\n */\n\n/**\n * @param {FlatStyle} flatStyle The flat style.\n * @param {ParsingContext} context The parsing context.\n * @return {ImageEvaluator?} A function that evaluates to an image symbolizer.\n */\nfunction buildImage(flatStyle, context) {\n  if ('icon-src' in flatStyle) {\n    return buildIcon(flatStyle, context);\n  }\n  if ('shape-points' in flatStyle) {\n    return buildShape(flatStyle, context);\n  }\n  if ('circle-radius' in flatStyle) {\n    return buildCircle(flatStyle, context);\n  }\n  return null;\n}\n\n/**\n * @param {FlatStyle} flatStyle The flat style.\n * @param {ParsingContext} context The parsing context.\n * @return {ImageEvaluator} A function that evaluates to an image symbolizer.\n */\nfunction buildIcon(flatStyle, context) {\n  const prefix = 'icon-';\n\n  // required property\n  const srcName = prefix + 'src';\n  const src = requireString(flatStyle[srcName], srcName);\n\n  // settable properties\n  const evaluateAnchor = coordinateEvaluator(flatStyle, prefix + 'anchor', context);\n  const evaluateScale = sizeLikeEvaluator(flatStyle, prefix + 'scale', context);\n  const evaluateOpacity = numberEvaluator(flatStyle, prefix + 'opacity', context);\n  const evaluateDisplacement = coordinateEvaluator(flatStyle, prefix + 'displacement', context);\n  const evaluateRotation = numberEvaluator(flatStyle, prefix + 'rotation', context);\n  const evaluateRotateWithView = booleanEvaluator(flatStyle, prefix + 'rotate-with-view', context);\n\n  // the remaining symbolizer properties are not currently settable\n  const anchorOrigin = optionalIconOrigin(flatStyle, prefix + 'anchor-origin');\n  const anchorXUnits = optionalIconAnchorUnits(flatStyle, prefix + 'anchor-x-units');\n  const anchorYUnits = optionalIconAnchorUnits(flatStyle, prefix + 'anchor-y-units');\n  const color = optionalColorLike(flatStyle, prefix + 'color');\n  const crossOrigin = optionalString(flatStyle, prefix + 'cross-origin');\n  const offset = optionalNumberArray(flatStyle, prefix + 'offset');\n  const offsetOrigin = optionalIconOrigin(flatStyle, prefix + 'offset-origin');\n  const width = optionalNumber(flatStyle, prefix + 'width');\n  const height = optionalNumber(flatStyle, prefix + 'height');\n  const size = optionalSize(flatStyle, prefix + 'size');\n  const declutterMode = optionalDeclutterMode(flatStyle, prefix + 'declutter');\n  const icon = new Icon({\n    src,\n    anchorOrigin,\n    anchorXUnits,\n    anchorYUnits,\n    color,\n    crossOrigin,\n    offset,\n    offsetOrigin,\n    height,\n    width,\n    size,\n    declutterMode\n  });\n  return function (context) {\n    if (evaluateOpacity) {\n      icon.setOpacity(evaluateOpacity(context));\n    }\n    if (evaluateDisplacement) {\n      icon.setDisplacement(evaluateDisplacement(context));\n    }\n    if (evaluateRotation) {\n      icon.setRotation(evaluateRotation(context));\n    }\n    if (evaluateRotateWithView) {\n      icon.setRotateWithView(evaluateRotateWithView(context));\n    }\n    if (evaluateScale) {\n      icon.setScale(evaluateScale(context));\n    }\n    if (evaluateAnchor) {\n      icon.setAnchor(evaluateAnchor(context));\n    }\n    return icon;\n  };\n}\n\n/**\n * @param {FlatStyle} flatStyle The flat style.\n * @param {ParsingContext} context The parsing context.\n * @return {ImageEvaluator} A function that evaluates to an icon symbolizer.\n */\nfunction buildShape(flatStyle, context) {\n  const prefix = 'shape-';\n\n  // required property\n  const pointsName = prefix + 'points';\n  const points = requireNumber(flatStyle[pointsName], pointsName);\n\n  // settable properties\n  const evaluateFill = buildFill(flatStyle, prefix, context);\n  const evaluateStroke = buildStroke(flatStyle, prefix, context);\n  const evaluateScale = sizeLikeEvaluator(flatStyle, prefix + 'scale', context);\n  const evaluateDisplacement = coordinateEvaluator(flatStyle, prefix + 'displacement', context);\n  const evaluateRotation = numberEvaluator(flatStyle, prefix + 'rotation', context);\n  const evaluateRotateWithView = booleanEvaluator(flatStyle, prefix + 'rotate-with-view', context);\n\n  // the remaining properties are not currently settable\n  const radius = optionalNumber(flatStyle, prefix + 'radius');\n  const radius1 = optionalNumber(flatStyle, prefix + 'radius1');\n  const radius2 = optionalNumber(flatStyle, prefix + 'radius2');\n  const angle = optionalNumber(flatStyle, prefix + 'angle');\n  const declutterMode = optionalDeclutterMode(flatStyle, prefix + 'declutter-mode');\n  const shape = new RegularShape({\n    points,\n    radius,\n    radius1,\n    radius2,\n    angle,\n    declutterMode\n  });\n  return function (context) {\n    if (evaluateFill) {\n      shape.setFill(evaluateFill(context));\n    }\n    if (evaluateStroke) {\n      shape.setStroke(evaluateStroke(context));\n    }\n    if (evaluateDisplacement) {\n      shape.setDisplacement(evaluateDisplacement(context));\n    }\n    if (evaluateRotation) {\n      shape.setRotation(evaluateRotation(context));\n    }\n    if (evaluateRotateWithView) {\n      shape.setRotateWithView(evaluateRotateWithView(context));\n    }\n    if (evaluateScale) {\n      shape.setScale(evaluateScale(context));\n    }\n    return shape;\n  };\n}\n\n/**\n * @param {FlatStyle} flatStyle The flat style.\n * @param {ParsingContext} context The parsing context.\n * @return {ImageEvaluator} A function that evaluates to a circle symbolizer.\n */\nfunction buildCircle(flatStyle, context) {\n  const prefix = 'circle-';\n\n  // settable properties\n  const evaluateFill = buildFill(flatStyle, prefix, context);\n  const evaluateStroke = buildStroke(flatStyle, prefix, context);\n  const evaluateRadius = numberEvaluator(flatStyle, prefix + 'radius', context);\n  const evaluateScale = sizeLikeEvaluator(flatStyle, prefix + 'scale', context);\n  const evaluateDisplacement = coordinateEvaluator(flatStyle, prefix + 'displacement', context);\n  const evaluateRotation = numberEvaluator(flatStyle, prefix + 'rotation', context);\n  const evaluateRotateWithView = booleanEvaluator(flatStyle, prefix + 'rotate-with-view', context);\n\n  // the remaining properties are not currently settable\n  const declutterMode = optionalDeclutterMode(flatStyle, prefix + 'declutter-mode');\n  const circle = new Circle({\n    radius: 5,\n    // this is arbitrary, but required - the evaluated radius is used below\n    declutterMode\n  });\n  return function (context) {\n    if (evaluateRadius) {\n      circle.setRadius(evaluateRadius(context));\n    }\n    if (evaluateFill) {\n      circle.setFill(evaluateFill(context));\n    }\n    if (evaluateStroke) {\n      circle.setStroke(evaluateStroke(context));\n    }\n    if (evaluateDisplacement) {\n      circle.setDisplacement(evaluateDisplacement(context));\n    }\n    if (evaluateRotation) {\n      circle.setRotation(evaluateRotation(context));\n    }\n    if (evaluateRotateWithView) {\n      circle.setRotateWithView(evaluateRotateWithView(context));\n    }\n    if (evaluateScale) {\n      circle.setScale(evaluateScale(context));\n    }\n    return circle;\n  };\n}\n\n/**\n * @param {FlatStyle} flatStyle The flat style.\n * @param {string} name The property name.\n * @param {ParsingContext} context The parsing context.\n * @return {import('../../expr/cpu.js').NumberEvaluator|undefined} The expression evaluator or undefined.\n */\nfunction numberEvaluator(flatStyle, name, context) {\n  if (!(name in flatStyle)) {\n    return undefined;\n  }\n  const evaluator = buildExpression(flatStyle[name], NumberType, context);\n  return function (context) {\n    return requireNumber(evaluator(context), name);\n  };\n}\n\n/**\n * @param {FlatStyle} flatStyle The flat style.\n * @param {string} name The property name.\n * @param {ParsingContext} context The parsing context.\n * @return {import('../../expr/cpu.js').StringEvaluator?} The expression evaluator.\n */\nfunction stringEvaluator(flatStyle, name, context) {\n  if (!(name in flatStyle)) {\n    return null;\n  }\n  const evaluator = buildExpression(flatStyle[name], StringType, context);\n  return function (context) {\n    return requireString(evaluator(context), name);\n  };\n}\n\n/**\n * @param {FlatStyle} flatStyle The flat style.\n * @param {string} name The property name.\n * @param {ParsingContext} context The parsing context.\n * @return {import('../../expr/cpu.js').BooleanEvaluator?} The expression evaluator.\n */\nfunction booleanEvaluator(flatStyle, name, context) {\n  if (!(name in flatStyle)) {\n    return null;\n  }\n  const evaluator = buildExpression(flatStyle[name], BooleanType, context);\n  return function (context) {\n    const value = evaluator(context);\n    if (typeof value !== 'boolean') {\n      throw new Error(`Expected a boolean for ${name}`);\n    }\n    return value;\n  };\n}\n\n/**\n * @param {FlatStyle} flatStyle The flat style.\n * @param {string} name The property name.\n * @param {ParsingContext} context The parsing context.\n * @return {import('../../expr/cpu.js').ColorLikeEvaluator?} The expression evaluator.\n */\nfunction colorLikeEvaluator(flatStyle, name, context) {\n  if (!(name in flatStyle)) {\n    return null;\n  }\n  const evaluator = buildExpression(flatStyle[name], ColorType | StringType, context);\n  return function (context) {\n    return requireColorLike(evaluator(context), name);\n  };\n}\n\n/**\n * @param {FlatStyle} flatStyle The flat style.\n * @param {string} name The property name.\n * @param {ParsingContext} context The parsing context.\n * @return {import('../../expr/cpu.js').NumberArrayEvaluator?} The expression evaluator.\n */\nfunction numberArrayEvaluator(flatStyle, name, context) {\n  if (!(name in flatStyle)) {\n    return null;\n  }\n  const evaluator = buildExpression(flatStyle[name], NumberArrayType, context);\n  return function (context) {\n    return requireNumberArray(evaluator(context), name);\n  };\n}\n\n/**\n * @param {FlatStyle} flatStyle The flat style.\n * @param {string} name The property name.\n * @param {ParsingContext} context The parsing context.\n * @return {import('../../expr/cpu.js').CoordinateEvaluator?} The expression evaluator.\n */\nfunction coordinateEvaluator(flatStyle, name, context) {\n  if (!(name in flatStyle)) {\n    return null;\n  }\n  const evaluator = buildExpression(flatStyle[name], NumberArrayType, context);\n  return function (context) {\n    const array = requireNumberArray(evaluator(context), name);\n    if (array.length !== 2) {\n      throw new Error(`Expected two numbers for ${name}`);\n    }\n    return array;\n  };\n}\n\n/**\n * @param {FlatStyle} flatStyle The flat style.\n * @param {string} name The property name.\n * @param {ParsingContext} context The parsing context.\n * @return {import('../../expr/cpu.js').SizeLikeEvaluator?} The expression evaluator.\n */\nfunction sizeLikeEvaluator(flatStyle, name, context) {\n  if (!(name in flatStyle)) {\n    return null;\n  }\n  const evaluator = buildExpression(flatStyle[name], NumberArrayType | NumberType, context);\n  return function (context) {\n    return requireSizeLike(evaluator(context), name);\n  };\n}\n\n/**\n * @param {FlatStyle} flatStyle The flat style.\n * @param {string} property The symbolizer property.\n * @return {number|undefined} A number or undefined.\n */\nfunction optionalNumber(flatStyle, property) {\n  const value = flatStyle[property];\n  if (value === undefined) {\n    return undefined;\n  }\n  if (typeof value !== 'number') {\n    throw new Error(`Expected a number for ${property}`);\n  }\n  return value;\n}\n\n/**\n * @param {FlatStyle} flatStyle The flat style.\n * @param {string} property The symbolizer property.\n * @return {import(\"../../size.js\").Size|undefined} A size or undefined.\n */\nfunction optionalSize(flatStyle, property) {\n  const encoded = flatStyle[property];\n  if (encoded === undefined) {\n    return undefined;\n  }\n  if (typeof encoded === 'number') {\n    return toSize(encoded);\n  }\n  if (!Array.isArray(encoded)) {\n    throw new Error(`Expected a number or size array for ${property}`);\n  }\n  if (encoded.length !== 2 || typeof encoded[0] !== 'number' || typeof encoded[1] !== 'number') {\n    throw new Error(`Expected a number or size array for ${property}`);\n  }\n  return encoded;\n}\n\n/**\n * @param {FlatStyle} flatStyle The flat style.\n * @param {string} property The symbolizer property.\n * @return {string|undefined} A string or undefined.\n */\nfunction optionalString(flatStyle, property) {\n  const encoded = flatStyle[property];\n  if (encoded === undefined) {\n    return undefined;\n  }\n  if (typeof encoded !== 'string') {\n    throw new Error(`Expected a string for ${property}`);\n  }\n  return encoded;\n}\n\n/**\n * @param {FlatStyle} flatStyle The flat style.\n * @param {string} property The symbolizer property.\n * @return {import(\"../../style/Icon.js\").IconOrigin|undefined} An icon origin or undefined.\n */\nfunction optionalIconOrigin(flatStyle, property) {\n  const encoded = flatStyle[property];\n  if (encoded === undefined) {\n    return undefined;\n  }\n  if (encoded !== 'bottom-left' && encoded !== 'bottom-right' && encoded !== 'top-left' && encoded !== 'top-right') {\n    throw new Error(`Expected bottom-left, bottom-right, top-left, or top-right for ${property}`);\n  }\n  return encoded;\n}\n\n/**\n * @param {FlatStyle} flatStyle The flat style.\n * @param {string} property The symbolizer property.\n * @return {import(\"../../style/Icon.js\").IconAnchorUnits|undefined} Icon anchor units or undefined.\n */\nfunction optionalIconAnchorUnits(flatStyle, property) {\n  const encoded = flatStyle[property];\n  if (encoded === undefined) {\n    return undefined;\n  }\n  if (encoded !== 'pixels' && encoded !== 'fraction') {\n    throw new Error(`Expected pixels or fraction for ${property}`);\n  }\n  return encoded;\n}\n\n/**\n * @param {FlatStyle} flatStyle The flat style.\n * @param {string} property The symbolizer property.\n * @return {Array<number>|undefined} An array of numbers or undefined.\n */\nfunction optionalNumberArray(flatStyle, property) {\n  const encoded = flatStyle[property];\n  if (encoded === undefined) {\n    return undefined;\n  }\n  return requireNumberArray(encoded, property);\n}\n\n/**\n * @param {FlatStyle} flatStyle The flat style.\n * @param {string} property The symbolizer property.\n * @return {\"declutter\"|\"obstacle\"|\"none\"|undefined} Icon declutter mode.\n */\nfunction optionalDeclutterMode(flatStyle, property) {\n  const encoded = flatStyle[property];\n  if (encoded === undefined) {\n    return undefined;\n  }\n  if (typeof encoded !== 'string') {\n    throw new Error(`Expected a string for ${property}`);\n  }\n  if (encoded !== 'declutter' && encoded !== 'obstacle' && encoded !== 'none') {\n    throw new Error(`Expected declutter, obstacle, or none for ${property}`);\n  }\n  return encoded;\n}\n\n/**\n * @param {FlatStyle} flatStyle The flat style.\n * @param {string} property The symbolizer property.\n * @return {string|Array<number>|undefined} A string or an array of color values or undefined.\n */\nfunction optionalColorLike(flatStyle, property) {\n  const encoded = flatStyle[property];\n  if (encoded === undefined) {\n    return undefined;\n  }\n  return requireColorLike(encoded, property);\n}\n\n/**\n * @param {any} value The value.\n * @param {string} property The property.\n * @return {Array<number>} An array of numbers.\n */\nfunction requireNumberArray(value, property) {\n  if (!Array.isArray(value)) {\n    throw new Error(`Expected an array for ${property}`);\n  }\n  const length = value.length;\n  for (let i = 0; i < length; ++i) {\n    if (typeof value[i] !== 'number') {\n      throw new Error(`Expected an array of numbers for ${property}`);\n    }\n  }\n  return value;\n}\n\n/**\n * @param {any} value The value.\n * @param {string} property The property.\n * @return {string} A string.\n */\nfunction requireString(value, property) {\n  if (typeof value !== 'string') {\n    throw new Error(`Expected a string for ${property}`);\n  }\n  return value;\n}\n\n/**\n * @param {any} value The value.\n * @param {string} property The property.\n * @return {number} A number.\n */\nfunction requireNumber(value, property) {\n  if (typeof value !== 'number') {\n    throw new Error(`Expected a number for ${property}`);\n  }\n  return value;\n}\n\n/**\n * @param {any} value The value.\n * @param {string} property The property.\n * @return {Array<number>|string} A color.\n */\nfunction requireColorLike(value, property) {\n  if (typeof value === 'string') {\n    return value;\n  }\n  const array = requireNumberArray(value, property);\n  const length = array.length;\n  if (length < 3 || length > 4) {\n    throw new Error(`Expected a color with 3 or 4 values for ${property}`);\n  }\n  return array;\n}\n\n/**\n * @param {any} value The value.\n * @param {string} property The property.\n * @return {number|Array<number>} A number or an array of two numbers.\n */\nfunction requireSizeLike(value, property) {\n  if (typeof value === 'number') {\n    return value;\n  }\n  const size = requireNumberArray(value, property);\n  if (size.length !== 2) {\n    throw new Error(`Expected an array of two numbers for ${property}`);\n  }\n  return size;\n}","map":{"version":3,"names":["Circle","Fill","Icon","RegularShape","Stroke","Style","Text","BooleanType","ColorType","NumberArrayType","NumberType","StringType","newParsingContext","buildExpression","newEvaluationContext","toSize","always","context","rulesToStyleFunction","rules","parsingContext","evaluator","buildRuleSet","evaluationContext","feature","resolution","properties","getPropertiesInternal","flatStylesToStyleFunction","flatStyles","length","evaluators","Array","i","buildStyle","styles","compiledRules","rule","filter","isArray","style","styleLength","j","someMatched","filterEvaluator","else","styleEvaluator","push","flatStyle","evaluateFill","buildFill","evaluateStroke","buildStroke","evaluateText","buildText","evaluateImage","buildImage","evaluateZIndex","numberEvaluator","empty","fill","setFill","stroke","setStroke","text","setText","image","setImage","setZIndex","prefix","evaluateColor","colorLikeEvaluator","color","setColor","evaluateWidth","evaluateLineCap","stringEvaluator","evaluateLineJoin","evaluateLineDash","numberArrayEvaluator","evaluateLineDashOffset","evaluateMiterLimit","setWidth","lineCap","Error","setLineCap","lineJoin","setLineJoin","setLineDash","setLineDashOffset","setMiterLimit","evaluateValue","evaluateBackgroundFill","evaluateBackgroundStroke","evaluateFont","evaluateMaxAngle","evaluateOffsetX","evaluateOffsetY","evaluateOverflow","booleanEvaluator","evaluatePlacement","evaluateRepeat","evaluateScale","sizeLikeEvaluator","evaluateRotateWithView","evaluateRotation","evaluateAlign","evaluateJustify","evaluateBaseline","evaluatePadding","setBackgroundFill","setBackgroundStroke","setFont","setMaxAngle","setOffsetX","setOffsetY","setOverflow","placement","setPlacement","setRepeat","setScale","setRotateWithView","setRotation","textAlign","setTextAlign","justify","setJustify","textBaseline","setTextBaseline","setPadding","buildIcon","buildShape","buildCircle","srcName","src","requireString","evaluateAnchor","coordinateEvaluator","evaluateOpacity","evaluateDisplacement","anchorOrigin","optionalIconOrigin","anchorXUnits","optionalIconAnchorUnits","anchorYUnits","optionalColorLike","crossOrigin","optionalString","offset","optionalNumberArray","offsetOrigin","width","optionalNumber","height","size","optionalSize","declutterMode","optionalDeclutterMode","icon","setOpacity","setDisplacement","setAnchor","pointsName","points","requireNumber","radius","radius1","radius2","angle","shape","evaluateRadius","circle","setRadius","name","undefined","value","requireColorLike","requireNumberArray","array","requireSizeLike","property","encoded"],"sources":["E:/Desktop/scenerymonitor/node_modules/ol/render/canvas/style.js"],"sourcesContent":["/**\n * @module ol/render/canvas/style\n */\n\nimport Circle from '../../style/Circle.js';\nimport Fill from '../../style/Fill.js';\nimport Icon from '../../style/Icon.js';\nimport RegularShape from '../../style/RegularShape.js';\nimport Stroke from '../../style/Stroke.js';\nimport Style from '../../style/Style.js';\nimport Text from '../../style/Text.js';\nimport {\n  BooleanType,\n  ColorType,\n  NumberArrayType,\n  NumberType,\n  StringType,\n  newParsingContext,\n} from '../../expr/expression.js';\nimport {buildExpression, newEvaluationContext} from '../../expr/cpu.js';\nimport {toSize} from '../../size.js';\n\n/**\n * @fileoverview This module includes functions to build styles for the canvas renderer.  Building\n * is composed of two steps: parsing and compiling.  The parsing step takes an encoded expression\n * and returns an instance of one of the expression classes.  The compiling step takes the\n * expression instance and returns a function that can be evaluated to return a literal value.  The\n * evaluator function should do as little allocation and work as possible.\n */\n\n/**\n * @typedef {import(\"../../style/flat.js\").FlatStyle} FlatStyle\n */\n\n/**\n * @typedef {import(\"../../expr/expression.js\").EncodedExpression} EncodedExpression\n */\n\n/**\n * @typedef {import(\"../../expr/expression.js\").ParsingContext} ParsingContext\n */\n\n/**\n * @typedef {import(\"../../expr/expression.js\").CallExpression} CallExpression\n */\n\n/**\n * @typedef {import(\"../../expr/cpu.js\").EvaluationContext} EvaluationContext\n */\n\n/**\n * @typedef {import(\"../../expr/cpu.js\").ExpressionEvaluator} ExpressionEvaluator\n */\n\n/**\n * @param {EvaluationContext} context The evaluation context.\n * @return {boolean} Always true.\n */\nfunction always(context) {\n  return true;\n}\n\n/**\n * This function adapts a rule evaluator to the existing style function interface.\n * After we have deprecated the style function, we can use the compiled rules directly\n * and pass a more complete evaluation context (variables, zoom, time, etc.).\n *\n * @param {Array<import('../../style/flat.js').Rule>} rules The rules.\n * @return {import('../../style/Style.js').StyleFunction} A style function.\n */\nexport function rulesToStyleFunction(rules) {\n  const parsingContext = newParsingContext();\n  const evaluator = buildRuleSet(rules, parsingContext);\n  const evaluationContext = newEvaluationContext();\n  return function (feature, resolution) {\n    evaluationContext.properties = feature.getPropertiesInternal();\n    evaluationContext.resolution = resolution;\n    return evaluator(evaluationContext);\n  };\n}\n\n/**\n * This function adapts a style evaluator to the existing style function interface.\n * After we have deprecated the style function, we can use the compiled rules directly\n * and pass a more complete evaluation context (variables, zoom, time, etc.).\n *\n * @param {Array<import('../../style/flat.js').FlatStyle>} flatStyles The flat styles.\n * @return {import('../../style/Style.js').StyleFunction} A style function.\n */\nexport function flatStylesToStyleFunction(flatStyles) {\n  const parsingContext = newParsingContext();\n  const length = flatStyles.length;\n\n  /**\n   * @type {Array<StyleEvaluator>}\n   */\n  const evaluators = new Array(length);\n  for (let i = 0; i < length; ++i) {\n    evaluators[i] = buildStyle(flatStyles[i], parsingContext);\n  }\n  const evaluationContext = newEvaluationContext();\n\n  /**\n   * @type {Array<Style>}\n   */\n  const styles = new Array(length);\n\n  return function (feature, resolution) {\n    evaluationContext.properties = feature.getPropertiesInternal();\n    evaluationContext.resolution = resolution;\n    for (let i = 0; i < length; ++i) {\n      styles[i] = evaluators[i](evaluationContext);\n    }\n    return styles;\n  };\n}\n\n/**\n * @typedef {function(EvaluationContext):Array<Style>} RuleSetEvaluator\n */\n\n/**\n * @typedef {Object} CompiledRule\n * @property {ExpressionEvaluator} filter The compiled filter evaluator.\n * @property {Array<StyleEvaluator>} styles The list of compiled style evaluators.\n */\n\n/**\n * @param {Array<import('../../style/flat.js').Rule>} rules The rules.\n * @param {ParsingContext} context The parsing context.\n * @return {RuleSetEvaluator} The evaluator function.\n */\nexport function buildRuleSet(rules, context) {\n  const length = rules.length;\n\n  /**\n   * @type {Array<CompiledRule>}\n   */\n  const compiledRules = new Array(length);\n\n  for (let i = 0; i < length; ++i) {\n    const rule = rules[i];\n    const filter =\n      'filter' in rule\n        ? buildExpression(rule.filter, BooleanType, context)\n        : always;\n\n    /**\n     * @type {Array<StyleEvaluator>}\n     */\n    let styles;\n    if (Array.isArray(rule.style)) {\n      const styleLength = rule.style.length;\n      styles = new Array(styleLength);\n      for (let j = 0; j < styleLength; ++j) {\n        styles[j] = buildStyle(rule.style[j], context);\n      }\n    } else {\n      styles = [buildStyle(rule.style, context)];\n    }\n\n    compiledRules[i] = {filter, styles};\n  }\n\n  return function (context) {\n    /**\n     * @type {Array<Style>}\n     */\n    const styles = [];\n\n    let someMatched = false;\n    for (let i = 0; i < length; ++i) {\n      const filterEvaluator = compiledRules[i].filter;\n      if (!filterEvaluator(context)) {\n        continue;\n      }\n      if (rules[i].else && someMatched) {\n        continue;\n      }\n      someMatched = true;\n      for (const styleEvaluator of compiledRules[i].styles) {\n        const style = styleEvaluator(context);\n        if (!style) {\n          continue;\n        }\n        styles.push(style);\n      }\n    }\n\n    return styles;\n  };\n}\n\n/**\n * @typedef {function(EvaluationContext):Style} StyleEvaluator\n */\n\n/**\n * @param {FlatStyle} flatStyle A flat style literal.\n * @param {ParsingContext} context The parsing context.\n * @return {StyleEvaluator} A function that evaluates to a style.  The style returned by\n * this function will be reused between invocations.\n */\nexport function buildStyle(flatStyle, context) {\n  const evaluateFill = buildFill(flatStyle, '', context);\n  const evaluateStroke = buildStroke(flatStyle, '', context);\n  const evaluateText = buildText(flatStyle, context);\n  const evaluateImage = buildImage(flatStyle, context);\n  const evaluateZIndex = numberEvaluator(flatStyle, 'z-index', context);\n\n  const style = new Style();\n  return function (context) {\n    let empty = true;\n    if (evaluateFill) {\n      const fill = evaluateFill(context);\n      if (fill) {\n        empty = false;\n      }\n      style.setFill(fill);\n    }\n    if (evaluateStroke) {\n      const stroke = evaluateStroke(context);\n      if (stroke) {\n        empty = false;\n      }\n      style.setStroke(stroke);\n    }\n    if (evaluateText) {\n      const text = evaluateText(context);\n      if (text) {\n        empty = false;\n      }\n      style.setText(text);\n    }\n    if (evaluateImage) {\n      const image = evaluateImage(context);\n      if (image) {\n        empty = false;\n      }\n      style.setImage(image);\n    }\n    if (evaluateZIndex) {\n      style.setZIndex(evaluateZIndex(context));\n    }\n    if (empty) {\n      return null;\n    }\n    return style;\n  };\n}\n\n/**\n * @typedef {function(EvaluationContext):Fill} FillEvaluator\n */\n\n/**\n * @param {FlatStyle} flatStyle The flat style.\n * @param {string} prefix The property prefix.\n * @param {ParsingContext} context The parsing context.\n * @return {FillEvaluator?} A function that evaluates to a fill.\n */\nfunction buildFill(flatStyle, prefix, context) {\n  const evaluateColor = colorLikeEvaluator(\n    flatStyle,\n    prefix + 'fill-color',\n    context\n  );\n  if (!evaluateColor) {\n    return null;\n  }\n\n  const fill = new Fill();\n  return function (context) {\n    const color = evaluateColor(context);\n    if (color === 'none') {\n      return null;\n    }\n    fill.setColor(color);\n    return fill;\n  };\n}\n\n/**\n * @typedef {function(EvaluationContext):Stroke} StrokeEvaluator\n */\n\n/**\n * @param {FlatStyle} flatStyle The flat style.\n * @param {string} prefix The property prefix.\n * @param {ParsingContext} context The parsing context.\n * @return {StrokeEvaluator?} A function the evaluates to a stroke.\n */\nfunction buildStroke(flatStyle, prefix, context) {\n  const evaluateWidth = numberEvaluator(\n    flatStyle,\n    prefix + 'stroke-width',\n    context\n  );\n\n  const evaluateColor = colorLikeEvaluator(\n    flatStyle,\n    prefix + 'stroke-color',\n    context\n  );\n\n  if (!evaluateWidth && !evaluateColor) {\n    return null;\n  }\n\n  const evaluateLineCap = stringEvaluator(\n    flatStyle,\n    prefix + 'stroke-line-cap',\n    context\n  );\n\n  const evaluateLineJoin = stringEvaluator(\n    flatStyle,\n    prefix + 'stroke-line-join',\n    context\n  );\n\n  const evaluateLineDash = numberArrayEvaluator(\n    flatStyle,\n    prefix + 'stroke-line-dash',\n    context\n  );\n\n  const evaluateLineDashOffset = numberEvaluator(\n    flatStyle,\n    prefix + 'stroke-line-dash-offset',\n    context\n  );\n\n  const evaluateMiterLimit = numberEvaluator(\n    flatStyle,\n    prefix + 'stroke-miter-limit',\n    context\n  );\n\n  const stroke = new Stroke();\n  return function (context) {\n    if (evaluateColor) {\n      const color = evaluateColor(context);\n      if (color === 'none') {\n        return null;\n      }\n      stroke.setColor(color);\n    }\n\n    if (evaluateWidth) {\n      stroke.setWidth(evaluateWidth(context));\n    }\n\n    if (evaluateLineCap) {\n      const lineCap = evaluateLineCap(context);\n      if (lineCap !== 'butt' && lineCap !== 'round' && lineCap !== 'square') {\n        throw new Error('Expected butt, round, or square line cap');\n      }\n      stroke.setLineCap(lineCap);\n    }\n\n    if (evaluateLineJoin) {\n      const lineJoin = evaluateLineJoin(context);\n      if (\n        lineJoin !== 'bevel' &&\n        lineJoin !== 'round' &&\n        lineJoin !== 'miter'\n      ) {\n        throw new Error('Expected bevel, round, or miter line join');\n      }\n      stroke.setLineJoin(lineJoin);\n    }\n\n    if (evaluateLineDash) {\n      stroke.setLineDash(evaluateLineDash(context));\n    }\n\n    if (evaluateLineDashOffset) {\n      stroke.setLineDashOffset(evaluateLineDashOffset(context));\n    }\n\n    if (evaluateMiterLimit) {\n      stroke.setMiterLimit(evaluateMiterLimit(context));\n    }\n\n    return stroke;\n  };\n}\n\n/**\n * @typedef {function(EvaluationContext):Text} TextEvaluator\n */\n\n/**\n * @param {FlatStyle} flatStyle The flat style.\n * @param {ParsingContext} context The parsing context.\n * @return {TextEvaluator?} A function that evaluates to a text symbolizer.\n */\nfunction buildText(flatStyle, context) {\n  const prefix = 'text-';\n\n  // Currently, an Array<string> may be used for rich text support.  This doesn't\n  // work with our expression syntax where arrays of strings are interpreted as\n  // call expressions.  To support rich text, we could add a 'strings' operator\n  // where all the following arguments would be string values.\n  const evaluateValue = stringEvaluator(flatStyle, prefix + 'value', context);\n  if (!evaluateValue) {\n    return null;\n  }\n\n  const evaluateFill = buildFill(flatStyle, prefix, context);\n\n  const evaluateBackgroundFill = buildFill(\n    flatStyle,\n    prefix + 'background-',\n    context\n  );\n\n  const evaluateStroke = buildStroke(flatStyle, prefix, context);\n\n  const evaluateBackgroundStroke = buildStroke(\n    flatStyle,\n    prefix + 'background-',\n    context\n  );\n\n  const evaluateFont = stringEvaluator(flatStyle, prefix + 'font', context);\n\n  const evaluateMaxAngle = numberEvaluator(\n    flatStyle,\n    prefix + 'max-angle',\n    context\n  );\n\n  const evaluateOffsetX = numberEvaluator(\n    flatStyle,\n    prefix + 'offset-x',\n    context\n  );\n\n  const evaluateOffsetY = numberEvaluator(\n    flatStyle,\n    prefix + 'offset-y',\n    context\n  );\n\n  const evaluateOverflow = booleanEvaluator(\n    flatStyle,\n    prefix + 'overflow',\n    context\n  );\n\n  const evaluatePlacement = stringEvaluator(\n    flatStyle,\n    prefix + 'placement',\n    context\n  );\n\n  const evaluateRepeat = numberEvaluator(flatStyle, prefix + 'repeat', context);\n\n  const evaluateScale = sizeLikeEvaluator(flatStyle, prefix + 'scale', context);\n\n  const evaluateRotateWithView = booleanEvaluator(\n    flatStyle,\n    prefix + 'rotate-with-view',\n    context\n  );\n\n  const evaluateRotation = numberEvaluator(\n    flatStyle,\n    prefix + 'rotation',\n    context\n  );\n\n  const evaluateAlign = stringEvaluator(flatStyle, prefix + 'align', context);\n\n  const evaluateJustify = stringEvaluator(\n    flatStyle,\n    prefix + 'justify',\n    context\n  );\n\n  const evaluateBaseline = stringEvaluator(\n    flatStyle,\n    prefix + 'baseline',\n    context\n  );\n\n  const evaluatePadding = numberArrayEvaluator(\n    flatStyle,\n    prefix + 'padding',\n    context\n  );\n\n  const text = new Text({});\n  return function (context) {\n    text.setText(evaluateValue(context));\n\n    if (evaluateFill) {\n      text.setFill(evaluateFill(context));\n    }\n\n    if (evaluateBackgroundFill) {\n      text.setBackgroundFill(evaluateBackgroundFill(context));\n    }\n\n    if (evaluateStroke) {\n      text.setStroke(evaluateStroke(context));\n    }\n\n    if (evaluateBackgroundStroke) {\n      text.setBackgroundStroke(evaluateBackgroundStroke(context));\n    }\n\n    if (evaluateFont) {\n      text.setFont(evaluateFont(context));\n    }\n\n    if (evaluateMaxAngle) {\n      text.setMaxAngle(evaluateMaxAngle(context));\n    }\n\n    if (evaluateOffsetX) {\n      text.setOffsetX(evaluateOffsetX(context));\n    }\n\n    if (evaluateOffsetY) {\n      text.setOffsetY(evaluateOffsetY(context));\n    }\n\n    if (evaluateOverflow) {\n      text.setOverflow(evaluateOverflow(context));\n    }\n\n    if (evaluatePlacement) {\n      const placement = evaluatePlacement(context);\n      if (placement !== 'point' && placement !== 'line') {\n        throw new Error('Expected point or line for text-placement');\n      }\n      text.setPlacement(placement);\n    }\n\n    if (evaluateRepeat) {\n      text.setRepeat(evaluateRepeat(context));\n    }\n\n    if (evaluateScale) {\n      text.setScale(evaluateScale(context));\n    }\n\n    if (evaluateRotateWithView) {\n      text.setRotateWithView(evaluateRotateWithView(context));\n    }\n\n    if (evaluateRotation) {\n      text.setRotation(evaluateRotation(context));\n    }\n\n    if (evaluateAlign) {\n      const textAlign = evaluateAlign(context);\n      if (\n        textAlign !== 'left' &&\n        textAlign !== 'center' &&\n        textAlign !== 'right' &&\n        textAlign !== 'end' &&\n        textAlign !== 'start'\n      ) {\n        throw new Error(\n          'Expected left, right, center, start, or end for text-align'\n        );\n      }\n      text.setTextAlign(textAlign);\n    }\n\n    if (evaluateJustify) {\n      const justify = evaluateJustify(context);\n      if (justify !== 'left' && justify !== 'right' && justify !== 'center') {\n        throw new Error('Expected left, right, or center for text-justify');\n      }\n      text.setJustify(justify);\n    }\n\n    if (evaluateBaseline) {\n      const textBaseline = evaluateBaseline(context);\n      if (\n        textBaseline !== 'bottom' &&\n        textBaseline !== 'top' &&\n        textBaseline !== 'middle' &&\n        textBaseline !== 'alphabetic' &&\n        textBaseline !== 'hanging'\n      ) {\n        throw new Error(\n          'Expected bottom, top, middle, alphabetic, or hanging for text-baseline'\n        );\n      }\n      text.setTextBaseline(textBaseline);\n    }\n\n    if (evaluatePadding) {\n      text.setPadding(evaluatePadding(context));\n    }\n\n    return text;\n  };\n}\n\n/**\n * @typedef {function(EvaluationContext):import(\"../../style/Image.js\").default} ImageEvaluator\n */\n\n/**\n * @param {FlatStyle} flatStyle The flat style.\n * @param {ParsingContext} context The parsing context.\n * @return {ImageEvaluator?} A function that evaluates to an image symbolizer.\n */\nfunction buildImage(flatStyle, context) {\n  if ('icon-src' in flatStyle) {\n    return buildIcon(flatStyle, context);\n  }\n\n  if ('shape-points' in flatStyle) {\n    return buildShape(flatStyle, context);\n  }\n\n  if ('circle-radius' in flatStyle) {\n    return buildCircle(flatStyle, context);\n  }\n\n  return null;\n}\n\n/**\n * @param {FlatStyle} flatStyle The flat style.\n * @param {ParsingContext} context The parsing context.\n * @return {ImageEvaluator} A function that evaluates to an image symbolizer.\n */\nfunction buildIcon(flatStyle, context) {\n  const prefix = 'icon-';\n\n  // required property\n  const srcName = prefix + 'src';\n  const src = requireString(flatStyle[srcName], srcName);\n\n  // settable properties\n  const evaluateAnchor = coordinateEvaluator(\n    flatStyle,\n    prefix + 'anchor',\n    context\n  );\n\n  const evaluateScale = sizeLikeEvaluator(flatStyle, prefix + 'scale', context);\n\n  const evaluateOpacity = numberEvaluator(\n    flatStyle,\n    prefix + 'opacity',\n    context\n  );\n\n  const evaluateDisplacement = coordinateEvaluator(\n    flatStyle,\n    prefix + 'displacement',\n    context\n  );\n\n  const evaluateRotation = numberEvaluator(\n    flatStyle,\n    prefix + 'rotation',\n    context\n  );\n\n  const evaluateRotateWithView = booleanEvaluator(\n    flatStyle,\n    prefix + 'rotate-with-view',\n    context\n  );\n\n  // the remaining symbolizer properties are not currently settable\n  const anchorOrigin = optionalIconOrigin(flatStyle, prefix + 'anchor-origin');\n  const anchorXUnits = optionalIconAnchorUnits(\n    flatStyle,\n    prefix + 'anchor-x-units'\n  );\n  const anchorYUnits = optionalIconAnchorUnits(\n    flatStyle,\n    prefix + 'anchor-y-units'\n  );\n  const color = optionalColorLike(flatStyle, prefix + 'color');\n  const crossOrigin = optionalString(flatStyle, prefix + 'cross-origin');\n  const offset = optionalNumberArray(flatStyle, prefix + 'offset');\n  const offsetOrigin = optionalIconOrigin(flatStyle, prefix + 'offset-origin');\n  const width = optionalNumber(flatStyle, prefix + 'width');\n  const height = optionalNumber(flatStyle, prefix + 'height');\n  const size = optionalSize(flatStyle, prefix + 'size');\n  const declutterMode = optionalDeclutterMode(flatStyle, prefix + 'declutter');\n\n  const icon = new Icon({\n    src,\n    anchorOrigin,\n    anchorXUnits,\n    anchorYUnits,\n    color,\n    crossOrigin,\n    offset,\n    offsetOrigin,\n    height,\n    width,\n    size,\n    declutterMode,\n  });\n\n  return function (context) {\n    if (evaluateOpacity) {\n      icon.setOpacity(evaluateOpacity(context));\n    }\n\n    if (evaluateDisplacement) {\n      icon.setDisplacement(evaluateDisplacement(context));\n    }\n\n    if (evaluateRotation) {\n      icon.setRotation(evaluateRotation(context));\n    }\n\n    if (evaluateRotateWithView) {\n      icon.setRotateWithView(evaluateRotateWithView(context));\n    }\n\n    if (evaluateScale) {\n      icon.setScale(evaluateScale(context));\n    }\n\n    if (evaluateAnchor) {\n      icon.setAnchor(evaluateAnchor(context));\n    }\n    return icon;\n  };\n}\n\n/**\n * @param {FlatStyle} flatStyle The flat style.\n * @param {ParsingContext} context The parsing context.\n * @return {ImageEvaluator} A function that evaluates to an icon symbolizer.\n */\nfunction buildShape(flatStyle, context) {\n  const prefix = 'shape-';\n\n  // required property\n  const pointsName = prefix + 'points';\n  const points = requireNumber(flatStyle[pointsName], pointsName);\n\n  // settable properties\n  const evaluateFill = buildFill(flatStyle, prefix, context);\n  const evaluateStroke = buildStroke(flatStyle, prefix, context);\n  const evaluateScale = sizeLikeEvaluator(flatStyle, prefix + 'scale', context);\n  const evaluateDisplacement = coordinateEvaluator(\n    flatStyle,\n    prefix + 'displacement',\n    context\n  );\n  const evaluateRotation = numberEvaluator(\n    flatStyle,\n    prefix + 'rotation',\n    context\n  );\n  const evaluateRotateWithView = booleanEvaluator(\n    flatStyle,\n    prefix + 'rotate-with-view',\n    context\n  );\n\n  // the remaining properties are not currently settable\n  const radius = optionalNumber(flatStyle, prefix + 'radius');\n  const radius1 = optionalNumber(flatStyle, prefix + 'radius1');\n  const radius2 = optionalNumber(flatStyle, prefix + 'radius2');\n  const angle = optionalNumber(flatStyle, prefix + 'angle');\n  const declutterMode = optionalDeclutterMode(\n    flatStyle,\n    prefix + 'declutter-mode'\n  );\n\n  const shape = new RegularShape({\n    points,\n    radius,\n    radius1,\n    radius2,\n    angle,\n    declutterMode,\n  });\n\n  return function (context) {\n    if (evaluateFill) {\n      shape.setFill(evaluateFill(context));\n    }\n    if (evaluateStroke) {\n      shape.setStroke(evaluateStroke(context));\n    }\n    if (evaluateDisplacement) {\n      shape.setDisplacement(evaluateDisplacement(context));\n    }\n    if (evaluateRotation) {\n      shape.setRotation(evaluateRotation(context));\n    }\n    if (evaluateRotateWithView) {\n      shape.setRotateWithView(evaluateRotateWithView(context));\n    }\n    if (evaluateScale) {\n      shape.setScale(evaluateScale(context));\n    }\n\n    return shape;\n  };\n}\n\n/**\n * @param {FlatStyle} flatStyle The flat style.\n * @param {ParsingContext} context The parsing context.\n * @return {ImageEvaluator} A function that evaluates to a circle symbolizer.\n */\nfunction buildCircle(flatStyle, context) {\n  const prefix = 'circle-';\n\n  // settable properties\n  const evaluateFill = buildFill(flatStyle, prefix, context);\n  const evaluateStroke = buildStroke(flatStyle, prefix, context);\n  const evaluateRadius = numberEvaluator(flatStyle, prefix + 'radius', context);\n  const evaluateScale = sizeLikeEvaluator(flatStyle, prefix + 'scale', context);\n  const evaluateDisplacement = coordinateEvaluator(\n    flatStyle,\n    prefix + 'displacement',\n    context\n  );\n  const evaluateRotation = numberEvaluator(\n    flatStyle,\n    prefix + 'rotation',\n    context\n  );\n  const evaluateRotateWithView = booleanEvaluator(\n    flatStyle,\n    prefix + 'rotate-with-view',\n    context\n  );\n\n  // the remaining properties are not currently settable\n  const declutterMode = optionalDeclutterMode(\n    flatStyle,\n    prefix + 'declutter-mode'\n  );\n\n  const circle = new Circle({\n    radius: 5, // this is arbitrary, but required - the evaluated radius is used below\n    declutterMode,\n  });\n\n  return function (context) {\n    if (evaluateRadius) {\n      circle.setRadius(evaluateRadius(context));\n    }\n    if (evaluateFill) {\n      circle.setFill(evaluateFill(context));\n    }\n    if (evaluateStroke) {\n      circle.setStroke(evaluateStroke(context));\n    }\n    if (evaluateDisplacement) {\n      circle.setDisplacement(evaluateDisplacement(context));\n    }\n    if (evaluateRotation) {\n      circle.setRotation(evaluateRotation(context));\n    }\n    if (evaluateRotateWithView) {\n      circle.setRotateWithView(evaluateRotateWithView(context));\n    }\n    if (evaluateScale) {\n      circle.setScale(evaluateScale(context));\n    }\n\n    return circle;\n  };\n}\n\n/**\n * @param {FlatStyle} flatStyle The flat style.\n * @param {string} name The property name.\n * @param {ParsingContext} context The parsing context.\n * @return {import('../../expr/cpu.js').NumberEvaluator|undefined} The expression evaluator or undefined.\n */\nfunction numberEvaluator(flatStyle, name, context) {\n  if (!(name in flatStyle)) {\n    return undefined;\n  }\n  const evaluator = buildExpression(flatStyle[name], NumberType, context);\n  return function (context) {\n    return requireNumber(evaluator(context), name);\n  };\n}\n\n/**\n * @param {FlatStyle} flatStyle The flat style.\n * @param {string} name The property name.\n * @param {ParsingContext} context The parsing context.\n * @return {import('../../expr/cpu.js').StringEvaluator?} The expression evaluator.\n */\nfunction stringEvaluator(flatStyle, name, context) {\n  if (!(name in flatStyle)) {\n    return null;\n  }\n  const evaluator = buildExpression(flatStyle[name], StringType, context);\n  return function (context) {\n    return requireString(evaluator(context), name);\n  };\n}\n\n/**\n * @param {FlatStyle} flatStyle The flat style.\n * @param {string} name The property name.\n * @param {ParsingContext} context The parsing context.\n * @return {import('../../expr/cpu.js').BooleanEvaluator?} The expression evaluator.\n */\nfunction booleanEvaluator(flatStyle, name, context) {\n  if (!(name in flatStyle)) {\n    return null;\n  }\n  const evaluator = buildExpression(flatStyle[name], BooleanType, context);\n  return function (context) {\n    const value = evaluator(context);\n    if (typeof value !== 'boolean') {\n      throw new Error(`Expected a boolean for ${name}`);\n    }\n    return value;\n  };\n}\n\n/**\n * @param {FlatStyle} flatStyle The flat style.\n * @param {string} name The property name.\n * @param {ParsingContext} context The parsing context.\n * @return {import('../../expr/cpu.js').ColorLikeEvaluator?} The expression evaluator.\n */\nfunction colorLikeEvaluator(flatStyle, name, context) {\n  if (!(name in flatStyle)) {\n    return null;\n  }\n  const evaluator = buildExpression(\n    flatStyle[name],\n    ColorType | StringType,\n    context\n  );\n  return function (context) {\n    return requireColorLike(evaluator(context), name);\n  };\n}\n\n/**\n * @param {FlatStyle} flatStyle The flat style.\n * @param {string} name The property name.\n * @param {ParsingContext} context The parsing context.\n * @return {import('../../expr/cpu.js').NumberArrayEvaluator?} The expression evaluator.\n */\nfunction numberArrayEvaluator(flatStyle, name, context) {\n  if (!(name in flatStyle)) {\n    return null;\n  }\n  const evaluator = buildExpression(flatStyle[name], NumberArrayType, context);\n  return function (context) {\n    return requireNumberArray(evaluator(context), name);\n  };\n}\n\n/**\n * @param {FlatStyle} flatStyle The flat style.\n * @param {string} name The property name.\n * @param {ParsingContext} context The parsing context.\n * @return {import('../../expr/cpu.js').CoordinateEvaluator?} The expression evaluator.\n */\nfunction coordinateEvaluator(flatStyle, name, context) {\n  if (!(name in flatStyle)) {\n    return null;\n  }\n  const evaluator = buildExpression(flatStyle[name], NumberArrayType, context);\n  return function (context) {\n    const array = requireNumberArray(evaluator(context), name);\n    if (array.length !== 2) {\n      throw new Error(`Expected two numbers for ${name}`);\n    }\n    return array;\n  };\n}\n\n/**\n * @param {FlatStyle} flatStyle The flat style.\n * @param {string} name The property name.\n * @param {ParsingContext} context The parsing context.\n * @return {import('../../expr/cpu.js').SizeLikeEvaluator?} The expression evaluator.\n */\nfunction sizeLikeEvaluator(flatStyle, name, context) {\n  if (!(name in flatStyle)) {\n    return null;\n  }\n  const evaluator = buildExpression(\n    flatStyle[name],\n    NumberArrayType | NumberType,\n    context\n  );\n  return function (context) {\n    return requireSizeLike(evaluator(context), name);\n  };\n}\n\n/**\n * @param {FlatStyle} flatStyle The flat style.\n * @param {string} property The symbolizer property.\n * @return {number|undefined} A number or undefined.\n */\nfunction optionalNumber(flatStyle, property) {\n  const value = flatStyle[property];\n  if (value === undefined) {\n    return undefined;\n  }\n  if (typeof value !== 'number') {\n    throw new Error(`Expected a number for ${property}`);\n  }\n  return value;\n}\n\n/**\n * @param {FlatStyle} flatStyle The flat style.\n * @param {string} property The symbolizer property.\n * @return {import(\"../../size.js\").Size|undefined} A size or undefined.\n */\nfunction optionalSize(flatStyle, property) {\n  const encoded = flatStyle[property];\n  if (encoded === undefined) {\n    return undefined;\n  }\n  if (typeof encoded === 'number') {\n    return toSize(encoded);\n  }\n  if (!Array.isArray(encoded)) {\n    throw new Error(`Expected a number or size array for ${property}`);\n  }\n  if (\n    encoded.length !== 2 ||\n    typeof encoded[0] !== 'number' ||\n    typeof encoded[1] !== 'number'\n  ) {\n    throw new Error(`Expected a number or size array for ${property}`);\n  }\n  return encoded;\n}\n\n/**\n * @param {FlatStyle} flatStyle The flat style.\n * @param {string} property The symbolizer property.\n * @return {string|undefined} A string or undefined.\n */\nfunction optionalString(flatStyle, property) {\n  const encoded = flatStyle[property];\n  if (encoded === undefined) {\n    return undefined;\n  }\n  if (typeof encoded !== 'string') {\n    throw new Error(`Expected a string for ${property}`);\n  }\n  return encoded;\n}\n\n/**\n * @param {FlatStyle} flatStyle The flat style.\n * @param {string} property The symbolizer property.\n * @return {import(\"../../style/Icon.js\").IconOrigin|undefined} An icon origin or undefined.\n */\nfunction optionalIconOrigin(flatStyle, property) {\n  const encoded = flatStyle[property];\n  if (encoded === undefined) {\n    return undefined;\n  }\n  if (\n    encoded !== 'bottom-left' &&\n    encoded !== 'bottom-right' &&\n    encoded !== 'top-left' &&\n    encoded !== 'top-right'\n  ) {\n    throw new Error(\n      `Expected bottom-left, bottom-right, top-left, or top-right for ${property}`\n    );\n  }\n  return encoded;\n}\n\n/**\n * @param {FlatStyle} flatStyle The flat style.\n * @param {string} property The symbolizer property.\n * @return {import(\"../../style/Icon.js\").IconAnchorUnits|undefined} Icon anchor units or undefined.\n */\nfunction optionalIconAnchorUnits(flatStyle, property) {\n  const encoded = flatStyle[property];\n  if (encoded === undefined) {\n    return undefined;\n  }\n  if (encoded !== 'pixels' && encoded !== 'fraction') {\n    throw new Error(`Expected pixels or fraction for ${property}`);\n  }\n  return encoded;\n}\n\n/**\n * @param {FlatStyle} flatStyle The flat style.\n * @param {string} property The symbolizer property.\n * @return {Array<number>|undefined} An array of numbers or undefined.\n */\nfunction optionalNumberArray(flatStyle, property) {\n  const encoded = flatStyle[property];\n  if (encoded === undefined) {\n    return undefined;\n  }\n  return requireNumberArray(encoded, property);\n}\n\n/**\n * @param {FlatStyle} flatStyle The flat style.\n * @param {string} property The symbolizer property.\n * @return {\"declutter\"|\"obstacle\"|\"none\"|undefined} Icon declutter mode.\n */\nfunction optionalDeclutterMode(flatStyle, property) {\n  const encoded = flatStyle[property];\n  if (encoded === undefined) {\n    return undefined;\n  }\n  if (typeof encoded !== 'string') {\n    throw new Error(`Expected a string for ${property}`);\n  }\n  if (encoded !== 'declutter' && encoded !== 'obstacle' && encoded !== 'none') {\n    throw new Error(`Expected declutter, obstacle, or none for ${property}`);\n  }\n  return encoded;\n}\n\n/**\n * @param {FlatStyle} flatStyle The flat style.\n * @param {string} property The symbolizer property.\n * @return {string|Array<number>|undefined} A string or an array of color values or undefined.\n */\nfunction optionalColorLike(flatStyle, property) {\n  const encoded = flatStyle[property];\n  if (encoded === undefined) {\n    return undefined;\n  }\n  return requireColorLike(encoded, property);\n}\n\n/**\n * @param {any} value The value.\n * @param {string} property The property.\n * @return {Array<number>} An array of numbers.\n */\nfunction requireNumberArray(value, property) {\n  if (!Array.isArray(value)) {\n    throw new Error(`Expected an array for ${property}`);\n  }\n  const length = value.length;\n  for (let i = 0; i < length; ++i) {\n    if (typeof value[i] !== 'number') {\n      throw new Error(`Expected an array of numbers for ${property}`);\n    }\n  }\n  return value;\n}\n\n/**\n * @param {any} value The value.\n * @param {string} property The property.\n * @return {string} A string.\n */\nfunction requireString(value, property) {\n  if (typeof value !== 'string') {\n    throw new Error(`Expected a string for ${property}`);\n  }\n  return value;\n}\n\n/**\n * @param {any} value The value.\n * @param {string} property The property.\n * @return {number} A number.\n */\nfunction requireNumber(value, property) {\n  if (typeof value !== 'number') {\n    throw new Error(`Expected a number for ${property}`);\n  }\n  return value;\n}\n\n/**\n * @param {any} value The value.\n * @param {string} property The property.\n * @return {Array<number>|string} A color.\n */\nfunction requireColorLike(value, property) {\n  if (typeof value === 'string') {\n    return value;\n  }\n  const array = requireNumberArray(value, property);\n  const length = array.length;\n  if (length < 3 || length > 4) {\n    throw new Error(`Expected a color with 3 or 4 values for ${property}`);\n  }\n  return array;\n}\n\n/**\n * @param {any} value The value.\n * @param {string} property The property.\n * @return {number|Array<number>} A number or an array of two numbers.\n */\nfunction requireSizeLike(value, property) {\n  if (typeof value === 'number') {\n    return value;\n  }\n  const size = requireNumberArray(value, property);\n  if (size.length !== 2) {\n    throw new Error(`Expected an array of two numbers for ${property}`);\n  }\n  return size;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}