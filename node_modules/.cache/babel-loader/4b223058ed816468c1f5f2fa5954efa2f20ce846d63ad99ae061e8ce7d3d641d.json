{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\n/**\n * @module ol/color\n */\nimport { clamp } from './math.js';\n\n/**\n * A color represented as a short array [red, green, blue, alpha].\n * red, green, and blue should be integers in the range 0..255 inclusive.\n * alpha should be a float in the range 0..1 inclusive. If no alpha value is\n * given then `1` will be used.\n * @typedef {Array<number>} Color\n * @api\n */\n\n/**\n * This RegExp matches # followed by 3, 4, 6, or 8 hex digits.\n * @const\n * @type {RegExp}\n * @private\n */\nconst HEX_COLOR_RE_ = /^#([a-f0-9]{3}|[a-f0-9]{4}(?:[a-f0-9]{2}){0,2})$/i;\n\n/**\n * Regular expression for matching potential named color style strings.\n * @const\n * @type {RegExp}\n * @private\n */\nconst NAMED_COLOR_RE_ = /^([a-z]*)$|^hsla?\\(.*\\)$/i;\n\n/**\n * Return the color as an rgba string.\n * @param {Color|string} color Color.\n * @return {string} Rgba string.\n * @api\n */\nexport function asString(color) {\n  if (typeof color === 'string') {\n    return color;\n  }\n  return toString(color);\n}\n\n/**\n * Return named color as an rgba string.\n * @param {string} color Named color.\n * @return {string} Rgb string.\n */\nfunction fromNamed(color) {\n  const el = document.createElement('div');\n  el.style.color = color;\n  if (el.style.color !== '') {\n    document.body.appendChild(el);\n    const rgb = getComputedStyle(el).color;\n    document.body.removeChild(el);\n    return rgb;\n  }\n  return '';\n}\n\n/**\n * @param {string} s String.\n * @return {Color} Color.\n */\nexport const fromString = function () {\n  // We maintain a small cache of parsed strings.  To provide cheap LRU-like\n  // semantics, whenever the cache grows too large we simply delete an\n  // arbitrary 25% of the entries.\n\n  /**\n   * @const\n   * @type {number}\n   */\n  const MAX_CACHE_SIZE = 1024;\n\n  /**\n   * @type {Object<string, Color>}\n   */\n  const cache = {};\n\n  /**\n   * @type {number}\n   */\n  let cacheSize = 0;\n  return (\n    /**\n     * @param {string} s String.\n     * @return {Color} Color.\n     */\n    function (s) {\n      let color;\n      if (cache.hasOwnProperty(s)) {\n        color = cache[s];\n      } else {\n        if (cacheSize >= MAX_CACHE_SIZE) {\n          let i = 0;\n          for (const key in cache) {\n            if ((i++ & 3) === 0) {\n              delete cache[key];\n              --cacheSize;\n            }\n          }\n        }\n        color = fromStringInternal_(s);\n        cache[s] = color;\n        ++cacheSize;\n      }\n      return color;\n    }\n  );\n}();\n\n/**\n * Return the color as an array. This function maintains a cache of calculated\n * arrays which means the result should not be modified.\n * @param {Color|string} color Color.\n * @return {Color} Color.\n * @api\n */\nexport function asArray(color) {\n  if (Array.isArray(color)) {\n    return color;\n  }\n  return fromString(color);\n}\n\n/**\n * @param {string} s String.\n * @private\n * @return {Color} Color.\n */\nfunction fromStringInternal_(s) {\n  let r, g, b, a, color;\n  if (NAMED_COLOR_RE_.exec(s)) {\n    s = fromNamed(s);\n  }\n  if (HEX_COLOR_RE_.exec(s)) {\n    // hex\n    const n = s.length - 1; // number of hex digits\n    let d; // number of digits per channel\n    if (n <= 4) {\n      d = 1;\n    } else {\n      d = 2;\n    }\n    const hasAlpha = n === 4 || n === 8;\n    r = parseInt(s.substr(1 + 0 * d, d), 16);\n    g = parseInt(s.substr(1 + 1 * d, d), 16);\n    b = parseInt(s.substr(1 + 2 * d, d), 16);\n    if (hasAlpha) {\n      a = parseInt(s.substr(1 + 3 * d, d), 16);\n    } else {\n      a = 255;\n    }\n    if (d == 1) {\n      r = (r << 4) + r;\n      g = (g << 4) + g;\n      b = (b << 4) + b;\n      if (hasAlpha) {\n        a = (a << 4) + a;\n      }\n    }\n    color = [r, g, b, a / 255];\n  } else if (s.startsWith('rgba(')) {\n    // rgba()\n    color = s.slice(5, -1).split(',').map(Number);\n    normalize(color);\n  } else if (s.startsWith('rgb(')) {\n    // rgb()\n    color = s.slice(4, -1).split(',').map(Number);\n    color.push(1);\n    normalize(color);\n  } else {\n    throw new Error('Invalid color');\n  }\n  return color;\n}\n\n/**\n * TODO this function is only used in the test, we probably shouldn't export it\n * @param {Color} color Color.\n * @return {Color} Clamped color.\n */\nexport function normalize(color) {\n  color[0] = clamp(color[0] + 0.5 | 0, 0, 255);\n  color[1] = clamp(color[1] + 0.5 | 0, 0, 255);\n  color[2] = clamp(color[2] + 0.5 | 0, 0, 255);\n  color[3] = clamp(color[3], 0, 1);\n  return color;\n}\n\n/**\n * @param {Color} color Color.\n * @return {string} String.\n */\nexport function toString(color) {\n  let r = color[0];\n  if (r != (r | 0)) {\n    r = r + 0.5 | 0;\n  }\n  let g = color[1];\n  if (g != (g | 0)) {\n    g = g + 0.5 | 0;\n  }\n  let b = color[2];\n  if (b != (b | 0)) {\n    b = b + 0.5 | 0;\n  }\n  const a = color[3] === undefined ? 1 : Math.round(color[3] * 100) / 100;\n  return 'rgba(' + r + ',' + g + ',' + b + ',' + a + ')';\n}\n\n/**\n * @param {string} s String.\n * @return {boolean} Whether the string is actually a valid color\n */\nexport function isStringColor(s) {\n  if (NAMED_COLOR_RE_.test(s)) {\n    s = fromNamed(s);\n  }\n  return HEX_COLOR_RE_.test(s) || s.startsWith('rgba(') || s.startsWith('rgb(');\n}","map":{"version":3,"names":["clamp","HEX_COLOR_RE_","NAMED_COLOR_RE_","asString","color","toString","fromNamed","el","document","createElement","style","body","appendChild","rgb","getComputedStyle","removeChild","fromString","MAX_CACHE_SIZE","cache","cacheSize","s","hasOwnProperty","i","key","fromStringInternal_","asArray","Array","isArray","r","g","b","a","exec","n","length","d","hasAlpha","parseInt","substr","startsWith","slice","split","map","Number","normalize","push","Error","undefined","Math","round","isStringColor","test"],"sources":["E:/Desktop/SceneryPlatform_v3.0_LTS/node_modules/ol/color.js"],"sourcesContent":["/**\n * @module ol/color\n */\nimport {clamp} from './math.js';\n\n/**\n * A color represented as a short array [red, green, blue, alpha].\n * red, green, and blue should be integers in the range 0..255 inclusive.\n * alpha should be a float in the range 0..1 inclusive. If no alpha value is\n * given then `1` will be used.\n * @typedef {Array<number>} Color\n * @api\n */\n\n/**\n * This RegExp matches # followed by 3, 4, 6, or 8 hex digits.\n * @const\n * @type {RegExp}\n * @private\n */\nconst HEX_COLOR_RE_ = /^#([a-f0-9]{3}|[a-f0-9]{4}(?:[a-f0-9]{2}){0,2})$/i;\n\n/**\n * Regular expression for matching potential named color style strings.\n * @const\n * @type {RegExp}\n * @private\n */\nconst NAMED_COLOR_RE_ = /^([a-z]*)$|^hsla?\\(.*\\)$/i;\n\n/**\n * Return the color as an rgba string.\n * @param {Color|string} color Color.\n * @return {string} Rgba string.\n * @api\n */\nexport function asString(color) {\n  if (typeof color === 'string') {\n    return color;\n  }\n  return toString(color);\n}\n\n/**\n * Return named color as an rgba string.\n * @param {string} color Named color.\n * @return {string} Rgb string.\n */\nfunction fromNamed(color) {\n  const el = document.createElement('div');\n  el.style.color = color;\n  if (el.style.color !== '') {\n    document.body.appendChild(el);\n    const rgb = getComputedStyle(el).color;\n    document.body.removeChild(el);\n    return rgb;\n  }\n  return '';\n}\n\n/**\n * @param {string} s String.\n * @return {Color} Color.\n */\nexport const fromString = (function () {\n  // We maintain a small cache of parsed strings.  To provide cheap LRU-like\n  // semantics, whenever the cache grows too large we simply delete an\n  // arbitrary 25% of the entries.\n\n  /**\n   * @const\n   * @type {number}\n   */\n  const MAX_CACHE_SIZE = 1024;\n\n  /**\n   * @type {Object<string, Color>}\n   */\n  const cache = {};\n\n  /**\n   * @type {number}\n   */\n  let cacheSize = 0;\n\n  return (\n    /**\n     * @param {string} s String.\n     * @return {Color} Color.\n     */\n    function (s) {\n      let color;\n      if (cache.hasOwnProperty(s)) {\n        color = cache[s];\n      } else {\n        if (cacheSize >= MAX_CACHE_SIZE) {\n          let i = 0;\n          for (const key in cache) {\n            if ((i++ & 3) === 0) {\n              delete cache[key];\n              --cacheSize;\n            }\n          }\n        }\n        color = fromStringInternal_(s);\n        cache[s] = color;\n        ++cacheSize;\n      }\n      return color;\n    }\n  );\n})();\n\n/**\n * Return the color as an array. This function maintains a cache of calculated\n * arrays which means the result should not be modified.\n * @param {Color|string} color Color.\n * @return {Color} Color.\n * @api\n */\nexport function asArray(color) {\n  if (Array.isArray(color)) {\n    return color;\n  }\n  return fromString(color);\n}\n\n/**\n * @param {string} s String.\n * @private\n * @return {Color} Color.\n */\nfunction fromStringInternal_(s) {\n  let r, g, b, a, color;\n\n  if (NAMED_COLOR_RE_.exec(s)) {\n    s = fromNamed(s);\n  }\n\n  if (HEX_COLOR_RE_.exec(s)) {\n    // hex\n    const n = s.length - 1; // number of hex digits\n    let d; // number of digits per channel\n    if (n <= 4) {\n      d = 1;\n    } else {\n      d = 2;\n    }\n    const hasAlpha = n === 4 || n === 8;\n    r = parseInt(s.substr(1 + 0 * d, d), 16);\n    g = parseInt(s.substr(1 + 1 * d, d), 16);\n    b = parseInt(s.substr(1 + 2 * d, d), 16);\n    if (hasAlpha) {\n      a = parseInt(s.substr(1 + 3 * d, d), 16);\n    } else {\n      a = 255;\n    }\n    if (d == 1) {\n      r = (r << 4) + r;\n      g = (g << 4) + g;\n      b = (b << 4) + b;\n      if (hasAlpha) {\n        a = (a << 4) + a;\n      }\n    }\n    color = [r, g, b, a / 255];\n  } else if (s.startsWith('rgba(')) {\n    // rgba()\n    color = s.slice(5, -1).split(',').map(Number);\n    normalize(color);\n  } else if (s.startsWith('rgb(')) {\n    // rgb()\n    color = s.slice(4, -1).split(',').map(Number);\n    color.push(1);\n    normalize(color);\n  } else {\n    throw new Error('Invalid color');\n  }\n  return color;\n}\n\n/**\n * TODO this function is only used in the test, we probably shouldn't export it\n * @param {Color} color Color.\n * @return {Color} Clamped color.\n */\nexport function normalize(color) {\n  color[0] = clamp((color[0] + 0.5) | 0, 0, 255);\n  color[1] = clamp((color[1] + 0.5) | 0, 0, 255);\n  color[2] = clamp((color[2] + 0.5) | 0, 0, 255);\n  color[3] = clamp(color[3], 0, 1);\n  return color;\n}\n\n/**\n * @param {Color} color Color.\n * @return {string} String.\n */\nexport function toString(color) {\n  let r = color[0];\n  if (r != (r | 0)) {\n    r = (r + 0.5) | 0;\n  }\n  let g = color[1];\n  if (g != (g | 0)) {\n    g = (g + 0.5) | 0;\n  }\n  let b = color[2];\n  if (b != (b | 0)) {\n    b = (b + 0.5) | 0;\n  }\n  const a = color[3] === undefined ? 1 : Math.round(color[3] * 100) / 100;\n  return 'rgba(' + r + ',' + g + ',' + b + ',' + a + ')';\n}\n\n/**\n * @param {string} s String.\n * @return {boolean} Whether the string is actually a valid color\n */\nexport function isStringColor(s) {\n  if (NAMED_COLOR_RE_.test(s)) {\n    s = fromNamed(s);\n  }\n  return HEX_COLOR_RE_.test(s) || s.startsWith('rgba(') || s.startsWith('rgb(');\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}