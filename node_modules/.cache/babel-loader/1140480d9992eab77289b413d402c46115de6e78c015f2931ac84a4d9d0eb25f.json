{"ast":null,"code":"/**\n * @module ol/renderer/webgl/Layer\n */\nimport LayerProperty from '../../layer/Property.js';\nimport LayerRenderer from '../Layer.js';\nimport RenderEvent from '../../render/Event.js';\nimport RenderEventType from '../../render/EventType.js';\nimport WebGLHelper from '../../webgl/Helper.js';\nimport { compose as composeTransform, create as createTransform } from '../../transform.js';\n\n/**\n * @typedef {Object} PostProcessesOptions\n * @property {number} [scaleRatio] Scale ratio; if < 1, the post process will render to a texture smaller than\n * the main canvas that will then be sampled up (useful for saving resource on blur steps).\n * @property {string} [vertexShader] Vertex shader source\n * @property {string} [fragmentShader] Fragment shader source\n * @property {Object<string,import(\"../../webgl/Helper\").UniformValue>} [uniforms] Uniform definitions for the post process step\n */\n\n/**\n * @typedef {Object} Options\n * @property {Object<string,import(\"../../webgl/Helper\").UniformValue>} [uniforms] Uniform definitions for the post process steps\n * @property {Array<PostProcessesOptions>} [postProcesses] Post-processes definitions\n */\n\n/**\n * @classdesc\n * Base WebGL renderer class.\n * Holds all logic related to data manipulation & some common rendering logic\n * @template {import(\"../../layer/Layer.js\").default} LayerType\n * @extends {LayerRenderer<LayerType>}\n */\nclass WebGLLayerRenderer extends LayerRenderer {\n  /**\n   * @param {LayerType} layer Layer.\n   * @param {Options} [options] Options.\n   */\n  constructor(layer, options) {\n    super(layer);\n    options = options || {};\n\n    /**\n     * The transform for viewport CSS pixels to rendered pixels.  This transform is only\n     * set before dispatching rendering events.\n     * @private\n     * @type {import(\"../../transform.js\").Transform}\n     */\n    this.inversePixelTransform_ = createTransform();\n\n    /**\n     * @private\n     * @type {CanvasRenderingContext2D}\n     */\n    this.pixelContext_ = null;\n\n    /**\n     * @private\n     */\n    this.postProcesses_ = options.postProcesses;\n\n    /**\n     * @private\n     */\n    this.uniforms_ = options.uniforms;\n\n    /**\n     * @type {WebGLHelper}\n     * @protected\n     */\n    this.helper;\n    layer.addChangeListener(LayerProperty.MAP, this.removeHelper.bind(this));\n    this.dispatchPreComposeEvent = this.dispatchPreComposeEvent.bind(this);\n    this.dispatchPostComposeEvent = this.dispatchPostComposeEvent.bind(this);\n  }\n\n  /**\n   * @param {WebGLRenderingContext} context The WebGL rendering context.\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @protected\n   */\n  dispatchPreComposeEvent(context, frameState) {\n    const layer = this.getLayer();\n    if (layer.hasListener(RenderEventType.PRECOMPOSE)) {\n      const event = new RenderEvent(RenderEventType.PRECOMPOSE, undefined, frameState, context);\n      layer.dispatchEvent(event);\n    }\n  }\n\n  /**\n   * @param {WebGLRenderingContext} context The WebGL rendering context.\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @protected\n   */\n  dispatchPostComposeEvent(context, frameState) {\n    const layer = this.getLayer();\n    if (layer.hasListener(RenderEventType.POSTCOMPOSE)) {\n      const event = new RenderEvent(RenderEventType.POSTCOMPOSE, undefined, frameState, context);\n      layer.dispatchEvent(event);\n    }\n  }\n\n  /**\n   * Reset options (only handles uniforms).\n   * @param {Options} options Options.\n   */\n  reset(options) {\n    this.uniforms_ = options.uniforms;\n    if (this.helper) {\n      this.helper.setUniforms(this.uniforms_);\n    }\n  }\n\n  /**\n   * @protected\n   */\n  removeHelper() {\n    if (this.helper) {\n      this.helper.dispose();\n      delete this.helper;\n    }\n  }\n\n  /**\n   * Determine whether renderFrame should be called.\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @return {boolean} Layer is ready to be rendered.\n   */\n  prepareFrame(frameState) {\n    if (this.getLayer().getRenderSource()) {\n      let incrementGroup = true;\n      let groupNumber = -1;\n      let className;\n      for (let i = 0, ii = frameState.layerStatesArray.length; i < ii; i++) {\n        const layer = frameState.layerStatesArray[i].layer;\n        const renderer = layer.getRenderer();\n        if (!(renderer instanceof WebGLLayerRenderer)) {\n          incrementGroup = true;\n          continue;\n        }\n        const layerClassName = layer.getClassName();\n        if (incrementGroup || layerClassName !== className) {\n          groupNumber += 1;\n          incrementGroup = false;\n        }\n        className = layerClassName;\n        if (renderer === this) {\n          break;\n        }\n      }\n      const canvasCacheKey = 'map/' + frameState.mapId + '/group/' + groupNumber;\n      if (!this.helper || !this.helper.canvasCacheKeyMatches(canvasCacheKey) || this.helper.needsToBeRecreated()) {\n        this.removeHelper();\n        this.helper = new WebGLHelper({\n          postProcesses: this.postProcesses_,\n          uniforms: this.uniforms_,\n          canvasCacheKey: canvasCacheKey\n        });\n        if (className) {\n          this.helper.getCanvas().className = className;\n        }\n        this.afterHelperCreated();\n      }\n    }\n    return this.prepareFrameInternal(frameState);\n  }\n\n  /**\n   * @protected\n   */\n  afterHelperCreated() {}\n\n  /**\n   * Determine whether renderFrame should be called.\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @return {boolean} Layer is ready to be rendered.\n   * @protected\n   */\n  prepareFrameInternal(frameState) {\n    return true;\n  }\n\n  /**\n   * Clean up.\n   */\n  disposeInternal() {\n    this.removeHelper();\n    super.disposeInternal();\n  }\n\n  /**\n   * @param {import(\"../../render/EventType.js\").default} type Event type.\n   * @param {WebGLRenderingContext} context The rendering context.\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @private\n   */\n  dispatchRenderEvent_(type, context, frameState) {\n    const layer = this.getLayer();\n    if (layer.hasListener(type)) {\n      composeTransform(this.inversePixelTransform_, 0, 0, frameState.pixelRatio, -frameState.pixelRatio, 0, 0, -frameState.size[1]);\n      const event = new RenderEvent(type, this.inversePixelTransform_, frameState, context);\n      layer.dispatchEvent(event);\n    }\n  }\n\n  /**\n   * @param {WebGLRenderingContext} context The rendering context.\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @protected\n   */\n  preRender(context, frameState) {\n    this.dispatchRenderEvent_(RenderEventType.PRERENDER, context, frameState);\n  }\n\n  /**\n   * @param {WebGLRenderingContext} context The rendering context.\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @protected\n   */\n  postRender(context, frameState) {\n    this.dispatchRenderEvent_(RenderEventType.POSTRENDER, context, frameState);\n  }\n}\nexport default WebGLLayerRenderer;","map":{"version":3,"names":["LayerProperty","LayerRenderer","RenderEvent","RenderEventType","WebGLHelper","compose","composeTransform","create","createTransform","WebGLLayerRenderer","constructor","layer","options","inversePixelTransform_","pixelContext_","postProcesses_","postProcesses","uniforms_","uniforms","helper","addChangeListener","MAP","removeHelper","bind","dispatchPreComposeEvent","dispatchPostComposeEvent","context","frameState","getLayer","hasListener","PRECOMPOSE","event","undefined","dispatchEvent","POSTCOMPOSE","reset","setUniforms","dispose","prepareFrame","getRenderSource","incrementGroup","groupNumber","className","i","ii","layerStatesArray","length","renderer","getRenderer","layerClassName","getClassName","canvasCacheKey","mapId","canvasCacheKeyMatches","needsToBeRecreated","getCanvas","afterHelperCreated","prepareFrameInternal","disposeInternal","dispatchRenderEvent_","type","pixelRatio","size","preRender","PRERENDER","postRender","POSTRENDER"],"sources":["E:/Desktop/scenerymonitor/node_modules/ol/renderer/webgl/Layer.js"],"sourcesContent":["/**\n * @module ol/renderer/webgl/Layer\n */\nimport LayerProperty from '../../layer/Property.js';\nimport LayerRenderer from '../Layer.js';\nimport RenderEvent from '../../render/Event.js';\nimport RenderEventType from '../../render/EventType.js';\nimport WebGLHelper from '../../webgl/Helper.js';\nimport {\n  compose as composeTransform,\n  create as createTransform,\n} from '../../transform.js';\n\n/**\n * @typedef {Object} PostProcessesOptions\n * @property {number} [scaleRatio] Scale ratio; if < 1, the post process will render to a texture smaller than\n * the main canvas that will then be sampled up (useful for saving resource on blur steps).\n * @property {string} [vertexShader] Vertex shader source\n * @property {string} [fragmentShader] Fragment shader source\n * @property {Object<string,import(\"../../webgl/Helper\").UniformValue>} [uniforms] Uniform definitions for the post process step\n */\n\n/**\n * @typedef {Object} Options\n * @property {Object<string,import(\"../../webgl/Helper\").UniformValue>} [uniforms] Uniform definitions for the post process steps\n * @property {Array<PostProcessesOptions>} [postProcesses] Post-processes definitions\n */\n\n/**\n * @classdesc\n * Base WebGL renderer class.\n * Holds all logic related to data manipulation & some common rendering logic\n * @template {import(\"../../layer/Layer.js\").default} LayerType\n * @extends {LayerRenderer<LayerType>}\n */\nclass WebGLLayerRenderer extends LayerRenderer {\n  /**\n   * @param {LayerType} layer Layer.\n   * @param {Options} [options] Options.\n   */\n  constructor(layer, options) {\n    super(layer);\n\n    options = options || {};\n\n    /**\n     * The transform for viewport CSS pixels to rendered pixels.  This transform is only\n     * set before dispatching rendering events.\n     * @private\n     * @type {import(\"../../transform.js\").Transform}\n     */\n    this.inversePixelTransform_ = createTransform();\n\n    /**\n     * @private\n     * @type {CanvasRenderingContext2D}\n     */\n    this.pixelContext_ = null;\n\n    /**\n     * @private\n     */\n    this.postProcesses_ = options.postProcesses;\n\n    /**\n     * @private\n     */\n    this.uniforms_ = options.uniforms;\n\n    /**\n     * @type {WebGLHelper}\n     * @protected\n     */\n    this.helper;\n\n    layer.addChangeListener(LayerProperty.MAP, this.removeHelper.bind(this));\n\n    this.dispatchPreComposeEvent = this.dispatchPreComposeEvent.bind(this);\n    this.dispatchPostComposeEvent = this.dispatchPostComposeEvent.bind(this);\n  }\n\n  /**\n   * @param {WebGLRenderingContext} context The WebGL rendering context.\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @protected\n   */\n  dispatchPreComposeEvent(context, frameState) {\n    const layer = this.getLayer();\n    if (layer.hasListener(RenderEventType.PRECOMPOSE)) {\n      const event = new RenderEvent(\n        RenderEventType.PRECOMPOSE,\n        undefined,\n        frameState,\n        context\n      );\n      layer.dispatchEvent(event);\n    }\n  }\n\n  /**\n   * @param {WebGLRenderingContext} context The WebGL rendering context.\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @protected\n   */\n  dispatchPostComposeEvent(context, frameState) {\n    const layer = this.getLayer();\n    if (layer.hasListener(RenderEventType.POSTCOMPOSE)) {\n      const event = new RenderEvent(\n        RenderEventType.POSTCOMPOSE,\n        undefined,\n        frameState,\n        context\n      );\n      layer.dispatchEvent(event);\n    }\n  }\n\n  /**\n   * Reset options (only handles uniforms).\n   * @param {Options} options Options.\n   */\n  reset(options) {\n    this.uniforms_ = options.uniforms;\n    if (this.helper) {\n      this.helper.setUniforms(this.uniforms_);\n    }\n  }\n\n  /**\n   * @protected\n   */\n  removeHelper() {\n    if (this.helper) {\n      this.helper.dispose();\n      delete this.helper;\n    }\n  }\n\n  /**\n   * Determine whether renderFrame should be called.\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @return {boolean} Layer is ready to be rendered.\n   */\n  prepareFrame(frameState) {\n    if (this.getLayer().getRenderSource()) {\n      let incrementGroup = true;\n      let groupNumber = -1;\n      let className;\n      for (let i = 0, ii = frameState.layerStatesArray.length; i < ii; i++) {\n        const layer = frameState.layerStatesArray[i].layer;\n        const renderer = layer.getRenderer();\n        if (!(renderer instanceof WebGLLayerRenderer)) {\n          incrementGroup = true;\n          continue;\n        }\n        const layerClassName = layer.getClassName();\n        if (incrementGroup || layerClassName !== className) {\n          groupNumber += 1;\n          incrementGroup = false;\n        }\n        className = layerClassName;\n        if (renderer === this) {\n          break;\n        }\n      }\n\n      const canvasCacheKey =\n        'map/' + frameState.mapId + '/group/' + groupNumber;\n\n      if (\n        !this.helper ||\n        !this.helper.canvasCacheKeyMatches(canvasCacheKey) ||\n        this.helper.needsToBeRecreated()\n      ) {\n        this.removeHelper();\n\n        this.helper = new WebGLHelper({\n          postProcesses: this.postProcesses_,\n          uniforms: this.uniforms_,\n          canvasCacheKey: canvasCacheKey,\n        });\n\n        if (className) {\n          this.helper.getCanvas().className = className;\n        }\n\n        this.afterHelperCreated();\n      }\n    }\n\n    return this.prepareFrameInternal(frameState);\n  }\n\n  /**\n   * @protected\n   */\n  afterHelperCreated() {}\n\n  /**\n   * Determine whether renderFrame should be called.\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @return {boolean} Layer is ready to be rendered.\n   * @protected\n   */\n  prepareFrameInternal(frameState) {\n    return true;\n  }\n\n  /**\n   * Clean up.\n   */\n  disposeInternal() {\n    this.removeHelper();\n    super.disposeInternal();\n  }\n\n  /**\n   * @param {import(\"../../render/EventType.js\").default} type Event type.\n   * @param {WebGLRenderingContext} context The rendering context.\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @private\n   */\n  dispatchRenderEvent_(type, context, frameState) {\n    const layer = this.getLayer();\n    if (layer.hasListener(type)) {\n      composeTransform(\n        this.inversePixelTransform_,\n        0,\n        0,\n        frameState.pixelRatio,\n        -frameState.pixelRatio,\n        0,\n        0,\n        -frameState.size[1]\n      );\n\n      const event = new RenderEvent(\n        type,\n        this.inversePixelTransform_,\n        frameState,\n        context\n      );\n      layer.dispatchEvent(event);\n    }\n  }\n\n  /**\n   * @param {WebGLRenderingContext} context The rendering context.\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @protected\n   */\n  preRender(context, frameState) {\n    this.dispatchRenderEvent_(RenderEventType.PRERENDER, context, frameState);\n  }\n\n  /**\n   * @param {WebGLRenderingContext} context The rendering context.\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @protected\n   */\n  postRender(context, frameState) {\n    this.dispatchRenderEvent_(RenderEventType.POSTRENDER, context, frameState);\n  }\n}\n\nexport default WebGLLayerRenderer;\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}