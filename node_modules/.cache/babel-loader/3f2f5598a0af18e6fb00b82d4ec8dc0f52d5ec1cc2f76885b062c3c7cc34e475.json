{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\n/**\n * @module ol/render/webgl/utils\n */\nimport earcut from 'earcut';\nimport { apply as applyTransform } from '../../transform.js';\nimport { clamp } from '../../math.js';\nconst tmpArray_ = [];\n\n/**\n * An object holding positions both in an index and a vertex buffer.\n * @typedef {Object} BufferPositions\n * @property {number} vertexPosition Position in the vertex buffer\n * @property {number} indexPosition Position in the index buffer\n */\nconst bufferPositions_ = {\n  vertexPosition: 0,\n  indexPosition: 0\n};\nfunction writePointVertex(buffer, pos, x, y, index) {\n  buffer[pos + 0] = x;\n  buffer[pos + 1] = y;\n  buffer[pos + 2] = index;\n}\n\n/**\n * Pushes a quad (two triangles) based on a point geometry\n * @param {Float32Array} instructions Array of render instructions for points.\n * @param {number} elementIndex Index from which render instructions will be read.\n * @param {Float32Array} vertexBuffer Buffer in the form of a typed array.\n * @param {Uint32Array} indexBuffer Buffer in the form of a typed array.\n * @param {number} customAttributesSize Amount of custom attributes for each element.\n * @param {BufferPositions} [bufferPositions] Buffer write positions; if not specified, positions will be set at 0.\n * @return {BufferPositions} New buffer positions where to write next\n * @property {number} vertexPosition New position in the vertex buffer where future writes should start.\n * @property {number} indexPosition New position in the index buffer where future writes should start.\n * @private\n */\nexport function writePointFeatureToBuffers(instructions, elementIndex, vertexBuffer, indexBuffer, customAttributesSize, bufferPositions) {\n  // This is for x, y and index\n  const baseVertexAttrsCount = 3;\n  const baseInstructionsCount = 2;\n  const stride = baseVertexAttrsCount + customAttributesSize;\n  const x = instructions[elementIndex + 0];\n  const y = instructions[elementIndex + 1];\n\n  // read custom numerical attributes on the feature\n  const customAttrs = tmpArray_;\n  customAttrs.length = customAttributesSize;\n  for (let i = 0; i < customAttrs.length; i++) {\n    customAttrs[i] = instructions[elementIndex + baseInstructionsCount + i];\n  }\n  let vPos = bufferPositions ? bufferPositions.vertexPosition : 0;\n  let iPos = bufferPositions ? bufferPositions.indexPosition : 0;\n  const baseIndex = vPos / stride;\n\n  // push vertices for each of the four quad corners (first standard then custom attributes)\n  writePointVertex(vertexBuffer, vPos, x, y, 0);\n  customAttrs.length && vertexBuffer.set(customAttrs, vPos + baseVertexAttrsCount);\n  vPos += stride;\n  writePointVertex(vertexBuffer, vPos, x, y, 1);\n  customAttrs.length && vertexBuffer.set(customAttrs, vPos + baseVertexAttrsCount);\n  vPos += stride;\n  writePointVertex(vertexBuffer, vPos, x, y, 2);\n  customAttrs.length && vertexBuffer.set(customAttrs, vPos + baseVertexAttrsCount);\n  vPos += stride;\n  writePointVertex(vertexBuffer, vPos, x, y, 3);\n  customAttrs.length && vertexBuffer.set(customAttrs, vPos + baseVertexAttrsCount);\n  vPos += stride;\n  indexBuffer[iPos++] = baseIndex;\n  indexBuffer[iPos++] = baseIndex + 1;\n  indexBuffer[iPos++] = baseIndex + 3;\n  indexBuffer[iPos++] = baseIndex + 1;\n  indexBuffer[iPos++] = baseIndex + 2;\n  indexBuffer[iPos++] = baseIndex + 3;\n  bufferPositions_.vertexPosition = vPos;\n  bufferPositions_.indexPosition = iPos;\n  return bufferPositions_;\n}\n\n/**\n * Pushes a single quad to form a line segment; also includes a computation for the join angles with previous and next\n * segment, in order to be able to offset the vertices correctly in the shader\n * @param {Float32Array} instructions Array of render instructions for lines.\n * @param {number} segmentStartIndex Index of the segment start point from which render instructions will be read.\n * @param {number} segmentEndIndex Index of the segment end point from which render instructions will be read.\n * @param {number|null} beforeSegmentIndex Index of the point right before the segment (null if none, e.g this is a line start)\n * @param {number|null} afterSegmentIndex Index of the point right after the segment (null if none, e.g this is a line end)\n * @param {Array<number>} vertexArray Array containing vertices.\n * @param {Array<number>} indexArray Array containing indices.\n * @param {Array<number>} customAttributes Array of custom attributes value\n * @param {import('../../transform.js').Transform} toWorldTransform Transform matrix used to obtain world coordinates from instructions\n * @param {number} currentLength Cumulated length of segments processed so far\n * @return {number} Cumulated length with the newly processed segment (in world units)\n * @private\n */\nexport function writeLineSegmentToBuffers(instructions, segmentStartIndex, segmentEndIndex, beforeSegmentIndex, afterSegmentIndex, vertexArray, indexArray, customAttributes, toWorldTransform, currentLength) {\n  // compute the stride to determine how many vertices were already pushed\n  const baseVertexAttrsCount = 8; // base attributes: x0, y0, x1, y1, angle0, angle1, distance, params\n  const stride = baseVertexAttrsCount + customAttributes.length;\n  const baseIndex = vertexArray.length / stride;\n\n  // The segment is composed of two positions called P0[x0, y0] and P1[x1, y1]\n  // Depending on whether there are points before and after the segment, its final shape\n  // will be different\n  const p0 = [instructions[segmentStartIndex + 0], instructions[segmentStartIndex + 1]];\n  const p1 = [instructions[segmentEndIndex], instructions[segmentEndIndex + 1]];\n\n  // to compute join angles we need to reproject coordinates back in world units\n  const p0world = applyTransform(toWorldTransform, [...p0]);\n  const p1world = applyTransform(toWorldTransform, [...p1]);\n\n  // compute the angle between p0pA and p0pB\n  // returns a value in [0, 2PI]\n  function angleBetween(p0, pA, pB) {\n    const lenA = Math.sqrt((pA[0] - p0[0]) * (pA[0] - p0[0]) + (pA[1] - p0[1]) * (pA[1] - p0[1]));\n    const tangentA = [(pA[0] - p0[0]) / lenA, (pA[1] - p0[1]) / lenA];\n    const orthoA = [-tangentA[1], tangentA[0]];\n    const lenB = Math.sqrt((pB[0] - p0[0]) * (pB[0] - p0[0]) + (pB[1] - p0[1]) * (pB[1] - p0[1]));\n    const tangentB = [(pB[0] - p0[0]) / lenB, (pB[1] - p0[1]) / lenB];\n\n    // this angle can be clockwise or anticlockwise; hence the computation afterwards\n    const angle = lenA === 0 || lenB === 0 ? 0 : Math.acos(clamp(tangentB[0] * tangentA[0] + tangentB[1] * tangentA[1], -1, 1));\n    const isClockwise = tangentB[0] * orthoA[0] + tangentB[1] * orthoA[1] > 0;\n    return !isClockwise ? Math.PI * 2 - angle : angle;\n  }\n\n  // a negative angle indicates a line cap\n  let angle0 = -1;\n  let angle1 = -1;\n  const joinBefore = beforeSegmentIndex !== null;\n  const joinAfter = afterSegmentIndex !== null;\n\n  // add vertices and adapt offsets for P0 in case of join\n  if (joinBefore) {\n    // B for before\n    const pB = [instructions[beforeSegmentIndex], instructions[beforeSegmentIndex + 1]];\n    const pBworld = applyTransform(toWorldTransform, [...pB]);\n    angle0 = angleBetween(p0world, p1world, pBworld);\n  }\n  // adapt offsets for P1 in case of join\n  if (joinAfter) {\n    // A for after\n    const pA = [instructions[afterSegmentIndex], instructions[afterSegmentIndex + 1]];\n    const pAworld = applyTransform(toWorldTransform, [...pA]);\n    angle1 = angleBetween(p1world, p0world, pAworld);\n  }\n\n  // add main segment triangles\n  vertexArray.push(p0[0], p0[1], p1[0], p1[1], angle0, angle1, currentLength, 0);\n  vertexArray.push(...customAttributes);\n  vertexArray.push(p0[0], p0[1], p1[0], p1[1], angle0, angle1, currentLength, 1);\n  vertexArray.push(...customAttributes);\n  vertexArray.push(p0[0], p0[1], p1[0], p1[1], angle0, angle1, currentLength, 2);\n  vertexArray.push(...customAttributes);\n  vertexArray.push(p0[0], p0[1], p1[0], p1[1], angle0, angle1, currentLength, 3);\n  vertexArray.push(...customAttributes);\n  indexArray.push(baseIndex, baseIndex + 1, baseIndex + 2, baseIndex + 1, baseIndex + 3, baseIndex + 2);\n  return currentLength + Math.sqrt((p1world[0] - p0world[0]) * (p1world[0] - p0world[0]) + (p1world[1] - p0world[1]) * (p1world[1] - p0world[1]));\n}\n\n/**\n * Pushes several triangles to form a polygon, including holes\n * @param {Float32Array} instructions Array of render instructions for lines.\n * @param {number} polygonStartIndex Index of the polygon start point from which render instructions will be read.\n * @param {Array<number>} vertexArray Array containing vertices.\n * @param {Array<number>} indexArray Array containing indices.\n * @param {number} customAttributesSize Amount of custom attributes for each element.\n * @return {number} Next polygon instructions index\n * @private\n */\nexport function writePolygonTrianglesToBuffers(instructions, polygonStartIndex, vertexArray, indexArray, customAttributesSize) {\n  const instructionsPerVertex = 2; // x, y\n  const attributesPerVertex = 2 + customAttributesSize;\n  let instructionsIndex = polygonStartIndex;\n  const customAttributes = instructions.slice(instructionsIndex, instructionsIndex + customAttributesSize);\n  instructionsIndex += customAttributesSize;\n  const ringsCount = instructions[instructionsIndex++];\n  let verticesCount = 0;\n  const holes = new Array(ringsCount - 1);\n  for (let i = 0; i < ringsCount; i++) {\n    verticesCount += instructions[instructionsIndex++];\n    if (i < ringsCount - 1) {\n      holes[i] = verticesCount;\n    }\n  }\n  const flatCoords = instructions.slice(instructionsIndex, instructionsIndex + verticesCount * instructionsPerVertex);\n\n  // pushing to vertices and indices!! this is where the magic happens\n  const result = earcut(flatCoords, holes, instructionsPerVertex);\n  for (let i = 0; i < result.length; i++) {\n    indexArray.push(result[i] + vertexArray.length / attributesPerVertex);\n  }\n  for (let i = 0; i < flatCoords.length; i += 2) {\n    vertexArray.push(flatCoords[i], flatCoords[i + 1], ...customAttributes);\n  }\n  return instructionsIndex + verticesCount * instructionsPerVertex;\n}\n\n/**\n * Returns a texture of 1x1 pixel, white\n * @private\n * @return {ImageData} Image data.\n */\nexport function getBlankImageData() {\n  const canvas = document.createElement('canvas');\n  const image = canvas.getContext('2d').createImageData(1, 1);\n  image.data[0] = 255;\n  image.data[1] = 255;\n  image.data[2] = 255;\n  image.data[3] = 255;\n  return image;\n}\n\n/**\n * Generates a color array based on a numerical id\n * Note: the range for each component is 0 to 1 with 256 steps\n * @param {number} id Id\n * @param {Array<number>} [array] Reusable array\n * @return {Array<number>} Color array containing the encoded id\n */\nexport function colorEncodeId(id, array) {\n  array = array || [];\n  const radix = 256;\n  const divide = radix - 1;\n  array[0] = Math.floor(id / radix / radix / radix) / divide;\n  array[1] = Math.floor(id / radix / radix) % radix / divide;\n  array[2] = Math.floor(id / radix) % radix / divide;\n  array[3] = id % radix / divide;\n  return array;\n}\n\n/**\n * Reads an id from a color-encoded array\n * Note: the expected range for each component is 0 to 1 with 256 steps.\n * @param {Array<number>} color Color array containing the encoded id\n * @return {number} Decoded id\n */\nexport function colorDecodeId(color) {\n  let id = 0;\n  const radix = 256;\n  const mult = radix - 1;\n  id += Math.round(color[0] * radix * radix * radix * mult);\n  id += Math.round(color[1] * radix * radix * mult);\n  id += Math.round(color[2] * radix * mult);\n  id += Math.round(color[3] * mult);\n  return id;\n}","map":{"version":3,"names":["earcut","apply","applyTransform","clamp","tmpArray_","bufferPositions_","vertexPosition","indexPosition","writePointVertex","buffer","pos","x","y","index","writePointFeatureToBuffers","instructions","elementIndex","vertexBuffer","indexBuffer","customAttributesSize","bufferPositions","baseVertexAttrsCount","baseInstructionsCount","stride","customAttrs","length","i","vPos","iPos","baseIndex","set","writeLineSegmentToBuffers","segmentStartIndex","segmentEndIndex","beforeSegmentIndex","afterSegmentIndex","vertexArray","indexArray","customAttributes","toWorldTransform","currentLength","p0","p1","p0world","p1world","angleBetween","pA","pB","lenA","Math","sqrt","tangentA","orthoA","lenB","tangentB","angle","acos","isClockwise","PI","angle0","angle1","joinBefore","joinAfter","pBworld","pAworld","push","writePolygonTrianglesToBuffers","polygonStartIndex","instructionsPerVertex","attributesPerVertex","instructionsIndex","slice","ringsCount","verticesCount","holes","Array","flatCoords","result","getBlankImageData","canvas","document","createElement","image","getContext","createImageData","data","colorEncodeId","id","array","radix","divide","floor","colorDecodeId","color","mult","round"],"sources":["E:/Desktop/SceneryPlatform_v3.0_LTS/node_modules/ol/render/webgl/utils.js"],"sourcesContent":["/**\n * @module ol/render/webgl/utils\n */\nimport earcut from 'earcut';\nimport {apply as applyTransform} from '../../transform.js';\nimport {clamp} from '../../math.js';\n\nconst tmpArray_ = [];\n\n/**\n * An object holding positions both in an index and a vertex buffer.\n * @typedef {Object} BufferPositions\n * @property {number} vertexPosition Position in the vertex buffer\n * @property {number} indexPosition Position in the index buffer\n */\nconst bufferPositions_ = {vertexPosition: 0, indexPosition: 0};\n\nfunction writePointVertex(buffer, pos, x, y, index) {\n  buffer[pos + 0] = x;\n  buffer[pos + 1] = y;\n  buffer[pos + 2] = index;\n}\n\n/**\n * Pushes a quad (two triangles) based on a point geometry\n * @param {Float32Array} instructions Array of render instructions for points.\n * @param {number} elementIndex Index from which render instructions will be read.\n * @param {Float32Array} vertexBuffer Buffer in the form of a typed array.\n * @param {Uint32Array} indexBuffer Buffer in the form of a typed array.\n * @param {number} customAttributesSize Amount of custom attributes for each element.\n * @param {BufferPositions} [bufferPositions] Buffer write positions; if not specified, positions will be set at 0.\n * @return {BufferPositions} New buffer positions where to write next\n * @property {number} vertexPosition New position in the vertex buffer where future writes should start.\n * @property {number} indexPosition New position in the index buffer where future writes should start.\n * @private\n */\nexport function writePointFeatureToBuffers(\n  instructions,\n  elementIndex,\n  vertexBuffer,\n  indexBuffer,\n  customAttributesSize,\n  bufferPositions\n) {\n  // This is for x, y and index\n  const baseVertexAttrsCount = 3;\n  const baseInstructionsCount = 2;\n  const stride = baseVertexAttrsCount + customAttributesSize;\n\n  const x = instructions[elementIndex + 0];\n  const y = instructions[elementIndex + 1];\n\n  // read custom numerical attributes on the feature\n  const customAttrs = tmpArray_;\n  customAttrs.length = customAttributesSize;\n  for (let i = 0; i < customAttrs.length; i++) {\n    customAttrs[i] = instructions[elementIndex + baseInstructionsCount + i];\n  }\n\n  let vPos = bufferPositions ? bufferPositions.vertexPosition : 0;\n  let iPos = bufferPositions ? bufferPositions.indexPosition : 0;\n  const baseIndex = vPos / stride;\n\n  // push vertices for each of the four quad corners (first standard then custom attributes)\n  writePointVertex(vertexBuffer, vPos, x, y, 0);\n  customAttrs.length &&\n    vertexBuffer.set(customAttrs, vPos + baseVertexAttrsCount);\n  vPos += stride;\n\n  writePointVertex(vertexBuffer, vPos, x, y, 1);\n  customAttrs.length &&\n    vertexBuffer.set(customAttrs, vPos + baseVertexAttrsCount);\n  vPos += stride;\n\n  writePointVertex(vertexBuffer, vPos, x, y, 2);\n  customAttrs.length &&\n    vertexBuffer.set(customAttrs, vPos + baseVertexAttrsCount);\n  vPos += stride;\n\n  writePointVertex(vertexBuffer, vPos, x, y, 3);\n  customAttrs.length &&\n    vertexBuffer.set(customAttrs, vPos + baseVertexAttrsCount);\n  vPos += stride;\n\n  indexBuffer[iPos++] = baseIndex;\n  indexBuffer[iPos++] = baseIndex + 1;\n  indexBuffer[iPos++] = baseIndex + 3;\n  indexBuffer[iPos++] = baseIndex + 1;\n  indexBuffer[iPos++] = baseIndex + 2;\n  indexBuffer[iPos++] = baseIndex + 3;\n\n  bufferPositions_.vertexPosition = vPos;\n  bufferPositions_.indexPosition = iPos;\n\n  return bufferPositions_;\n}\n\n/**\n * Pushes a single quad to form a line segment; also includes a computation for the join angles with previous and next\n * segment, in order to be able to offset the vertices correctly in the shader\n * @param {Float32Array} instructions Array of render instructions for lines.\n * @param {number} segmentStartIndex Index of the segment start point from which render instructions will be read.\n * @param {number} segmentEndIndex Index of the segment end point from which render instructions will be read.\n * @param {number|null} beforeSegmentIndex Index of the point right before the segment (null if none, e.g this is a line start)\n * @param {number|null} afterSegmentIndex Index of the point right after the segment (null if none, e.g this is a line end)\n * @param {Array<number>} vertexArray Array containing vertices.\n * @param {Array<number>} indexArray Array containing indices.\n * @param {Array<number>} customAttributes Array of custom attributes value\n * @param {import('../../transform.js').Transform} toWorldTransform Transform matrix used to obtain world coordinates from instructions\n * @param {number} currentLength Cumulated length of segments processed so far\n * @return {number} Cumulated length with the newly processed segment (in world units)\n * @private\n */\nexport function writeLineSegmentToBuffers(\n  instructions,\n  segmentStartIndex,\n  segmentEndIndex,\n  beforeSegmentIndex,\n  afterSegmentIndex,\n  vertexArray,\n  indexArray,\n  customAttributes,\n  toWorldTransform,\n  currentLength\n) {\n  // compute the stride to determine how many vertices were already pushed\n  const baseVertexAttrsCount = 8; // base attributes: x0, y0, x1, y1, angle0, angle1, distance, params\n  const stride = baseVertexAttrsCount + customAttributes.length;\n  const baseIndex = vertexArray.length / stride;\n\n  // The segment is composed of two positions called P0[x0, y0] and P1[x1, y1]\n  // Depending on whether there are points before and after the segment, its final shape\n  // will be different\n  const p0 = [\n    instructions[segmentStartIndex + 0],\n    instructions[segmentStartIndex + 1],\n  ];\n  const p1 = [instructions[segmentEndIndex], instructions[segmentEndIndex + 1]];\n\n  // to compute join angles we need to reproject coordinates back in world units\n  const p0world = applyTransform(toWorldTransform, [...p0]);\n  const p1world = applyTransform(toWorldTransform, [...p1]);\n\n  // compute the angle between p0pA and p0pB\n  // returns a value in [0, 2PI]\n  function angleBetween(p0, pA, pB) {\n    const lenA = Math.sqrt(\n      (pA[0] - p0[0]) * (pA[0] - p0[0]) + (pA[1] - p0[1]) * (pA[1] - p0[1])\n    );\n    const tangentA = [(pA[0] - p0[0]) / lenA, (pA[1] - p0[1]) / lenA];\n    const orthoA = [-tangentA[1], tangentA[0]];\n    const lenB = Math.sqrt(\n      (pB[0] - p0[0]) * (pB[0] - p0[0]) + (pB[1] - p0[1]) * (pB[1] - p0[1])\n    );\n    const tangentB = [(pB[0] - p0[0]) / lenB, (pB[1] - p0[1]) / lenB];\n\n    // this angle can be clockwise or anticlockwise; hence the computation afterwards\n    const angle =\n      lenA === 0 || lenB === 0\n        ? 0\n        : Math.acos(\n            clamp(tangentB[0] * tangentA[0] + tangentB[1] * tangentA[1], -1, 1)\n          );\n    const isClockwise = tangentB[0] * orthoA[0] + tangentB[1] * orthoA[1] > 0;\n    return !isClockwise ? Math.PI * 2 - angle : angle;\n  }\n\n  // a negative angle indicates a line cap\n  let angle0 = -1;\n  let angle1 = -1;\n\n  const joinBefore = beforeSegmentIndex !== null;\n  const joinAfter = afterSegmentIndex !== null;\n\n  // add vertices and adapt offsets for P0 in case of join\n  if (joinBefore) {\n    // B for before\n    const pB = [\n      instructions[beforeSegmentIndex],\n      instructions[beforeSegmentIndex + 1],\n    ];\n    const pBworld = applyTransform(toWorldTransform, [...pB]);\n    angle0 = angleBetween(p0world, p1world, pBworld);\n  }\n  // adapt offsets for P1 in case of join\n  if (joinAfter) {\n    // A for after\n    const pA = [\n      instructions[afterSegmentIndex],\n      instructions[afterSegmentIndex + 1],\n    ];\n    const pAworld = applyTransform(toWorldTransform, [...pA]);\n    angle1 = angleBetween(p1world, p0world, pAworld);\n  }\n\n  // add main segment triangles\n  vertexArray.push(\n    p0[0],\n    p0[1],\n    p1[0],\n    p1[1],\n    angle0,\n    angle1,\n    currentLength,\n    0\n  );\n  vertexArray.push(...customAttributes);\n\n  vertexArray.push(\n    p0[0],\n    p0[1],\n    p1[0],\n    p1[1],\n    angle0,\n    angle1,\n    currentLength,\n    1\n  );\n  vertexArray.push(...customAttributes);\n\n  vertexArray.push(\n    p0[0],\n    p0[1],\n    p1[0],\n    p1[1],\n    angle0,\n    angle1,\n    currentLength,\n    2\n  );\n  vertexArray.push(...customAttributes);\n\n  vertexArray.push(\n    p0[0],\n    p0[1],\n    p1[0],\n    p1[1],\n    angle0,\n    angle1,\n    currentLength,\n    3\n  );\n  vertexArray.push(...customAttributes);\n\n  indexArray.push(\n    baseIndex,\n    baseIndex + 1,\n    baseIndex + 2,\n    baseIndex + 1,\n    baseIndex + 3,\n    baseIndex + 2\n  );\n\n  return (\n    currentLength +\n    Math.sqrt(\n      (p1world[0] - p0world[0]) * (p1world[0] - p0world[0]) +\n        (p1world[1] - p0world[1]) * (p1world[1] - p0world[1])\n    )\n  );\n}\n\n/**\n * Pushes several triangles to form a polygon, including holes\n * @param {Float32Array} instructions Array of render instructions for lines.\n * @param {number} polygonStartIndex Index of the polygon start point from which render instructions will be read.\n * @param {Array<number>} vertexArray Array containing vertices.\n * @param {Array<number>} indexArray Array containing indices.\n * @param {number} customAttributesSize Amount of custom attributes for each element.\n * @return {number} Next polygon instructions index\n * @private\n */\nexport function writePolygonTrianglesToBuffers(\n  instructions,\n  polygonStartIndex,\n  vertexArray,\n  indexArray,\n  customAttributesSize\n) {\n  const instructionsPerVertex = 2; // x, y\n  const attributesPerVertex = 2 + customAttributesSize;\n  let instructionsIndex = polygonStartIndex;\n  const customAttributes = instructions.slice(\n    instructionsIndex,\n    instructionsIndex + customAttributesSize\n  );\n  instructionsIndex += customAttributesSize;\n  const ringsCount = instructions[instructionsIndex++];\n  let verticesCount = 0;\n  const holes = new Array(ringsCount - 1);\n  for (let i = 0; i < ringsCount; i++) {\n    verticesCount += instructions[instructionsIndex++];\n    if (i < ringsCount - 1) {\n      holes[i] = verticesCount;\n    }\n  }\n  const flatCoords = instructions.slice(\n    instructionsIndex,\n    instructionsIndex + verticesCount * instructionsPerVertex\n  );\n\n  // pushing to vertices and indices!! this is where the magic happens\n  const result = earcut(flatCoords, holes, instructionsPerVertex);\n  for (let i = 0; i < result.length; i++) {\n    indexArray.push(result[i] + vertexArray.length / attributesPerVertex);\n  }\n  for (let i = 0; i < flatCoords.length; i += 2) {\n    vertexArray.push(flatCoords[i], flatCoords[i + 1], ...customAttributes);\n  }\n\n  return instructionsIndex + verticesCount * instructionsPerVertex;\n}\n\n/**\n * Returns a texture of 1x1 pixel, white\n * @private\n * @return {ImageData} Image data.\n */\nexport function getBlankImageData() {\n  const canvas = document.createElement('canvas');\n  const image = canvas.getContext('2d').createImageData(1, 1);\n  image.data[0] = 255;\n  image.data[1] = 255;\n  image.data[2] = 255;\n  image.data[3] = 255;\n  return image;\n}\n\n/**\n * Generates a color array based on a numerical id\n * Note: the range for each component is 0 to 1 with 256 steps\n * @param {number} id Id\n * @param {Array<number>} [array] Reusable array\n * @return {Array<number>} Color array containing the encoded id\n */\nexport function colorEncodeId(id, array) {\n  array = array || [];\n  const radix = 256;\n  const divide = radix - 1;\n  array[0] = Math.floor(id / radix / radix / radix) / divide;\n  array[1] = (Math.floor(id / radix / radix) % radix) / divide;\n  array[2] = (Math.floor(id / radix) % radix) / divide;\n  array[3] = (id % radix) / divide;\n  return array;\n}\n\n/**\n * Reads an id from a color-encoded array\n * Note: the expected range for each component is 0 to 1 with 256 steps.\n * @param {Array<number>} color Color array containing the encoded id\n * @return {number} Decoded id\n */\nexport function colorDecodeId(color) {\n  let id = 0;\n  const radix = 256;\n  const mult = radix - 1;\n  id += Math.round(color[0] * radix * radix * radix * mult);\n  id += Math.round(color[1] * radix * radix * mult);\n  id += Math.round(color[2] * radix * mult);\n  id += Math.round(color[3] * mult);\n  return id;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}