{"ast":null,"code":"/**\n * @module resample\n */\n\nfunction copyNewSize(array, width, height, samplesPerPixel = 1) {\n  return new (Object.getPrototypeOf(array).constructor)(width * height * samplesPerPixel);\n}\n\n/**\n * Resample the input arrays using nearest neighbor value selection.\n * @param {TypedArray[]} valueArrays The input arrays to resample\n * @param {number} inWidth The width of the input rasters\n * @param {number} inHeight The height of the input rasters\n * @param {number} outWidth The desired width of the output rasters\n * @param {number} outHeight The desired height of the output rasters\n * @returns {TypedArray[]} The resampled rasters\n */\nexport function resampleNearest(valueArrays, inWidth, inHeight, outWidth, outHeight) {\n  const relX = inWidth / outWidth;\n  const relY = inHeight / outHeight;\n  return valueArrays.map(array => {\n    const newArray = copyNewSize(array, outWidth, outHeight);\n    for (let y = 0; y < outHeight; ++y) {\n      const cy = Math.min(Math.round(relY * y), inHeight - 1);\n      for (let x = 0; x < outWidth; ++x) {\n        const cx = Math.min(Math.round(relX * x), inWidth - 1);\n        const value = array[cy * inWidth + cx];\n        newArray[y * outWidth + x] = value;\n      }\n    }\n    return newArray;\n  });\n}\n\n// simple linear interpolation, code from:\n// https://en.wikipedia.org/wiki/Linear_interpolation#Programming_language_support\nfunction lerp(v0, v1, t) {\n  return (1 - t) * v0 + t * v1;\n}\n\n/**\n * Resample the input arrays using bilinear interpolation.\n * @param {TypedArray[]} valueArrays The input arrays to resample\n * @param {number} inWidth The width of the input rasters\n * @param {number} inHeight The height of the input rasters\n * @param {number} outWidth The desired width of the output rasters\n * @param {number} outHeight The desired height of the output rasters\n * @returns {TypedArray[]} The resampled rasters\n */\nexport function resampleBilinear(valueArrays, inWidth, inHeight, outWidth, outHeight) {\n  const relX = inWidth / outWidth;\n  const relY = inHeight / outHeight;\n  return valueArrays.map(array => {\n    const newArray = copyNewSize(array, outWidth, outHeight);\n    for (let y = 0; y < outHeight; ++y) {\n      const rawY = relY * y;\n      const yl = Math.floor(rawY);\n      const yh = Math.min(Math.ceil(rawY), inHeight - 1);\n      for (let x = 0; x < outWidth; ++x) {\n        const rawX = relX * x;\n        const tx = rawX % 1;\n        const xl = Math.floor(rawX);\n        const xh = Math.min(Math.ceil(rawX), inWidth - 1);\n        const ll = array[yl * inWidth + xl];\n        const hl = array[yl * inWidth + xh];\n        const lh = array[yh * inWidth + xl];\n        const hh = array[yh * inWidth + xh];\n        const value = lerp(lerp(ll, hl, tx), lerp(lh, hh, tx), rawY % 1);\n        newArray[y * outWidth + x] = value;\n      }\n    }\n    return newArray;\n  });\n}\n\n/**\n * Resample the input arrays using the selected resampling method.\n * @param {TypedArray[]} valueArrays The input arrays to resample\n * @param {number} inWidth The width of the input rasters\n * @param {number} inHeight The height of the input rasters\n * @param {number} outWidth The desired width of the output rasters\n * @param {number} outHeight The desired height of the output rasters\n * @param {string} [method = 'nearest'] The desired resampling method\n * @returns {TypedArray[]} The resampled rasters\n */\nexport function resample(valueArrays, inWidth, inHeight, outWidth, outHeight, method = 'nearest') {\n  switch (method.toLowerCase()) {\n    case 'nearest':\n      return resampleNearest(valueArrays, inWidth, inHeight, outWidth, outHeight);\n    case 'bilinear':\n    case 'linear':\n      return resampleBilinear(valueArrays, inWidth, inHeight, outWidth, outHeight);\n    default:\n      throw new Error(`Unsupported resampling method: '${method}'`);\n  }\n}\n\n/**\n * Resample the pixel interleaved input array using nearest neighbor value selection.\n * @param {TypedArray} valueArrays The input arrays to resample\n * @param {number} inWidth The width of the input rasters\n * @param {number} inHeight The height of the input rasters\n * @param {number} outWidth The desired width of the output rasters\n * @param {number} outHeight The desired height of the output rasters\n * @param {number} samples The number of samples per pixel for pixel\n *                         interleaved data\n * @returns {TypedArray} The resampled raster\n */\nexport function resampleNearestInterleaved(valueArray, inWidth, inHeight, outWidth, outHeight, samples) {\n  const relX = inWidth / outWidth;\n  const relY = inHeight / outHeight;\n  const newArray = copyNewSize(valueArray, outWidth, outHeight, samples);\n  for (let y = 0; y < outHeight; ++y) {\n    const cy = Math.min(Math.round(relY * y), inHeight - 1);\n    for (let x = 0; x < outWidth; ++x) {\n      const cx = Math.min(Math.round(relX * x), inWidth - 1);\n      for (let i = 0; i < samples; ++i) {\n        const value = valueArray[cy * inWidth * samples + cx * samples + i];\n        newArray[y * outWidth * samples + x * samples + i] = value;\n      }\n    }\n  }\n  return newArray;\n}\n\n/**\n * Resample the pixel interleaved input array using bilinear interpolation.\n * @param {TypedArray} valueArrays The input arrays to resample\n * @param {number} inWidth The width of the input rasters\n * @param {number} inHeight The height of the input rasters\n * @param {number} outWidth The desired width of the output rasters\n * @param {number} outHeight The desired height of the output rasters\n * @param {number} samples The number of samples per pixel for pixel\n *                         interleaved data\n * @returns {TypedArray} The resampled raster\n */\nexport function resampleBilinearInterleaved(valueArray, inWidth, inHeight, outWidth, outHeight, samples) {\n  const relX = inWidth / outWidth;\n  const relY = inHeight / outHeight;\n  const newArray = copyNewSize(valueArray, outWidth, outHeight, samples);\n  for (let y = 0; y < outHeight; ++y) {\n    const rawY = relY * y;\n    const yl = Math.floor(rawY);\n    const yh = Math.min(Math.ceil(rawY), inHeight - 1);\n    for (let x = 0; x < outWidth; ++x) {\n      const rawX = relX * x;\n      const tx = rawX % 1;\n      const xl = Math.floor(rawX);\n      const xh = Math.min(Math.ceil(rawX), inWidth - 1);\n      for (let i = 0; i < samples; ++i) {\n        const ll = valueArray[yl * inWidth * samples + xl * samples + i];\n        const hl = valueArray[yl * inWidth * samples + xh * samples + i];\n        const lh = valueArray[yh * inWidth * samples + xl * samples + i];\n        const hh = valueArray[yh * inWidth * samples + xh * samples + i];\n        const value = lerp(lerp(ll, hl, tx), lerp(lh, hh, tx), rawY % 1);\n        newArray[y * outWidth * samples + x * samples + i] = value;\n      }\n    }\n  }\n  return newArray;\n}\n\n/**\n * Resample the pixel interleaved input array using the selected resampling method.\n * @param {TypedArray} valueArray The input array to resample\n * @param {number} inWidth The width of the input rasters\n * @param {number} inHeight The height of the input rasters\n * @param {number} outWidth The desired width of the output rasters\n * @param {number} outHeight The desired height of the output rasters\n * @param {number} samples The number of samples per pixel for pixel\n *                                 interleaved data\n * @param {string} [method = 'nearest'] The desired resampling method\n * @returns {TypedArray} The resampled rasters\n */\nexport function resampleInterleaved(valueArray, inWidth, inHeight, outWidth, outHeight, samples, method = 'nearest') {\n  switch (method.toLowerCase()) {\n    case 'nearest':\n      return resampleNearestInterleaved(valueArray, inWidth, inHeight, outWidth, outHeight, samples);\n    case 'bilinear':\n    case 'linear':\n      return resampleBilinearInterleaved(valueArray, inWidth, inHeight, outWidth, outHeight, samples);\n    default:\n      throw new Error(`Unsupported resampling method: '${method}'`);\n  }\n}","map":{"version":3,"names":["copyNewSize","array","width","height","samplesPerPixel","Object","getPrototypeOf","constructor","resampleNearest","valueArrays","inWidth","inHeight","outWidth","outHeight","relX","relY","map","newArray","y","cy","Math","min","round","x","cx","value","lerp","v0","v1","t","resampleBilinear","rawY","yl","floor","yh","ceil","rawX","tx","xl","xh","ll","hl","lh","hh","resample","method","toLowerCase","Error","resampleNearestInterleaved","valueArray","samples","i","resampleBilinearInterleaved","resampleInterleaved"],"sources":["E:/Desktop/scenerymonitor/node_modules/geotiff/dist-module/resample.js"],"sourcesContent":["/**\n * @module resample\n */\n\nfunction copyNewSize(array, width, height, samplesPerPixel = 1) {\n  return new (Object.getPrototypeOf(array).constructor)(width * height * samplesPerPixel);\n}\n\n/**\n * Resample the input arrays using nearest neighbor value selection.\n * @param {TypedArray[]} valueArrays The input arrays to resample\n * @param {number} inWidth The width of the input rasters\n * @param {number} inHeight The height of the input rasters\n * @param {number} outWidth The desired width of the output rasters\n * @param {number} outHeight The desired height of the output rasters\n * @returns {TypedArray[]} The resampled rasters\n */\nexport function resampleNearest(valueArrays, inWidth, inHeight, outWidth, outHeight) {\n  const relX = inWidth / outWidth;\n  const relY = inHeight / outHeight;\n  return valueArrays.map((array) => {\n    const newArray = copyNewSize(array, outWidth, outHeight);\n    for (let y = 0; y < outHeight; ++y) {\n      const cy = Math.min(Math.round(relY * y), inHeight - 1);\n      for (let x = 0; x < outWidth; ++x) {\n        const cx = Math.min(Math.round(relX * x), inWidth - 1);\n        const value = array[(cy * inWidth) + cx];\n        newArray[(y * outWidth) + x] = value;\n      }\n    }\n    return newArray;\n  });\n}\n\n// simple linear interpolation, code from:\n// https://en.wikipedia.org/wiki/Linear_interpolation#Programming_language_support\nfunction lerp(v0, v1, t) {\n  return ((1 - t) * v0) + (t * v1);\n}\n\n/**\n * Resample the input arrays using bilinear interpolation.\n * @param {TypedArray[]} valueArrays The input arrays to resample\n * @param {number} inWidth The width of the input rasters\n * @param {number} inHeight The height of the input rasters\n * @param {number} outWidth The desired width of the output rasters\n * @param {number} outHeight The desired height of the output rasters\n * @returns {TypedArray[]} The resampled rasters\n */\nexport function resampleBilinear(valueArrays, inWidth, inHeight, outWidth, outHeight) {\n  const relX = inWidth / outWidth;\n  const relY = inHeight / outHeight;\n\n  return valueArrays.map((array) => {\n    const newArray = copyNewSize(array, outWidth, outHeight);\n    for (let y = 0; y < outHeight; ++y) {\n      const rawY = relY * y;\n\n      const yl = Math.floor(rawY);\n      const yh = Math.min(Math.ceil(rawY), (inHeight - 1));\n\n      for (let x = 0; x < outWidth; ++x) {\n        const rawX = relX * x;\n        const tx = rawX % 1;\n\n        const xl = Math.floor(rawX);\n        const xh = Math.min(Math.ceil(rawX), (inWidth - 1));\n\n        const ll = array[(yl * inWidth) + xl];\n        const hl = array[(yl * inWidth) + xh];\n        const lh = array[(yh * inWidth) + xl];\n        const hh = array[(yh * inWidth) + xh];\n\n        const value = lerp(\n          lerp(ll, hl, tx),\n          lerp(lh, hh, tx),\n          rawY % 1,\n        );\n        newArray[(y * outWidth) + x] = value;\n      }\n    }\n    return newArray;\n  });\n}\n\n/**\n * Resample the input arrays using the selected resampling method.\n * @param {TypedArray[]} valueArrays The input arrays to resample\n * @param {number} inWidth The width of the input rasters\n * @param {number} inHeight The height of the input rasters\n * @param {number} outWidth The desired width of the output rasters\n * @param {number} outHeight The desired height of the output rasters\n * @param {string} [method = 'nearest'] The desired resampling method\n * @returns {TypedArray[]} The resampled rasters\n */\nexport function resample(valueArrays, inWidth, inHeight, outWidth, outHeight, method = 'nearest') {\n  switch (method.toLowerCase()) {\n    case 'nearest':\n      return resampleNearest(valueArrays, inWidth, inHeight, outWidth, outHeight);\n    case 'bilinear':\n    case 'linear':\n      return resampleBilinear(valueArrays, inWidth, inHeight, outWidth, outHeight);\n    default:\n      throw new Error(`Unsupported resampling method: '${method}'`);\n  }\n}\n\n/**\n * Resample the pixel interleaved input array using nearest neighbor value selection.\n * @param {TypedArray} valueArrays The input arrays to resample\n * @param {number} inWidth The width of the input rasters\n * @param {number} inHeight The height of the input rasters\n * @param {number} outWidth The desired width of the output rasters\n * @param {number} outHeight The desired height of the output rasters\n * @param {number} samples The number of samples per pixel for pixel\n *                         interleaved data\n * @returns {TypedArray} The resampled raster\n */\nexport function resampleNearestInterleaved(\n  valueArray, inWidth, inHeight, outWidth, outHeight, samples) {\n  const relX = inWidth / outWidth;\n  const relY = inHeight / outHeight;\n\n  const newArray = copyNewSize(valueArray, outWidth, outHeight, samples);\n  for (let y = 0; y < outHeight; ++y) {\n    const cy = Math.min(Math.round(relY * y), inHeight - 1);\n    for (let x = 0; x < outWidth; ++x) {\n      const cx = Math.min(Math.round(relX * x), inWidth - 1);\n      for (let i = 0; i < samples; ++i) {\n        const value = valueArray[(cy * inWidth * samples) + (cx * samples) + i];\n        newArray[(y * outWidth * samples) + (x * samples) + i] = value;\n      }\n    }\n  }\n  return newArray;\n}\n\n/**\n * Resample the pixel interleaved input array using bilinear interpolation.\n * @param {TypedArray} valueArrays The input arrays to resample\n * @param {number} inWidth The width of the input rasters\n * @param {number} inHeight The height of the input rasters\n * @param {number} outWidth The desired width of the output rasters\n * @param {number} outHeight The desired height of the output rasters\n * @param {number} samples The number of samples per pixel for pixel\n *                         interleaved data\n * @returns {TypedArray} The resampled raster\n */\nexport function resampleBilinearInterleaved(\n  valueArray, inWidth, inHeight, outWidth, outHeight, samples) {\n  const relX = inWidth / outWidth;\n  const relY = inHeight / outHeight;\n  const newArray = copyNewSize(valueArray, outWidth, outHeight, samples);\n  for (let y = 0; y < outHeight; ++y) {\n    const rawY = relY * y;\n\n    const yl = Math.floor(rawY);\n    const yh = Math.min(Math.ceil(rawY), (inHeight - 1));\n\n    for (let x = 0; x < outWidth; ++x) {\n      const rawX = relX * x;\n      const tx = rawX % 1;\n\n      const xl = Math.floor(rawX);\n      const xh = Math.min(Math.ceil(rawX), (inWidth - 1));\n\n      for (let i = 0; i < samples; ++i) {\n        const ll = valueArray[(yl * inWidth * samples) + (xl * samples) + i];\n        const hl = valueArray[(yl * inWidth * samples) + (xh * samples) + i];\n        const lh = valueArray[(yh * inWidth * samples) + (xl * samples) + i];\n        const hh = valueArray[(yh * inWidth * samples) + (xh * samples) + i];\n\n        const value = lerp(\n          lerp(ll, hl, tx),\n          lerp(lh, hh, tx),\n          rawY % 1,\n        );\n        newArray[(y * outWidth * samples) + (x * samples) + i] = value;\n      }\n    }\n  }\n  return newArray;\n}\n\n/**\n * Resample the pixel interleaved input array using the selected resampling method.\n * @param {TypedArray} valueArray The input array to resample\n * @param {number} inWidth The width of the input rasters\n * @param {number} inHeight The height of the input rasters\n * @param {number} outWidth The desired width of the output rasters\n * @param {number} outHeight The desired height of the output rasters\n * @param {number} samples The number of samples per pixel for pixel\n *                                 interleaved data\n * @param {string} [method = 'nearest'] The desired resampling method\n * @returns {TypedArray} The resampled rasters\n */\nexport function resampleInterleaved(valueArray, inWidth, inHeight, outWidth, outHeight, samples, method = 'nearest') {\n  switch (method.toLowerCase()) {\n    case 'nearest':\n      return resampleNearestInterleaved(\n        valueArray, inWidth, inHeight, outWidth, outHeight, samples,\n      );\n    case 'bilinear':\n    case 'linear':\n      return resampleBilinearInterleaved(\n        valueArray, inWidth, inHeight, outWidth, outHeight, samples,\n      );\n    default:\n      throw new Error(`Unsupported resampling method: '${method}'`);\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}