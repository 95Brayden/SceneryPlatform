{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\n/**\n * @module ol/control/MousePosition\n */\n\nimport Control from './Control.js';\nimport EventType from '../pointer/EventType.js';\nimport { get as getProjection, getTransformFromProjections, getUserProjection, identityTransform } from '../proj.js';\nimport { listen } from '../events.js';\nimport { wrapX } from '../coordinate.js';\n\n/**\n * @type {string}\n */\nconst PROJECTION = 'projection';\n\n/**\n * @type {string}\n */\nconst COORDINATE_FORMAT = 'coordinateFormat';\n\n/***\n * @template Return\n * @typedef {import(\"../Observable\").OnSignature<import(\"../Observable\").EventTypes, import(\"../events/Event.js\").default, Return> &\n *   import(\"../Observable\").OnSignature<import(\"../ObjectEventType\").Types|\n *     'change:coordinateFormat'|'change:projection', import(\"../Object\").ObjectEvent, Return> &\n *   import(\"../Observable\").CombinedOnSignature<import(\"../Observable\").EventTypes|import(\"../ObjectEventType\").Types|\n *     'change:coordinateFormat'|'change:projection', Return>} MousePositionOnSignature\n */\n\n/**\n * @typedef {Object} Options\n * @property {string} [className='ol-mouse-position'] CSS class name.\n * @property {import(\"../coordinate.js\").CoordinateFormat} [coordinateFormat] Coordinate format.\n * @property {import(\"../proj.js\").ProjectionLike} [projection] Projection. Default is the view projection.\n * @property {function(import(\"../MapEvent.js\").default):void} [render] Function called when the\n * control should be re-rendered. This is called in a `requestAnimationFrame`\n * callback.\n * @property {HTMLElement|string} [target] Specify a target if you want the\n * control to be rendered outside of the map's viewport.\n * @property {string} [placeholder] Markup to show when the mouse position is not\n * available (e.g. when the pointer leaves the map viewport).  By default, a non-breaking space is rendered\n * initially and the last position is retained when the mouse leaves the viewport.\n * When a string is provided (e.g. `'no position'` or `''` for an empty string) it is used as a\n * placeholder.\n * @property {boolean} [wrapX=true] Wrap the world horizontally on the projection's antimeridian, if it\n * is a global projection.\n */\n\n/**\n * @classdesc\n * A control to show the 2D coordinates of the mouse cursor. By default, these\n * are in the view projection, but can be in any supported projection.\n * By default the control is shown in the top right corner of the map, but this\n * can be changed by using the css selector `.ol-mouse-position`.\n *\n * On touch devices, which usually do not have a mouse cursor, the coordinates\n * of the currently touched position are shown.\n *\n * @api\n */\nclass MousePosition extends Control {\n  /**\n   * @param {Options} [options] Mouse position options.\n   */\n  constructor(options) {\n    options = options ? options : {};\n    const element = document.createElement('div');\n    element.className = options.className !== undefined ? options.className : 'ol-mouse-position';\n    super({\n      element: element,\n      render: options.render,\n      target: options.target\n    });\n\n    /***\n     * @type {MousePositionOnSignature<import(\"../events\").EventsKey>}\n     */\n    this.on;\n\n    /***\n     * @type {MousePositionOnSignature<import(\"../events\").EventsKey>}\n     */\n    this.once;\n\n    /***\n     * @type {MousePositionOnSignature<void>}\n     */\n    this.un;\n    this.addChangeListener(PROJECTION, this.handleProjectionChanged_);\n    if (options.coordinateFormat) {\n      this.setCoordinateFormat(options.coordinateFormat);\n    }\n    if (options.projection) {\n      this.setProjection(options.projection);\n    }\n\n    /**\n     * @private\n     * @type {boolean}\n     */\n    this.renderOnMouseOut_ = options.placeholder !== undefined;\n\n    /**\n     * @private\n     * @type {string}\n     */\n    this.placeholder_ = this.renderOnMouseOut_ ? options.placeholder : '&#160;';\n\n    /**\n     * @private\n     * @type {string}\n     */\n    this.renderedHTML_ = element.innerHTML;\n\n    /**\n     * @private\n     * @type {?import(\"../proj/Projection.js\").default}\n     */\n    this.mapProjection_ = null;\n\n    /**\n     * @private\n     * @type {?import(\"../proj.js\").TransformFunction}\n     */\n    this.transform_ = null;\n\n    /**\n     * @private\n     * @type {boolean}\n     */\n    this.wrapX_ = options.wrapX === false ? false : true;\n  }\n\n  /**\n   * @private\n   */\n  handleProjectionChanged_() {\n    this.transform_ = null;\n  }\n\n  /**\n   * Return the coordinate format type used to render the current position or\n   * undefined.\n   * @return {import(\"../coordinate.js\").CoordinateFormat|undefined} The format to render the current\n   *     position in.\n   * @observable\n   * @api\n   */\n  getCoordinateFormat() {\n    return (/** @type {import(\"../coordinate.js\").CoordinateFormat|undefined} */\n      this.get(COORDINATE_FORMAT)\n    );\n  }\n\n  /**\n   * Return the projection that is used to report the mouse position.\n   * @return {import(\"../proj/Projection.js\").default|undefined} The projection to report mouse\n   *     position in.\n   * @observable\n   * @api\n   */\n  getProjection() {\n    return (/** @type {import(\"../proj/Projection.js\").default|undefined} */\n      this.get(PROJECTION)\n    );\n  }\n\n  /**\n   * @param {MouseEvent} event Browser event.\n   * @protected\n   */\n  handleMouseMove(event) {\n    const map = this.getMap();\n    this.updateHTML_(map.getEventPixel(event));\n  }\n\n  /**\n   * @param {Event} event Browser event.\n   * @protected\n   */\n  handleMouseOut(event) {\n    this.updateHTML_(null);\n  }\n\n  /**\n   * Remove the control from its current map and attach it to the new map.\n   * Pass `null` to just remove the control from the current map.\n   * Subclasses may set up event handlers to get notified about changes to\n   * the map here.\n   * @param {import(\"../Map.js\").default|null} map Map.\n   * @api\n   */\n  setMap(map) {\n    super.setMap(map);\n    if (map) {\n      const viewport = map.getViewport();\n      this.listenerKeys.push(listen(viewport, EventType.POINTERMOVE, this.handleMouseMove, this));\n      if (this.renderOnMouseOut_) {\n        this.listenerKeys.push(listen(viewport, EventType.POINTEROUT, this.handleMouseOut, this));\n      }\n      this.updateHTML_(null);\n    }\n  }\n\n  /**\n   * Set the coordinate format type used to render the current position.\n   * @param {import(\"../coordinate.js\").CoordinateFormat} format The format to render the current\n   *     position in.\n   * @observable\n   * @api\n   */\n  setCoordinateFormat(format) {\n    this.set(COORDINATE_FORMAT, format);\n  }\n\n  /**\n   * Set the projection that is used to report the mouse position.\n   * @param {import(\"../proj.js\").ProjectionLike} projection The projection to report mouse\n   *     position in.\n   * @observable\n   * @api\n   */\n  setProjection(projection) {\n    this.set(PROJECTION, getProjection(projection));\n  }\n\n  /**\n   * @param {?import(\"../pixel.js\").Pixel} pixel Pixel.\n   * @private\n   */\n  updateHTML_(pixel) {\n    let html = this.placeholder_;\n    if (pixel && this.mapProjection_) {\n      if (!this.transform_) {\n        const projection = this.getProjection();\n        if (projection) {\n          this.transform_ = getTransformFromProjections(this.mapProjection_, projection);\n        } else {\n          this.transform_ = identityTransform;\n        }\n      }\n      const map = this.getMap();\n      const coordinate = map.getCoordinateFromPixelInternal(pixel);\n      if (coordinate) {\n        const userProjection = getUserProjection();\n        if (userProjection) {\n          this.transform_ = getTransformFromProjections(this.mapProjection_, userProjection);\n        }\n        this.transform_(coordinate, coordinate);\n        if (this.wrapX_) {\n          const projection = userProjection || this.getProjection() || this.mapProjection_;\n          wrapX(coordinate, projection);\n        }\n        const coordinateFormat = this.getCoordinateFormat();\n        if (coordinateFormat) {\n          html = coordinateFormat(coordinate);\n        } else {\n          html = coordinate.toString();\n        }\n      }\n    }\n    if (!this.renderedHTML_ || html !== this.renderedHTML_) {\n      this.element.innerHTML = html;\n      this.renderedHTML_ = html;\n    }\n  }\n\n  /**\n   * Update the projection. Rendering of the coordinates is done in\n   * `handleMouseMove` and `handleMouseUp`.\n   * @param {import(\"../MapEvent.js\").default} mapEvent Map event.\n   * @override\n   */\n  render(mapEvent) {\n    const frameState = mapEvent.frameState;\n    if (!frameState) {\n      this.mapProjection_ = null;\n    } else {\n      if (this.mapProjection_ != frameState.viewState.projection) {\n        this.mapProjection_ = frameState.viewState.projection;\n        this.transform_ = null;\n      }\n    }\n  }\n}\nexport default MousePosition;","map":{"version":3,"names":["Control","EventType","get","getProjection","getTransformFromProjections","getUserProjection","identityTransform","listen","wrapX","PROJECTION","COORDINATE_FORMAT","MousePosition","constructor","options","element","document","createElement","className","undefined","render","target","on","once","un","addChangeListener","handleProjectionChanged_","coordinateFormat","setCoordinateFormat","projection","setProjection","renderOnMouseOut_","placeholder","placeholder_","renderedHTML_","innerHTML","mapProjection_","transform_","wrapX_","getCoordinateFormat","handleMouseMove","event","map","getMap","updateHTML_","getEventPixel","handleMouseOut","setMap","viewport","getViewport","listenerKeys","push","POINTERMOVE","POINTEROUT","format","set","pixel","html","coordinate","getCoordinateFromPixelInternal","userProjection","toString","mapEvent","frameState","viewState"],"sources":["E:/Desktop/SceneryPlatform_v3.0_LTS/node_modules/ol/control/MousePosition.js"],"sourcesContent":["/**\n * @module ol/control/MousePosition\n */\n\nimport Control from './Control.js';\nimport EventType from '../pointer/EventType.js';\nimport {\n  get as getProjection,\n  getTransformFromProjections,\n  getUserProjection,\n  identityTransform,\n} from '../proj.js';\nimport {listen} from '../events.js';\nimport {wrapX} from '../coordinate.js';\n\n/**\n * @type {string}\n */\nconst PROJECTION = 'projection';\n\n/**\n * @type {string}\n */\nconst COORDINATE_FORMAT = 'coordinateFormat';\n\n/***\n * @template Return\n * @typedef {import(\"../Observable\").OnSignature<import(\"../Observable\").EventTypes, import(\"../events/Event.js\").default, Return> &\n *   import(\"../Observable\").OnSignature<import(\"../ObjectEventType\").Types|\n *     'change:coordinateFormat'|'change:projection', import(\"../Object\").ObjectEvent, Return> &\n *   import(\"../Observable\").CombinedOnSignature<import(\"../Observable\").EventTypes|import(\"../ObjectEventType\").Types|\n *     'change:coordinateFormat'|'change:projection', Return>} MousePositionOnSignature\n */\n\n/**\n * @typedef {Object} Options\n * @property {string} [className='ol-mouse-position'] CSS class name.\n * @property {import(\"../coordinate.js\").CoordinateFormat} [coordinateFormat] Coordinate format.\n * @property {import(\"../proj.js\").ProjectionLike} [projection] Projection. Default is the view projection.\n * @property {function(import(\"../MapEvent.js\").default):void} [render] Function called when the\n * control should be re-rendered. This is called in a `requestAnimationFrame`\n * callback.\n * @property {HTMLElement|string} [target] Specify a target if you want the\n * control to be rendered outside of the map's viewport.\n * @property {string} [placeholder] Markup to show when the mouse position is not\n * available (e.g. when the pointer leaves the map viewport).  By default, a non-breaking space is rendered\n * initially and the last position is retained when the mouse leaves the viewport.\n * When a string is provided (e.g. `'no position'` or `''` for an empty string) it is used as a\n * placeholder.\n * @property {boolean} [wrapX=true] Wrap the world horizontally on the projection's antimeridian, if it\n * is a global projection.\n */\n\n/**\n * @classdesc\n * A control to show the 2D coordinates of the mouse cursor. By default, these\n * are in the view projection, but can be in any supported projection.\n * By default the control is shown in the top right corner of the map, but this\n * can be changed by using the css selector `.ol-mouse-position`.\n *\n * On touch devices, which usually do not have a mouse cursor, the coordinates\n * of the currently touched position are shown.\n *\n * @api\n */\nclass MousePosition extends Control {\n  /**\n   * @param {Options} [options] Mouse position options.\n   */\n  constructor(options) {\n    options = options ? options : {};\n\n    const element = document.createElement('div');\n    element.className =\n      options.className !== undefined ? options.className : 'ol-mouse-position';\n\n    super({\n      element: element,\n      render: options.render,\n      target: options.target,\n    });\n\n    /***\n     * @type {MousePositionOnSignature<import(\"../events\").EventsKey>}\n     */\n    this.on;\n\n    /***\n     * @type {MousePositionOnSignature<import(\"../events\").EventsKey>}\n     */\n    this.once;\n\n    /***\n     * @type {MousePositionOnSignature<void>}\n     */\n    this.un;\n\n    this.addChangeListener(PROJECTION, this.handleProjectionChanged_);\n\n    if (options.coordinateFormat) {\n      this.setCoordinateFormat(options.coordinateFormat);\n    }\n    if (options.projection) {\n      this.setProjection(options.projection);\n    }\n\n    /**\n     * @private\n     * @type {boolean}\n     */\n    this.renderOnMouseOut_ = options.placeholder !== undefined;\n\n    /**\n     * @private\n     * @type {string}\n     */\n    this.placeholder_ = this.renderOnMouseOut_ ? options.placeholder : '&#160;';\n\n    /**\n     * @private\n     * @type {string}\n     */\n    this.renderedHTML_ = element.innerHTML;\n\n    /**\n     * @private\n     * @type {?import(\"../proj/Projection.js\").default}\n     */\n    this.mapProjection_ = null;\n\n    /**\n     * @private\n     * @type {?import(\"../proj.js\").TransformFunction}\n     */\n    this.transform_ = null;\n\n    /**\n     * @private\n     * @type {boolean}\n     */\n    this.wrapX_ = options.wrapX === false ? false : true;\n  }\n\n  /**\n   * @private\n   */\n  handleProjectionChanged_() {\n    this.transform_ = null;\n  }\n\n  /**\n   * Return the coordinate format type used to render the current position or\n   * undefined.\n   * @return {import(\"../coordinate.js\").CoordinateFormat|undefined} The format to render the current\n   *     position in.\n   * @observable\n   * @api\n   */\n  getCoordinateFormat() {\n    return /** @type {import(\"../coordinate.js\").CoordinateFormat|undefined} */ (\n      this.get(COORDINATE_FORMAT)\n    );\n  }\n\n  /**\n   * Return the projection that is used to report the mouse position.\n   * @return {import(\"../proj/Projection.js\").default|undefined} The projection to report mouse\n   *     position in.\n   * @observable\n   * @api\n   */\n  getProjection() {\n    return /** @type {import(\"../proj/Projection.js\").default|undefined} */ (\n      this.get(PROJECTION)\n    );\n  }\n\n  /**\n   * @param {MouseEvent} event Browser event.\n   * @protected\n   */\n  handleMouseMove(event) {\n    const map = this.getMap();\n    this.updateHTML_(map.getEventPixel(event));\n  }\n\n  /**\n   * @param {Event} event Browser event.\n   * @protected\n   */\n  handleMouseOut(event) {\n    this.updateHTML_(null);\n  }\n\n  /**\n   * Remove the control from its current map and attach it to the new map.\n   * Pass `null` to just remove the control from the current map.\n   * Subclasses may set up event handlers to get notified about changes to\n   * the map here.\n   * @param {import(\"../Map.js\").default|null} map Map.\n   * @api\n   */\n  setMap(map) {\n    super.setMap(map);\n    if (map) {\n      const viewport = map.getViewport();\n      this.listenerKeys.push(\n        listen(viewport, EventType.POINTERMOVE, this.handleMouseMove, this)\n      );\n      if (this.renderOnMouseOut_) {\n        this.listenerKeys.push(\n          listen(viewport, EventType.POINTEROUT, this.handleMouseOut, this)\n        );\n      }\n      this.updateHTML_(null);\n    }\n  }\n\n  /**\n   * Set the coordinate format type used to render the current position.\n   * @param {import(\"../coordinate.js\").CoordinateFormat} format The format to render the current\n   *     position in.\n   * @observable\n   * @api\n   */\n  setCoordinateFormat(format) {\n    this.set(COORDINATE_FORMAT, format);\n  }\n\n  /**\n   * Set the projection that is used to report the mouse position.\n   * @param {import(\"../proj.js\").ProjectionLike} projection The projection to report mouse\n   *     position in.\n   * @observable\n   * @api\n   */\n  setProjection(projection) {\n    this.set(PROJECTION, getProjection(projection));\n  }\n\n  /**\n   * @param {?import(\"../pixel.js\").Pixel} pixel Pixel.\n   * @private\n   */\n  updateHTML_(pixel) {\n    let html = this.placeholder_;\n    if (pixel && this.mapProjection_) {\n      if (!this.transform_) {\n        const projection = this.getProjection();\n        if (projection) {\n          this.transform_ = getTransformFromProjections(\n            this.mapProjection_,\n            projection\n          );\n        } else {\n          this.transform_ = identityTransform;\n        }\n      }\n      const map = this.getMap();\n      const coordinate = map.getCoordinateFromPixelInternal(pixel);\n      if (coordinate) {\n        const userProjection = getUserProjection();\n        if (userProjection) {\n          this.transform_ = getTransformFromProjections(\n            this.mapProjection_,\n            userProjection\n          );\n        }\n        this.transform_(coordinate, coordinate);\n        if (this.wrapX_) {\n          const projection =\n            userProjection || this.getProjection() || this.mapProjection_;\n          wrapX(coordinate, projection);\n        }\n        const coordinateFormat = this.getCoordinateFormat();\n        if (coordinateFormat) {\n          html = coordinateFormat(coordinate);\n        } else {\n          html = coordinate.toString();\n        }\n      }\n    }\n    if (!this.renderedHTML_ || html !== this.renderedHTML_) {\n      this.element.innerHTML = html;\n      this.renderedHTML_ = html;\n    }\n  }\n\n  /**\n   * Update the projection. Rendering of the coordinates is done in\n   * `handleMouseMove` and `handleMouseUp`.\n   * @param {import(\"../MapEvent.js\").default} mapEvent Map event.\n   * @override\n   */\n  render(mapEvent) {\n    const frameState = mapEvent.frameState;\n    if (!frameState) {\n      this.mapProjection_ = null;\n    } else {\n      if (this.mapProjection_ != frameState.viewState.projection) {\n        this.mapProjection_ = frameState.viewState.projection;\n        this.transform_ = null;\n      }\n    }\n  }\n}\n\nexport default MousePosition;\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}