{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport \"core-js/modules/es.typed-array.to-reversed.js\";\nimport \"core-js/modules/es.typed-array.to-sorted.js\";\nimport \"core-js/modules/es.typed-array.with.js\";\n/**\n * Operators and utilities used for style expressions\n * @module ol/style/expressions\n */\n\nimport PaletteTexture from '../webgl/PaletteTexture.js';\nimport { Uniforms } from '../renderer/webgl/TileLayer.js';\nimport { asArray, fromString, isStringColor } from '../color.js';\n\n/**\n * Base type used for literal style parameters; can be a number literal or the output of an operator,\n * which in turns takes {@link import(\"./expressions.js\").ExpressionValue} arguments.\n *\n * The following operators can be used:\n *\n * * Reading operators:\n *   * `['band', bandIndex, xOffset, yOffset]` For tile layers only. Fetches pixel values from band\n *     `bandIndex` of the source's data. The first `bandIndex` of the source data is `1`. Fetched values\n *     are in the 0..1 range. {@link import(\"../source/TileImage.js\").default} sources have 4 bands: red,\n *     green, blue and alpha. {@link import(\"../source/DataTile.js\").default} sources can have any number\n *     of bands, depending on the underlying data source and\n *     {@link import(\"../source/GeoTIFF.js\").Options configuration}. `xOffset` and `yOffset` are optional\n *     and allow specifying pixel offsets for x and y. This is used for sampling data from neighboring pixels.\n *   * `['get', 'attributeName', typeHint]` fetches a feature property value, similar to `feature.get('attributeName')`\n *     A type hint can optionally be specified, in case the resulting expression contains a type ambiguity which\n *     will make it invalid. Type hints can be one of: 'string', 'color', 'number', 'boolean', 'number[]'\n *   * `['geometry-type']` returns a feature's geometry type as string, either: 'LineString', 'Point' or 'Polygon'\n *     `Multi*` values are returned as their singular equivalent\n *     `Circle` geometries are returned as 'Polygon'\n *     `GeometryCollection` geometries are returned as the type of the first geometry found in the collection\n *   * `['resolution']` returns the current resolution\n *   * `['time']` returns the time in seconds since the creation of the layer\n *   * `['var', 'varName']` fetches a value from the style variables; will throw an error if that variable is undefined\n *   * `['zoom']` returns the current zoom level\n *\n * * Math operators:\n *   * `['*', value1, value2, ...]` multiplies the values (either numbers or colors)\n *   * `['/', value1, value2]` divides `value1` by `value2`\n *   * `['+', value1, value2, ...]` adds the values\n *   * `['-', value1, value2]` subtracts `value2` from `value1`\n *   * `['clamp', value, low, high]` clamps `value` between `low` and `high`\n *   * `['%', value1, value2]` returns the result of `value1 % value2` (modulo)\n *   * `['^', value1, value2]` returns the value of `value1` raised to the `value2` power\n *   * `['abs', value1]` returns the absolute value of `value1`\n *   * `['floor', value1]` returns the nearest integer less than or equal to `value1`\n *   * `['round', value1]` returns the nearest integer to `value1`\n *   * `['ceil', value1]` returns the nearest integer greater than or equal to `value1`\n *   * `['sin', value1]` returns the sine of `value1`\n *   * `['cos', value1]` returns the cosine of `value1`\n *   * `['atan', value1, value2]` returns `atan2(value1, value2)`. If `value2` is not provided, returns `atan(value1)`\n *   * `['sqrt', value1]` returns the square root of `value1`\n *\n * * Transform operators:\n *   * `['case', condition1, output1, ...conditionN, outputN, fallback]` selects the first output whose corresponding\n *     condition evaluates to `true`. If no match is found, returns the `fallback` value.\n *     All conditions should be `boolean`, output and fallback can be any kind.\n *   * `['match', input, match1, output1, ...matchN, outputN, fallback]` compares the `input` value against all\n *     provided `matchX` values, returning the output associated with the first valid match. If no match is found,\n *     returns the `fallback` value.\n *     `input` and `matchX` values must all be of the same type, and can be `number` or `string`. `outputX` and\n *     `fallback` values must be of the same type, and can be of any kind.\n *   * `['interpolate', interpolation, input, stop1, output1, ...stopN, outputN]` returns a value by interpolating between\n *     pairs of inputs and outputs; `interpolation` can either be `['linear']` or `['exponential', base]` where `base` is\n *     the rate of increase from stop A to stop B (i.e. power to which the interpolation ratio is raised); a value\n *     of 1 is equivalent to `['linear']`.\n *     `input` and `stopX` values must all be of type `number`. `outputX` values can be `number` or `color` values.\n *     Note: `input` will be clamped between `stop1` and `stopN`, meaning that all output values will be comprised\n *     between `output1` and `outputN`.\n *\n * * Logical operators:\n *   * `['<', value1, value2]` returns `true` if `value1` is strictly lower than `value2`, or `false` otherwise.\n *   * `['<=', value1, value2]` returns `true` if `value1` is lower than or equals `value2`, or `false` otherwise.\n *   * `['>', value1, value2]` returns `true` if `value1` is strictly greater than `value2`, or `false` otherwise.\n *   * `['>=', value1, value2]` returns `true` if `value1` is greater than or equals `value2`, or `false` otherwise.\n *   * `['==', value1, value2]` returns `true` if `value1` equals `value2`, or `false` otherwise.\n *   * `['!=', value1, value2]` returns `true` if `value1` does not equal `value2`, or `false` otherwise.\n *   * `['!', value1]` returns `false` if `value1` is `true` or greater than `0`, or `true` otherwise.\n *   * `['all', value1, value2, ...]` returns `true` if all the inputs are `true`, `false` otherwise.\n *   * `['any', value1, value2, ...]` returns `true` if any of the inputs are `true`, `false` otherwise.\n *   * `['between', value1, value2, value3]` returns `true` if `value1` is contained between `value2` and `value3`\n *     (inclusively), or `false` otherwise.\n *   * `['in', needle, haystack]` returns `true` if `needle` is found in `haystack`, and\n *     `false` otherwise.\n *     This operator has the following limitations:\n *     * `haystack` has to be an array of numbers or strings (searching for a substring in a string is not supported yet)\n *     * Only literal arrays are supported as `haystack` for now; this means that `haystack` cannot be the result of an\n *     expression. If `haystack` is an array of strings, use the `literal` operator to disambiguate from an expression:\n *     `['literal', ['abc', 'def', 'ghi']]`\n *\n * * Conversion operators:\n *   * `['array', value1, ...valueN]` creates a numerical array from `number` values; please note that the amount of\n *     values can currently only be 2, 3 or 4.\n *   * `['color', red, green, blue, alpha]` creates a `color` value from `number` values; the `alpha` parameter is\n *     optional; if not specified, it will be set to 1.\n *     Note: `red`, `green` and `blue` components must be values between 0 and 255; `alpha` between 0 and 1.\n *   * `['palette', index, colors]` picks a `color` value from an array of colors using the given index; the `index`\n *     expression must evaluate to a number; the items in the `colors` array must be strings with hex colors\n *     (e.g. `'#86A136'`), colors using the rgba[a] functional notation (e.g. `'rgb(134, 161, 54)'` or `'rgba(134, 161, 54, 1)'`),\n *     named colors (e.g. `'red'`), or array literals with 3 ([r, g, b]) or 4 ([r, g, b, a]) values (with r, g, and b\n *     in the 0-255 range and a in the 0-1 range).\n *\n * Values can either be literals or another operator, as they will be evaluated recursively.\n * Literal values can be of the following types:\n * * `boolean`\n * * `number`\n * * `number[]` (number arrays can only have a length of 2, 3 or 4)\n * * `string`\n * * {@link module:ol/color~Color}\n *\n * @typedef {Array<*>|import(\"../color.js\").Color|string|number|boolean} ExpressionValue\n * @api\n */\n\n/**\n * Possible inferred types from a given value or expression.\n * Note: these are binary flags.\n * @enum {number}\n */\nexport const ValueTypes = {\n  NUMBER: 0b00001,\n  STRING: 0b00010,\n  COLOR: 0b00100,\n  BOOLEAN: 0b01000,\n  NUMBER_ARRAY: 0b10000,\n  ANY: 0b11111,\n  NONE: 0\n};\n\n/**\n * @param {string} typeHint Type hint\n * @return {ValueTypes} Resulting value type (will be a single type)\n */\nfunction getTypeFromHint(typeHint) {\n  switch (typeHint) {\n    case 'string':\n      return ValueTypes.STRING;\n    case 'color':\n      return ValueTypes.COLOR;\n    case 'number':\n      return ValueTypes.NUMBER;\n    case 'boolean':\n      return ValueTypes.BOOLEAN;\n    case 'number[]':\n      return ValueTypes.NUMBER_ARRAY;\n    default:\n      throw new Error(`Unrecognized type hint: ${typeHint}`);\n  }\n}\n\n/**\n * An operator declaration must contain two methods: `getReturnType` which returns a type based on\n * the operator arguments, and `toGlsl` which returns a GLSL-compatible string.\n * Note: both methods can process arguments recursively.\n * @typedef {Object} Operator\n * @property {function(Array<ExpressionValue>): ValueTypes|number} getReturnType Returns one or several types\n * @property {function(ParsingContext, Array<ExpressionValue>, ValueTypes): string} toGlsl Returns a GLSL-compatible string\n * given a parsing context, an array of arguments and an expected type.\n * Note: the expected type can be a combination such as ValueTypes.NUMBER | ValueTypes.STRING or ValueTypes.ANY for instance\n */\n\n/**\n * Operator declarations\n * @type {Object<string, Operator>}\n */\nexport const Operators = {};\n\n/**\n * Returns the possible types for a given value (each type being a binary flag)\n * To test a value use e.g. `getValueType(v) & ValueTypes.BOOLEAN`\n * @param {ExpressionValue} value Value\n * @return {ValueTypes|number} Type or types inferred from the value\n */\nexport function getValueType(value) {\n  if (typeof value === 'number') {\n    return ValueTypes.NUMBER;\n  }\n  if (typeof value === 'boolean') {\n    return ValueTypes.BOOLEAN;\n  }\n  if (typeof value === 'string') {\n    if (isStringColor(value)) {\n      return ValueTypes.COLOR | ValueTypes.STRING;\n    }\n    return ValueTypes.STRING;\n  }\n  if (!Array.isArray(value)) {\n    throw new Error(`Unhandled value type: ${JSON.stringify(value)}`);\n  }\n  const valueArr = /** @type {Array<*>} */value;\n  const onlyNumbers = valueArr.every(function (v) {\n    return typeof v === 'number';\n  });\n  if (onlyNumbers) {\n    if (valueArr.length === 3 || valueArr.length === 4) {\n      return ValueTypes.COLOR | ValueTypes.NUMBER_ARRAY;\n    }\n    return ValueTypes.NUMBER_ARRAY;\n  }\n  if (typeof valueArr[0] !== 'string') {\n    throw new Error(`Expected an expression operator but received: ${JSON.stringify(valueArr)}`);\n  }\n  const operator = Operators[valueArr[0]];\n  if (operator === undefined) {\n    throw new Error(`Unrecognized expression operator: ${JSON.stringify(valueArr)}`);\n  }\n  return operator.getReturnType(valueArr.slice(1));\n}\n\n/**\n * Checks if only one value type is enabled in the input number.\n * @param {ValueTypes|number} valueType Number containing value type binary flags\n * @return {boolean} True if only one type flag is enabled, false if zero or multiple\n */\nexport function isTypeUnique(valueType) {\n  return Math.log2(valueType) % 1 === 0;\n}\n\n/**\n * Print types as a readable string\n * @param {ValueTypes|number} valueType Number containing value type binary flags\n * @return {string} Types\n */\nfunction printTypes(valueType) {\n  const result = [];\n  if ((valueType & ValueTypes.NUMBER) > 0) {\n    result.push('number');\n  }\n  if ((valueType & ValueTypes.COLOR) > 0) {\n    result.push('color');\n  }\n  if ((valueType & ValueTypes.BOOLEAN) > 0) {\n    result.push('boolean');\n  }\n  if ((valueType & ValueTypes.NUMBER_ARRAY) > 0) {\n    result.push('number[]');\n  }\n  if ((valueType & ValueTypes.STRING) > 0) {\n    result.push('string');\n  }\n  return result.length > 0 ? result.join(', ') : '(no type)';\n}\n\n/**\n * @typedef {Object} ParsingContextExternal\n * @property {string} name Name, unprefixed\n * @property {ValueTypes} type One of the value types constants\n * @property {function(import(\"../Feature.js\").FeatureLike): *} [callback] Function used for computing the attribute value;\n *   if undefined, `feature.get(attribute.name)` will be used\n */\n\n/**\n * Context available during the parsing of an expression.\n * @typedef {Object} ParsingContext\n * @property {boolean} [inFragmentShader] If false, means the expression output should be made for a vertex shader\n * @property {Array<ParsingContextExternal>} variables External variables used in the expression\n * @property {Array<ParsingContextExternal>} attributes External attributes used in the expression\n * @property {Object<string, string>} functions Lookup of functions used by the style.\n * @property {number} [bandCount] Number of bands per pixel.\n * @property {Array<PaletteTexture>} [paletteTextures] List of palettes used by the style.\n * @property {import(\"../style/literal\").LiteralStyle} style The style being parsed\n */\n\n/**\n * @param {string} operator Operator\n * @param {ParsingContext} context Parsing context\n * @return {string} A function name based on the operator, unique in the given context\n */\nfunction computeOperatorFunctionName(operator, context) {\n  return `operator_${operator}_${Object.keys(context.functions).length}`;\n}\n\n/**\n * Will return the number as a float with a dot separator, which is required by GLSL.\n * @param {number} v Numerical value.\n * @return {string} The value as string.\n */\nexport function numberToGlsl(v) {\n  const s = v.toString();\n  return s.includes('.') ? s : s + '.0';\n}\n\n/**\n * Will return the number array as a float with a dot separator, concatenated with ', '.\n * @param {Array<number>} array Numerical values array.\n * @return {string} The array as a vector, e. g.: `vec3(1.0, 2.0, 3.0)`.\n */\nexport function arrayToGlsl(array) {\n  if (array.length < 2 || array.length > 4) {\n    throw new Error('`formatArray` can only output `vec2`, `vec3` or `vec4` arrays.');\n  }\n  return `vec${array.length}(${array.map(numberToGlsl).join(', ')})`;\n}\n\n/**\n * Will normalize and converts to string a `vec4` color array compatible with GLSL.\n * @param {string|import(\"../color.js\").Color} color Color either in string format or [r, g, b, a] array format,\n * with RGB components in the 0..255 range and the alpha component in the 0..1 range.\n * Note that the final array will always have 4 components.\n * @return {string} The color expressed in the `vec4(1.0, 1.0, 1.0, 1.0)` form.\n */\nexport function colorToGlsl(color) {\n  const array = asArray(color);\n  const alpha = array.length > 3 ? array[3] : 1;\n  // all components are premultiplied with alpha value\n  return arrayToGlsl([array[0] / 255 * alpha, array[1] / 255 * alpha, array[2] / 255 * alpha, alpha]);\n}\n\n/** @type {Object<string, number>} */\nconst stringToFloatMap = {};\nlet stringToFloatCounter = 0;\n\n/**\n * Returns a stable equivalent number for the string literal.\n * @param {string} string String literal value\n * @return {number} Number equivalent\n */\nexport function getStringNumberEquivalent(string) {\n  if (!(string in stringToFloatMap)) {\n    stringToFloatMap[string] = stringToFloatCounter++;\n  }\n  return stringToFloatMap[string];\n}\n\n/**\n * Returns a stable equivalent number for the string literal, for use in shaders. This number is then\n * converted to be a GLSL-compatible string.\n * Note: with a float precision of `mediump`, the amount of unique strings supported is 16,777,216\n * @param {string} string String literal value\n * @return {string} GLSL-compatible string containing a number\n */\nexport function stringToGlsl(string) {\n  return numberToGlsl(getStringNumberEquivalent(string));\n}\n\n/**\n * Recursively parses a style expression and outputs a GLSL-compatible string. Takes in a parsing context that\n * will be read and modified during the parsing operation.\n * @param {ParsingContext} context Parsing context\n * @param {ExpressionValue} value Value\n * @param {ValueTypes|number} [expectedType] Expected final type (can be several types combined)\n * If omitted, defaults to ValueTypes.NUMBER\n * @return {string} GLSL-compatible output\n */\nexport function expressionToGlsl(context, value, expectedType) {\n  const returnType = expectedType !== undefined ? expectedType : ValueTypes.NUMBER;\n  // operator\n  if (Array.isArray(value) && typeof value[0] === 'string') {\n    const operator = Operators[value[0]];\n    if (operator === undefined) {\n      throw new Error(`Unrecognized expression operator: ${JSON.stringify(value)}`);\n    }\n    return operator.toGlsl(context, value.slice(1), returnType);\n  }\n  const possibleType = getValueType(value) & returnType;\n  assertNotEmptyType(value, possibleType, '');\n  if ((possibleType & ValueTypes.NUMBER) > 0) {\n    return numberToGlsl( /** @type {number} */value);\n  }\n  if ((possibleType & ValueTypes.BOOLEAN) > 0) {\n    return value.toString();\n  }\n  if ((possibleType & ValueTypes.STRING) > 0) {\n    return stringToGlsl(value.toString());\n  }\n  if ((possibleType & ValueTypes.COLOR) > 0) {\n    return colorToGlsl( /** @type {Array<number> | string} */value);\n  }\n  if ((possibleType & ValueTypes.NUMBER_ARRAY) > 0) {\n    return arrayToGlsl( /** @type {Array<number>} */value);\n  }\n  throw new Error(`Unexpected expression ${value} (expected type ${printTypes(returnType)})`);\n}\nfunction assertNumber(value) {\n  if ((getValueType(value) & ValueTypes.NUMBER) === 0) {\n    throw new Error(`A numeric value was expected, got ${JSON.stringify(value)} instead`);\n  }\n}\nfunction assertNumbers(values) {\n  for (let i = 0; i < values.length; i++) {\n    assertNumber(values[i]);\n  }\n}\nfunction assertString(value) {\n  if ((getValueType(value) & ValueTypes.STRING) === 0) {\n    throw new Error(`A string value was expected, got ${JSON.stringify(value)} instead`);\n  }\n}\nfunction assertBoolean(value) {\n  if ((getValueType(value) & ValueTypes.BOOLEAN) === 0) {\n    throw new Error(`A boolean value was expected, got ${JSON.stringify(value)} instead`);\n  }\n}\nfunction assertArgsCount(args, count) {\n  if (args.length !== count) {\n    throw new Error(`Exactly ${count} arguments were expected, got ${args.length} instead`);\n  }\n}\nfunction assertArgsMinCount(args, count) {\n  if (args.length < count) {\n    throw new Error(`At least ${count} arguments were expected, got ${args.length} instead`);\n  }\n}\nfunction assertArgsMaxCount(args, count) {\n  if (args.length > count) {\n    throw new Error(`At most ${count} arguments were expected, got ${args.length} instead`);\n  }\n}\nfunction assertArgsEven(args) {\n  if (args.length % 2 !== 0) {\n    throw new Error(`An even amount of arguments was expected, got ${JSON.stringify(args)} instead`);\n  }\n}\nfunction assertArgsOdd(args) {\n  if (args.length % 2 === 0) {\n    throw new Error(`An odd amount of arguments was expected, got ${JSON.stringify(args)} instead`);\n  }\n}\nfunction assertNotEmptyType(args, types, descriptor) {\n  if (types === ValueTypes.NONE) {\n    throw new Error(`No matching type was found for the following expression ${descriptor}: ${JSON.stringify(args)}`);\n  }\n}\nfunction assertSingleType(args, types, descriptor) {\n  assertNotEmptyType(args, types, descriptor);\n  if (!isTypeUnique(types)) {\n    throw new Error(`Expected to have a unique type for the following expression ${descriptor}: ${JSON.stringify(args)}\nGot the following types instead: ${printTypes(types)}`);\n  }\n}\nfunction assertOfType(args, types, expectedTypes, descriptor) {\n  if ((types & expectedTypes) === ValueTypes.NONE) {\n    throw new Error(`Expected the ${descriptor} type of the following expression: ${JSON.stringify(args)} to be of the following types: ${printTypes(expectedTypes)}\nGot these types instead: ${printTypes(types)}`);\n  }\n}\nOperators['get'] = {\n  getReturnType: function (args) {\n    if (args.length === 2) {\n      const hint = args[1];\n      return getTypeFromHint( /** @type {string} */hint);\n    }\n    return ValueTypes.ANY;\n  },\n  toGlsl: function (context, args, expectedType) {\n    assertArgsMinCount(args, 1);\n    assertArgsMaxCount(args, 2);\n    assertString(args[0]);\n    const outputType = expectedType & Operators['get'].getReturnType(args);\n    assertSingleType(['get', ...args], outputType, '');\n    const name = args[0].toString();\n    const existing = context.attributes.find(a => a.name === name);\n    if (!existing) {\n      context.attributes.push({\n        name: name,\n        type: outputType\n      });\n    } else if (outputType !== existing.type) {\n      throw new Error(`The following attribute was used in different places with incompatible types: ${name}\nTypes were: ${printTypes(existing.type)} and ${printTypes(outputType)}`);\n    }\n    const prefix = context.inFragmentShader ? 'v_' : 'a_';\n    return prefix + name;\n  }\n};\n\n/**\n * Get the uniform name given a variable name.\n * @param {string} variableName The variable name.\n * @return {string} The uniform name.\n */\nexport function uniformNameForVariable(variableName) {\n  return 'u_var_' + variableName;\n}\nOperators['var'] = {\n  getReturnType: function () {\n    return ValueTypes.ANY;\n  },\n  toGlsl: function (context, args, expectedType) {\n    assertArgsCount(args, 1);\n    assertString(args[0]);\n    const name = args[0].toString();\n    if (!context.style.variables || context.style.variables[name] === undefined) {\n      throw new Error(`The following variable is missing from the style: ${name}`);\n    }\n    const initialValue = context.style.variables[name];\n    const outputType = expectedType & getValueType(initialValue);\n    assertSingleType(['var', ...args], outputType, '');\n    const existing = context.variables.find(a => a.name === name);\n    if (!existing) {\n      context.variables.push({\n        name: name,\n        type: outputType\n      });\n    } else if (outputType !== existing.type) {\n      throw new Error(`The following variable was used in different places with incompatible types: ${name}\nTypes were: ${printTypes(existing.type)} and ${printTypes(outputType)}`);\n    }\n    return uniformNameForVariable(name);\n  }\n};\nexport const PALETTE_TEXTURE_ARRAY = 'u_paletteTextures';\n\n// ['palette', index, colors]\nOperators['palette'] = {\n  getReturnType: function () {\n    return ValueTypes.COLOR;\n  },\n  toGlsl: function (context, args) {\n    assertArgsCount(args, 2);\n    assertNumber(args[0]);\n    const index = expressionToGlsl(context, args[0]);\n    const colors = args[1];\n    if (!Array.isArray(colors)) {\n      throw new Error('The second argument of palette must be an array');\n    }\n    const numColors = colors.length;\n    const palette = new Uint8Array(numColors * 4);\n    for (let i = 0; i < numColors; i++) {\n      const candidate = colors[i];\n      /**\n       * @type {import('../color.js').Color}\n       */\n      let color;\n      if (typeof candidate === 'string') {\n        color = fromString(candidate);\n      } else {\n        if (!Array.isArray(candidate)) {\n          throw new Error('The second argument of palette must be an array of strings or colors');\n        }\n        const length = candidate.length;\n        if (length === 4) {\n          color = candidate;\n        } else {\n          if (length !== 3) {\n            throw new Error(`Expected palette color to have 3 or 4 values, got ${length}`);\n          }\n          color = [candidate[0], candidate[1], candidate[2], 1];\n        }\n      }\n      const offset = i * 4;\n      palette[offset] = color[0];\n      palette[offset + 1] = color[1];\n      palette[offset + 2] = color[2];\n      palette[offset + 3] = color[3] * 255;\n    }\n    if (!context.paletteTextures) {\n      context.paletteTextures = [];\n    }\n    const paletteName = `${PALETTE_TEXTURE_ARRAY}[${context.paletteTextures.length}]`;\n    const paletteTexture = new PaletteTexture(paletteName, palette);\n    context.paletteTextures.push(paletteTexture);\n    return `texture2D(${paletteName}, vec2((${index} + 0.5) / ${numColors}.0, 0.5))`;\n  }\n};\nconst GET_BAND_VALUE_FUNC = 'getBandValue';\nOperators['band'] = {\n  getReturnType: function () {\n    return ValueTypes.NUMBER;\n  },\n  toGlsl: function (context, args) {\n    assertArgsMinCount(args, 1);\n    assertArgsMaxCount(args, 3);\n    const band = args[0];\n    if (!(GET_BAND_VALUE_FUNC in context.functions)) {\n      let ifBlocks = '';\n      const bandCount = context.bandCount || 1;\n      for (let i = 0; i < bandCount; i++) {\n        const colorIndex = Math.floor(i / 4);\n        let bandIndex = i % 4;\n        if (i === bandCount - 1 && bandIndex === 1) {\n          // LUMINANCE_ALPHA - band 1 assigned to rgb and band 2 assigned to alpha\n          bandIndex = 3;\n        }\n        const textureName = `${Uniforms.TILE_TEXTURE_ARRAY}[${colorIndex}]`;\n        ifBlocks += `\n          if (band == ${i + 1}.0) {\n            return texture2D(${textureName}, v_textureCoord + vec2(dx, dy))[${bandIndex}];\n          }\n        `;\n      }\n      context.functions[GET_BAND_VALUE_FUNC] = `\n        float getBandValue(float band, float xOffset, float yOffset) {\n          float dx = xOffset / ${Uniforms.TEXTURE_PIXEL_WIDTH};\n          float dy = yOffset / ${Uniforms.TEXTURE_PIXEL_HEIGHT};\n          ${ifBlocks}\n        }\n      `;\n    }\n    const bandExpression = expressionToGlsl(context, band);\n    const xOffsetExpression = expressionToGlsl(context, args[1] || 0);\n    const yOffsetExpression = expressionToGlsl(context, args[2] || 0);\n    return `${GET_BAND_VALUE_FUNC}(${bandExpression}, ${xOffsetExpression}, ${yOffsetExpression})`;\n  }\n};\nOperators['time'] = {\n  getReturnType: function () {\n    return ValueTypes.NUMBER;\n  },\n  toGlsl: function (context, args) {\n    assertArgsCount(args, 0);\n    return 'u_time';\n  }\n};\nOperators['zoom'] = {\n  getReturnType: function () {\n    return ValueTypes.NUMBER;\n  },\n  toGlsl: function (context, args) {\n    assertArgsCount(args, 0);\n    return 'u_zoom';\n  }\n};\nOperators['resolution'] = {\n  getReturnType: function () {\n    return ValueTypes.NUMBER;\n  },\n  toGlsl: function (context, args) {\n    assertArgsCount(args, 0);\n    return 'u_resolution';\n  }\n};\nOperators['geometry-type'] = {\n  getReturnType: function () {\n    return ValueTypes.STRING;\n  },\n  toGlsl: function (context, args) {\n    assertArgsCount(args, 0);\n    const name = 'geometryType';\n    const computeType = geometry => {\n      const type = geometry.getType();\n      switch (type) {\n        case 'Point':\n        case 'LineString':\n        case 'Polygon':\n          return type;\n        case 'MultiPoint':\n        case 'MultiLineString':\n        case 'MultiPolygon':\n          return type.substring(5);\n        case 'Circle':\n          return 'Polygon';\n        case 'GeometryCollection':\n          return computeType(geometry.getGeometries()[0]);\n        default:\n      }\n    };\n    const existing = context.attributes.find(a => a.name === name);\n    if (!existing) {\n      context.attributes.push({\n        name: name,\n        type: ValueTypes.STRING,\n        callback: feature => {\n          return computeType(feature.getGeometry());\n        }\n      });\n    }\n    const prefix = context.inFragmentShader ? 'v_' : 'a_';\n    return prefix + name;\n  }\n};\nOperators['*'] = {\n  getReturnType: function (args) {\n    let outputType = ValueTypes.NUMBER | ValueTypes.COLOR;\n    for (let i = 0; i < args.length; i++) {\n      outputType = outputType & getValueType(args[i]);\n    }\n    return outputType;\n  },\n  toGlsl: function (context, args, expectedType) {\n    assertArgsMinCount(args, 2);\n    let outputType = expectedType;\n    for (let i = 0; i < args.length; i++) {\n      outputType = outputType & getValueType(args[i]);\n    }\n    assertOfType(args, outputType, ValueTypes.NUMBER | ValueTypes.COLOR, 'output');\n    return `(${args.map(arg => expressionToGlsl(context, arg, outputType)).join(' * ')})`;\n  }\n};\nOperators['/'] = {\n  getReturnType: function () {\n    return ValueTypes.NUMBER;\n  },\n  toGlsl: function (context, args) {\n    assertArgsCount(args, 2);\n    assertNumbers(args);\n    return `(${expressionToGlsl(context, args[0])} / ${expressionToGlsl(context, args[1])})`;\n  }\n};\nOperators['+'] = {\n  getReturnType: function () {\n    return ValueTypes.NUMBER;\n  },\n  toGlsl: function (context, args) {\n    assertArgsMinCount(args, 2);\n    assertNumbers(args);\n    return `(${args.map(arg => expressionToGlsl(context, arg)).join(' + ')})`;\n  }\n};\nOperators['-'] = {\n  getReturnType: function () {\n    return ValueTypes.NUMBER;\n  },\n  toGlsl: function (context, args) {\n    assertArgsCount(args, 2);\n    assertNumbers(args);\n    return `(${expressionToGlsl(context, args[0])} - ${expressionToGlsl(context, args[1])})`;\n  }\n};\nOperators['clamp'] = {\n  getReturnType: function () {\n    return ValueTypes.NUMBER;\n  },\n  toGlsl: function (context, args) {\n    assertArgsCount(args, 3);\n    assertNumbers(args);\n    const min = expressionToGlsl(context, args[1]);\n    const max = expressionToGlsl(context, args[2]);\n    return `clamp(${expressionToGlsl(context, args[0])}, ${min}, ${max})`;\n  }\n};\nOperators['%'] = {\n  getReturnType: function () {\n    return ValueTypes.NUMBER;\n  },\n  toGlsl: function (context, args) {\n    assertArgsCount(args, 2);\n    assertNumbers(args);\n    return `mod(${expressionToGlsl(context, args[0])}, ${expressionToGlsl(context, args[1])})`;\n  }\n};\nOperators['^'] = {\n  getReturnType: function () {\n    return ValueTypes.NUMBER;\n  },\n  toGlsl: function (context, args) {\n    assertArgsCount(args, 2);\n    assertNumbers(args);\n    return `pow(${expressionToGlsl(context, args[0])}, ${expressionToGlsl(context, args[1])})`;\n  }\n};\nOperators['abs'] = {\n  getReturnType: function () {\n    return ValueTypes.NUMBER;\n  },\n  toGlsl: function (context, args) {\n    assertArgsCount(args, 1);\n    assertNumbers(args);\n    return `abs(${expressionToGlsl(context, args[0])})`;\n  }\n};\nOperators['floor'] = {\n  getReturnType: function () {\n    return ValueTypes.NUMBER;\n  },\n  toGlsl: function (context, args) {\n    assertArgsCount(args, 1);\n    assertNumbers(args);\n    return `floor(${expressionToGlsl(context, args[0])})`;\n  }\n};\nOperators['round'] = {\n  getReturnType: function () {\n    return ValueTypes.NUMBER;\n  },\n  toGlsl: function (context, args) {\n    assertArgsCount(args, 1);\n    assertNumbers(args);\n    return `floor(${expressionToGlsl(context, args[0])} + 0.5)`;\n  }\n};\nOperators['ceil'] = {\n  getReturnType: function () {\n    return ValueTypes.NUMBER;\n  },\n  toGlsl: function (context, args) {\n    assertArgsCount(args, 1);\n    assertNumbers(args);\n    return `ceil(${expressionToGlsl(context, args[0])})`;\n  }\n};\nOperators['sin'] = {\n  getReturnType: function () {\n    return ValueTypes.NUMBER;\n  },\n  toGlsl: function (context, args) {\n    assertArgsCount(args, 1);\n    assertNumbers(args);\n    return `sin(${expressionToGlsl(context, args[0])})`;\n  }\n};\nOperators['cos'] = {\n  getReturnType: function () {\n    return ValueTypes.NUMBER;\n  },\n  toGlsl: function (context, args) {\n    assertArgsCount(args, 1);\n    assertNumbers(args);\n    return `cos(${expressionToGlsl(context, args[0])})`;\n  }\n};\nOperators['atan'] = {\n  getReturnType: function () {\n    return ValueTypes.NUMBER;\n  },\n  toGlsl: function (context, args) {\n    assertArgsMinCount(args, 1);\n    assertArgsMaxCount(args, 2);\n    assertNumbers(args);\n    return args.length === 2 ? `atan(${expressionToGlsl(context, args[0])}, ${expressionToGlsl(context, args[1])})` : `atan(${expressionToGlsl(context, args[0])})`;\n  }\n};\nOperators['sqrt'] = {\n  getReturnType: function () {\n    return ValueTypes.NUMBER;\n  },\n  toGlsl: function (context, args) {\n    assertArgsCount(args, 1);\n    assertNumbers(args);\n    return `sqrt(${expressionToGlsl(context, args[0])})`;\n  }\n};\nOperators['>'] = {\n  getReturnType: function () {\n    return ValueTypes.BOOLEAN;\n  },\n  toGlsl: function (context, args) {\n    assertArgsCount(args, 2);\n    assertNumbers(args);\n    return `(${expressionToGlsl(context, args[0])} > ${expressionToGlsl(context, args[1])})`;\n  }\n};\nOperators['>='] = {\n  getReturnType: function () {\n    return ValueTypes.BOOLEAN;\n  },\n  toGlsl: function (context, args) {\n    assertArgsCount(args, 2);\n    assertNumbers(args);\n    return `(${expressionToGlsl(context, args[0])} >= ${expressionToGlsl(context, args[1])})`;\n  }\n};\nOperators['<'] = {\n  getReturnType: function () {\n    return ValueTypes.BOOLEAN;\n  },\n  toGlsl: function (context, args) {\n    assertArgsCount(args, 2);\n    assertNumbers(args);\n    return `(${expressionToGlsl(context, args[0])} < ${expressionToGlsl(context, args[1])})`;\n  }\n};\nOperators['<='] = {\n  getReturnType: function () {\n    return ValueTypes.BOOLEAN;\n  },\n  toGlsl: function (context, args) {\n    assertArgsCount(args, 2);\n    assertNumbers(args);\n    return `(${expressionToGlsl(context, args[0])} <= ${expressionToGlsl(context, args[1])})`;\n  }\n};\nfunction getEqualOperator(operator) {\n  return {\n    getReturnType: function () {\n      return ValueTypes.BOOLEAN;\n    },\n    toGlsl: function (context, args) {\n      assertArgsCount(args, 2);\n\n      // find common type\n      let type = ValueTypes.ANY;\n      for (let i = 0; i < args.length; i++) {\n        type &= getValueType(args[i]);\n      }\n      if (type === ValueTypes.NONE) {\n        throw new Error(`All arguments should be of compatible type, got ${JSON.stringify(args)} instead`);\n      }\n\n      // Since it's not possible to have color types here, we can leave it out\n      // This fixes issues in case the value type is ambiguously detected as a color (e.g. the string 'red')\n      type &= ~ValueTypes.COLOR;\n      return `(${expressionToGlsl(context, args[0], type)} ${operator} ${expressionToGlsl(context, args[1], type)})`;\n    }\n  };\n}\nOperators['=='] = getEqualOperator('==');\nOperators['!='] = getEqualOperator('!=');\nOperators['!'] = {\n  getReturnType: function () {\n    return ValueTypes.BOOLEAN;\n  },\n  toGlsl: function (context, args) {\n    assertArgsCount(args, 1);\n    assertBoolean(args[0]);\n    return `(!${expressionToGlsl(context, args[0], ValueTypes.BOOLEAN)})`;\n  }\n};\nfunction getDecisionOperator(operator) {\n  return {\n    getReturnType: function () {\n      return ValueTypes.BOOLEAN;\n    },\n    toGlsl: function (context, args) {\n      assertArgsMinCount(args, 2);\n      for (let i = 0; i < args.length; i++) {\n        assertBoolean(args[i]);\n      }\n      let result = args.map(arg => expressionToGlsl(context, arg, ValueTypes.BOOLEAN)).join(` ${operator} `);\n      result = `(${result})`;\n      return result;\n    }\n  };\n}\nOperators['all'] = getDecisionOperator('&&');\nOperators['any'] = getDecisionOperator('||');\nOperators['between'] = {\n  getReturnType: function () {\n    return ValueTypes.BOOLEAN;\n  },\n  toGlsl: function (context, args) {\n    assertArgsCount(args, 3);\n    assertNumbers(args);\n    const min = expressionToGlsl(context, args[1]);\n    const max = expressionToGlsl(context, args[2]);\n    const value = expressionToGlsl(context, args[0]);\n    return `(${value} >= ${min} && ${value} <= ${max})`;\n  }\n};\nOperators['array'] = {\n  getReturnType: function () {\n    return ValueTypes.NUMBER_ARRAY;\n  },\n  toGlsl: function (context, args) {\n    assertArgsMinCount(args, 2);\n    assertArgsMaxCount(args, 4);\n    assertNumbers(args);\n    const parsedArgs = args.map(function (val) {\n      return expressionToGlsl(context, val);\n    });\n    return `vec${args.length}(${parsedArgs.join(', ')})`;\n  }\n};\nOperators['color'] = {\n  getReturnType: function () {\n    return ValueTypes.COLOR;\n  },\n  toGlsl: function (context, args) {\n    assertArgsMinCount(args, 3);\n    assertArgsMaxCount(args, 4);\n    assertNumbers(args);\n    const parsedArgs = args.slice(0, 3).map(val => `${expressionToGlsl(context, val)} / 255.0`);\n    if (args.length === 3) {\n      return `vec4(${parsedArgs.join(', ')}, 1.0)`;\n    }\n    const alpha = expressionToGlsl(context, args[3]);\n    return `(${alpha} * vec4(${parsedArgs.join(', ')}, 1.0))`;\n  }\n};\nOperators['interpolate'] = {\n  getReturnType: function (args) {\n    let type = ValueTypes.COLOR | ValueTypes.NUMBER;\n    for (let i = 3; i < args.length; i += 2) {\n      type = type & getValueType(args[i]);\n    }\n    return type;\n  },\n  toGlsl: function (context, args, expectedType) {\n    assertArgsEven(args);\n    assertArgsMinCount(args, 6);\n\n    // validate interpolation type\n    const type = args[0];\n    let interpolation;\n    switch (type[0]) {\n      case 'linear':\n        interpolation = 1;\n        break;\n      case 'exponential':\n        interpolation = type[1];\n        break;\n      default:\n        interpolation = null;\n    }\n    if (!interpolation) {\n      throw new Error(`Invalid interpolation type for \"interpolate\" operator, received: ${JSON.stringify(type)}`);\n    }\n\n    // compute input/output types\n    const inputType = ValueTypes.NUMBER;\n    const outputType = Operators['interpolate'].getReturnType(args) & expectedType;\n    assertSingleType(['interpolate', ...args], outputType, 'output');\n    const input = expressionToGlsl(context, args[1], inputType);\n    const exponent = numberToGlsl(interpolation);\n    let result = '';\n    for (let i = 2; i < args.length - 2; i += 2) {\n      const stop1 = expressionToGlsl(context, args[i], inputType);\n      const output1 = result || expressionToGlsl(context, args[i + 1], outputType);\n      const stop2 = expressionToGlsl(context, args[i + 2], inputType);\n      const output2 = expressionToGlsl(context, args[i + 3], outputType);\n      let ratio;\n      if (interpolation === 1) {\n        ratio = `(${input} - ${stop1}) / (${stop2} - ${stop1})`;\n      } else {\n        ratio = `(pow(${exponent}, (${input} - ${stop1})) - 1.0) / (pow(${exponent}, (${stop2} - ${stop1})) - 1.0)`;\n      }\n      result = `mix(${output1}, ${output2}, clamp(${ratio}, 0.0, 1.0))`;\n    }\n    return result;\n  }\n};\nOperators['match'] = {\n  getReturnType: function (args) {\n    let type = ValueTypes.ANY;\n    for (let i = 2; i < args.length; i += 2) {\n      type = type & getValueType(args[i]);\n    }\n    type = type & getValueType(args[args.length - 1]);\n    return type;\n  },\n  toGlsl: function (context, args, expectedType) {\n    assertArgsEven(args);\n    assertArgsMinCount(args, 4);\n    let inputType = getValueType(args[0]);\n    for (let i = 1; i < args.length - 1; i += 2) {\n      inputType = inputType & getValueType(args[i]);\n    }\n    assertOfType(['match', ...args], inputType, ValueTypes.STRING | ValueTypes.NUMBER | ValueTypes.BOOLEAN, 'input');\n    inputType = (ValueTypes.STRING | ValueTypes.NUMBER | ValueTypes.BOOLEAN) & inputType;\n    const outputType = Operators['match'].getReturnType(args) & expectedType;\n    assertSingleType(['match', ...args], outputType, 'output');\n    const input = expressionToGlsl(context, args[0], inputType);\n    const fallback = expressionToGlsl(context, args[args.length - 1], outputType);\n    let result = null;\n    for (let i = args.length - 3; i >= 1; i -= 2) {\n      const match = expressionToGlsl(context, args[i], inputType);\n      const output = expressionToGlsl(context, args[i + 1], outputType);\n      result = `(${input} == ${match} ? ${output} : ${result || fallback})`;\n    }\n    return result;\n  }\n};\nOperators['case'] = {\n  getReturnType: function (args) {\n    let type = ValueTypes.ANY;\n    for (let i = 1; i < args.length; i += 2) {\n      type = type & getValueType(args[i]);\n    }\n    type = type & getValueType(args[args.length - 1]);\n    return type;\n  },\n  toGlsl: function (context, args, expectedType) {\n    assertArgsOdd(args);\n    assertArgsMinCount(args, 3);\n    const outputType = Operators['case'].getReturnType(args) & expectedType;\n    assertSingleType(['case', ...args], outputType, 'output');\n    for (let i = 0; i < args.length - 1; i += 2) {\n      assertBoolean(args[i]);\n    }\n    const fallback = expressionToGlsl(context, args[args.length - 1], outputType);\n    let result = null;\n    for (let i = args.length - 3; i >= 0; i -= 2) {\n      const condition = expressionToGlsl(context, args[i], ValueTypes.BOOLEAN);\n      const output = expressionToGlsl(context, args[i + 1], outputType);\n      result = `(${condition} ? ${output} : ${result || fallback})`;\n    }\n    return result;\n  }\n};\nOperators['in'] = {\n  getReturnType: function (args) {\n    return ValueTypes.BOOLEAN;\n  },\n  toGlsl: function (context, args) {\n    assertArgsCount(args, 2);\n    const needle = args[0];\n    let haystack = args[1];\n    if (!Array.isArray(haystack)) {\n      throw new Error(`The \"in\" operator expects an array literal as its second argument.`);\n    }\n    if (typeof haystack[0] === 'string') {\n      if (haystack[0] !== 'literal') {\n        throw new Error(`For the \"in\" operator, a string array should be wrapped in a \"literal\" operator to disambiguate from expressions.`);\n      }\n      if (!Array.isArray(haystack[1])) {\n        throw new Error(`The \"in\" operator was provided a literal value which was not an array as second argument.`);\n      }\n      haystack = haystack[1];\n    }\n    let inputType = getValueType(needle);\n    for (let i = 0; i < haystack.length - 1; i += 1) {\n      inputType = inputType & getValueType(haystack[i]);\n    }\n    assertOfType(['match', ...args], inputType, ValueTypes.STRING | ValueTypes.NUMBER | ValueTypes.BOOLEAN, 'input');\n    inputType = (ValueTypes.STRING | ValueTypes.NUMBER | ValueTypes.BOOLEAN) & inputType;\n    const funcName = computeOperatorFunctionName('in', context);\n    const tests = [];\n    for (let i = 0; i < haystack.length; i += 1) {\n      tests.push(`  if (inputValue == ${expressionToGlsl(context, haystack[i], inputType)}) { return true; }`);\n    }\n    context.functions[funcName] = `bool ${funcName}(float inputValue) {\n${tests.join('\\n')}\n  return false;\n}`;\n    return `${funcName}(${expressionToGlsl(context, needle, inputType)})`;\n  }\n};","map":{"version":3,"names":["PaletteTexture","Uniforms","asArray","fromString","isStringColor","ValueTypes","NUMBER","STRING","COLOR","BOOLEAN","NUMBER_ARRAY","ANY","NONE","getTypeFromHint","typeHint","Error","Operators","getValueType","value","Array","isArray","JSON","stringify","valueArr","onlyNumbers","every","v","length","operator","undefined","getReturnType","slice","isTypeUnique","valueType","Math","log2","printTypes","result","push","join","computeOperatorFunctionName","context","Object","keys","functions","numberToGlsl","s","toString","includes","arrayToGlsl","array","map","colorToGlsl","color","alpha","stringToFloatMap","stringToFloatCounter","getStringNumberEquivalent","string","stringToGlsl","expressionToGlsl","expectedType","returnType","toGlsl","possibleType","assertNotEmptyType","assertNumber","assertNumbers","values","i","assertString","assertBoolean","assertArgsCount","args","count","assertArgsMinCount","assertArgsMaxCount","assertArgsEven","assertArgsOdd","types","descriptor","assertSingleType","assertOfType","expectedTypes","hint","outputType","name","existing","attributes","find","a","type","prefix","inFragmentShader","uniformNameForVariable","variableName","style","variables","initialValue","PALETTE_TEXTURE_ARRAY","index","colors","numColors","palette","Uint8Array","candidate","offset","paletteTextures","paletteName","paletteTexture","GET_BAND_VALUE_FUNC","band","ifBlocks","bandCount","colorIndex","floor","bandIndex","textureName","TILE_TEXTURE_ARRAY","TEXTURE_PIXEL_WIDTH","TEXTURE_PIXEL_HEIGHT","bandExpression","xOffsetExpression","yOffsetExpression","computeType","geometry","getType","substring","getGeometries","callback","feature","getGeometry","arg","min","max","getEqualOperator","getDecisionOperator","parsedArgs","val","interpolation","inputType","input","exponent","stop1","output1","stop2","output2","ratio","fallback","match","output","condition","needle","haystack","funcName","tests"],"sources":["E:/Desktop/scenerymonitor/node_modules/ol/style/expressions.js"],"sourcesContent":["/**\n * Operators and utilities used for style expressions\n * @module ol/style/expressions\n */\n\nimport PaletteTexture from '../webgl/PaletteTexture.js';\nimport {Uniforms} from '../renderer/webgl/TileLayer.js';\nimport {asArray, fromString, isStringColor} from '../color.js';\n\n/**\n * Base type used for literal style parameters; can be a number literal or the output of an operator,\n * which in turns takes {@link import(\"./expressions.js\").ExpressionValue} arguments.\n *\n * The following operators can be used:\n *\n * * Reading operators:\n *   * `['band', bandIndex, xOffset, yOffset]` For tile layers only. Fetches pixel values from band\n *     `bandIndex` of the source's data. The first `bandIndex` of the source data is `1`. Fetched values\n *     are in the 0..1 range. {@link import(\"../source/TileImage.js\").default} sources have 4 bands: red,\n *     green, blue and alpha. {@link import(\"../source/DataTile.js\").default} sources can have any number\n *     of bands, depending on the underlying data source and\n *     {@link import(\"../source/GeoTIFF.js\").Options configuration}. `xOffset` and `yOffset` are optional\n *     and allow specifying pixel offsets for x and y. This is used for sampling data from neighboring pixels.\n *   * `['get', 'attributeName', typeHint]` fetches a feature property value, similar to `feature.get('attributeName')`\n *     A type hint can optionally be specified, in case the resulting expression contains a type ambiguity which\n *     will make it invalid. Type hints can be one of: 'string', 'color', 'number', 'boolean', 'number[]'\n *   * `['geometry-type']` returns a feature's geometry type as string, either: 'LineString', 'Point' or 'Polygon'\n *     `Multi*` values are returned as their singular equivalent\n *     `Circle` geometries are returned as 'Polygon'\n *     `GeometryCollection` geometries are returned as the type of the first geometry found in the collection\n *   * `['resolution']` returns the current resolution\n *   * `['time']` returns the time in seconds since the creation of the layer\n *   * `['var', 'varName']` fetches a value from the style variables; will throw an error if that variable is undefined\n *   * `['zoom']` returns the current zoom level\n *\n * * Math operators:\n *   * `['*', value1, value2, ...]` multiplies the values (either numbers or colors)\n *   * `['/', value1, value2]` divides `value1` by `value2`\n *   * `['+', value1, value2, ...]` adds the values\n *   * `['-', value1, value2]` subtracts `value2` from `value1`\n *   * `['clamp', value, low, high]` clamps `value` between `low` and `high`\n *   * `['%', value1, value2]` returns the result of `value1 % value2` (modulo)\n *   * `['^', value1, value2]` returns the value of `value1` raised to the `value2` power\n *   * `['abs', value1]` returns the absolute value of `value1`\n *   * `['floor', value1]` returns the nearest integer less than or equal to `value1`\n *   * `['round', value1]` returns the nearest integer to `value1`\n *   * `['ceil', value1]` returns the nearest integer greater than or equal to `value1`\n *   * `['sin', value1]` returns the sine of `value1`\n *   * `['cos', value1]` returns the cosine of `value1`\n *   * `['atan', value1, value2]` returns `atan2(value1, value2)`. If `value2` is not provided, returns `atan(value1)`\n *   * `['sqrt', value1]` returns the square root of `value1`\n *\n * * Transform operators:\n *   * `['case', condition1, output1, ...conditionN, outputN, fallback]` selects the first output whose corresponding\n *     condition evaluates to `true`. If no match is found, returns the `fallback` value.\n *     All conditions should be `boolean`, output and fallback can be any kind.\n *   * `['match', input, match1, output1, ...matchN, outputN, fallback]` compares the `input` value against all\n *     provided `matchX` values, returning the output associated with the first valid match. If no match is found,\n *     returns the `fallback` value.\n *     `input` and `matchX` values must all be of the same type, and can be `number` or `string`. `outputX` and\n *     `fallback` values must be of the same type, and can be of any kind.\n *   * `['interpolate', interpolation, input, stop1, output1, ...stopN, outputN]` returns a value by interpolating between\n *     pairs of inputs and outputs; `interpolation` can either be `['linear']` or `['exponential', base]` where `base` is\n *     the rate of increase from stop A to stop B (i.e. power to which the interpolation ratio is raised); a value\n *     of 1 is equivalent to `['linear']`.\n *     `input` and `stopX` values must all be of type `number`. `outputX` values can be `number` or `color` values.\n *     Note: `input` will be clamped between `stop1` and `stopN`, meaning that all output values will be comprised\n *     between `output1` and `outputN`.\n *\n * * Logical operators:\n *   * `['<', value1, value2]` returns `true` if `value1` is strictly lower than `value2`, or `false` otherwise.\n *   * `['<=', value1, value2]` returns `true` if `value1` is lower than or equals `value2`, or `false` otherwise.\n *   * `['>', value1, value2]` returns `true` if `value1` is strictly greater than `value2`, or `false` otherwise.\n *   * `['>=', value1, value2]` returns `true` if `value1` is greater than or equals `value2`, or `false` otherwise.\n *   * `['==', value1, value2]` returns `true` if `value1` equals `value2`, or `false` otherwise.\n *   * `['!=', value1, value2]` returns `true` if `value1` does not equal `value2`, or `false` otherwise.\n *   * `['!', value1]` returns `false` if `value1` is `true` or greater than `0`, or `true` otherwise.\n *   * `['all', value1, value2, ...]` returns `true` if all the inputs are `true`, `false` otherwise.\n *   * `['any', value1, value2, ...]` returns `true` if any of the inputs are `true`, `false` otherwise.\n *   * `['between', value1, value2, value3]` returns `true` if `value1` is contained between `value2` and `value3`\n *     (inclusively), or `false` otherwise.\n *   * `['in', needle, haystack]` returns `true` if `needle` is found in `haystack`, and\n *     `false` otherwise.\n *     This operator has the following limitations:\n *     * `haystack` has to be an array of numbers or strings (searching for a substring in a string is not supported yet)\n *     * Only literal arrays are supported as `haystack` for now; this means that `haystack` cannot be the result of an\n *     expression. If `haystack` is an array of strings, use the `literal` operator to disambiguate from an expression:\n *     `['literal', ['abc', 'def', 'ghi']]`\n *\n * * Conversion operators:\n *   * `['array', value1, ...valueN]` creates a numerical array from `number` values; please note that the amount of\n *     values can currently only be 2, 3 or 4.\n *   * `['color', red, green, blue, alpha]` creates a `color` value from `number` values; the `alpha` parameter is\n *     optional; if not specified, it will be set to 1.\n *     Note: `red`, `green` and `blue` components must be values between 0 and 255; `alpha` between 0 and 1.\n *   * `['palette', index, colors]` picks a `color` value from an array of colors using the given index; the `index`\n *     expression must evaluate to a number; the items in the `colors` array must be strings with hex colors\n *     (e.g. `'#86A136'`), colors using the rgba[a] functional notation (e.g. `'rgb(134, 161, 54)'` or `'rgba(134, 161, 54, 1)'`),\n *     named colors (e.g. `'red'`), or array literals with 3 ([r, g, b]) or 4 ([r, g, b, a]) values (with r, g, and b\n *     in the 0-255 range and a in the 0-1 range).\n *\n * Values can either be literals or another operator, as they will be evaluated recursively.\n * Literal values can be of the following types:\n * * `boolean`\n * * `number`\n * * `number[]` (number arrays can only have a length of 2, 3 or 4)\n * * `string`\n * * {@link module:ol/color~Color}\n *\n * @typedef {Array<*>|import(\"../color.js\").Color|string|number|boolean} ExpressionValue\n * @api\n */\n\n/**\n * Possible inferred types from a given value or expression.\n * Note: these are binary flags.\n * @enum {number}\n */\nexport const ValueTypes = {\n  NUMBER: 0b00001,\n  STRING: 0b00010,\n  COLOR: 0b00100,\n  BOOLEAN: 0b01000,\n  NUMBER_ARRAY: 0b10000,\n  ANY: 0b11111,\n  NONE: 0,\n};\n\n/**\n * @param {string} typeHint Type hint\n * @return {ValueTypes} Resulting value type (will be a single type)\n */\nfunction getTypeFromHint(typeHint) {\n  switch (typeHint) {\n    case 'string':\n      return ValueTypes.STRING;\n    case 'color':\n      return ValueTypes.COLOR;\n    case 'number':\n      return ValueTypes.NUMBER;\n    case 'boolean':\n      return ValueTypes.BOOLEAN;\n    case 'number[]':\n      return ValueTypes.NUMBER_ARRAY;\n    default:\n      throw new Error(`Unrecognized type hint: ${typeHint}`);\n  }\n}\n\n/**\n * An operator declaration must contain two methods: `getReturnType` which returns a type based on\n * the operator arguments, and `toGlsl` which returns a GLSL-compatible string.\n * Note: both methods can process arguments recursively.\n * @typedef {Object} Operator\n * @property {function(Array<ExpressionValue>): ValueTypes|number} getReturnType Returns one or several types\n * @property {function(ParsingContext, Array<ExpressionValue>, ValueTypes): string} toGlsl Returns a GLSL-compatible string\n * given a parsing context, an array of arguments and an expected type.\n * Note: the expected type can be a combination such as ValueTypes.NUMBER | ValueTypes.STRING or ValueTypes.ANY for instance\n */\n\n/**\n * Operator declarations\n * @type {Object<string, Operator>}\n */\nexport const Operators = {};\n\n/**\n * Returns the possible types for a given value (each type being a binary flag)\n * To test a value use e.g. `getValueType(v) & ValueTypes.BOOLEAN`\n * @param {ExpressionValue} value Value\n * @return {ValueTypes|number} Type or types inferred from the value\n */\nexport function getValueType(value) {\n  if (typeof value === 'number') {\n    return ValueTypes.NUMBER;\n  }\n  if (typeof value === 'boolean') {\n    return ValueTypes.BOOLEAN;\n  }\n  if (typeof value === 'string') {\n    if (isStringColor(value)) {\n      return ValueTypes.COLOR | ValueTypes.STRING;\n    }\n    return ValueTypes.STRING;\n  }\n  if (!Array.isArray(value)) {\n    throw new Error(`Unhandled value type: ${JSON.stringify(value)}`);\n  }\n  const valueArr = /** @type {Array<*>} */ (value);\n  const onlyNumbers = valueArr.every(function (v) {\n    return typeof v === 'number';\n  });\n  if (onlyNumbers) {\n    if (valueArr.length === 3 || valueArr.length === 4) {\n      return ValueTypes.COLOR | ValueTypes.NUMBER_ARRAY;\n    }\n    return ValueTypes.NUMBER_ARRAY;\n  }\n  if (typeof valueArr[0] !== 'string') {\n    throw new Error(\n      `Expected an expression operator but received: ${JSON.stringify(\n        valueArr\n      )}`\n    );\n  }\n  const operator = Operators[valueArr[0]];\n  if (operator === undefined) {\n    throw new Error(\n      `Unrecognized expression operator: ${JSON.stringify(valueArr)}`\n    );\n  }\n  return operator.getReturnType(valueArr.slice(1));\n}\n\n/**\n * Checks if only one value type is enabled in the input number.\n * @param {ValueTypes|number} valueType Number containing value type binary flags\n * @return {boolean} True if only one type flag is enabled, false if zero or multiple\n */\nexport function isTypeUnique(valueType) {\n  return Math.log2(valueType) % 1 === 0;\n}\n\n/**\n * Print types as a readable string\n * @param {ValueTypes|number} valueType Number containing value type binary flags\n * @return {string} Types\n */\nfunction printTypes(valueType) {\n  const result = [];\n  if ((valueType & ValueTypes.NUMBER) > 0) {\n    result.push('number');\n  }\n  if ((valueType & ValueTypes.COLOR) > 0) {\n    result.push('color');\n  }\n  if ((valueType & ValueTypes.BOOLEAN) > 0) {\n    result.push('boolean');\n  }\n  if ((valueType & ValueTypes.NUMBER_ARRAY) > 0) {\n    result.push('number[]');\n  }\n  if ((valueType & ValueTypes.STRING) > 0) {\n    result.push('string');\n  }\n  return result.length > 0 ? result.join(', ') : '(no type)';\n}\n\n/**\n * @typedef {Object} ParsingContextExternal\n * @property {string} name Name, unprefixed\n * @property {ValueTypes} type One of the value types constants\n * @property {function(import(\"../Feature.js\").FeatureLike): *} [callback] Function used for computing the attribute value;\n *   if undefined, `feature.get(attribute.name)` will be used\n */\n\n/**\n * Context available during the parsing of an expression.\n * @typedef {Object} ParsingContext\n * @property {boolean} [inFragmentShader] If false, means the expression output should be made for a vertex shader\n * @property {Array<ParsingContextExternal>} variables External variables used in the expression\n * @property {Array<ParsingContextExternal>} attributes External attributes used in the expression\n * @property {Object<string, string>} functions Lookup of functions used by the style.\n * @property {number} [bandCount] Number of bands per pixel.\n * @property {Array<PaletteTexture>} [paletteTextures] List of palettes used by the style.\n * @property {import(\"../style/literal\").LiteralStyle} style The style being parsed\n */\n\n/**\n * @param {string} operator Operator\n * @param {ParsingContext} context Parsing context\n * @return {string} A function name based on the operator, unique in the given context\n */\nfunction computeOperatorFunctionName(operator, context) {\n  return `operator_${operator}_${Object.keys(context.functions).length}`;\n}\n\n/**\n * Will return the number as a float with a dot separator, which is required by GLSL.\n * @param {number} v Numerical value.\n * @return {string} The value as string.\n */\nexport function numberToGlsl(v) {\n  const s = v.toString();\n  return s.includes('.') ? s : s + '.0';\n}\n\n/**\n * Will return the number array as a float with a dot separator, concatenated with ', '.\n * @param {Array<number>} array Numerical values array.\n * @return {string} The array as a vector, e. g.: `vec3(1.0, 2.0, 3.0)`.\n */\nexport function arrayToGlsl(array) {\n  if (array.length < 2 || array.length > 4) {\n    throw new Error(\n      '`formatArray` can only output `vec2`, `vec3` or `vec4` arrays.'\n    );\n  }\n  return `vec${array.length}(${array.map(numberToGlsl).join(', ')})`;\n}\n\n/**\n * Will normalize and converts to string a `vec4` color array compatible with GLSL.\n * @param {string|import(\"../color.js\").Color} color Color either in string format or [r, g, b, a] array format,\n * with RGB components in the 0..255 range and the alpha component in the 0..1 range.\n * Note that the final array will always have 4 components.\n * @return {string} The color expressed in the `vec4(1.0, 1.0, 1.0, 1.0)` form.\n */\nexport function colorToGlsl(color) {\n  const array = asArray(color);\n  const alpha = array.length > 3 ? array[3] : 1;\n  // all components are premultiplied with alpha value\n  return arrayToGlsl([\n    (array[0] / 255) * alpha,\n    (array[1] / 255) * alpha,\n    (array[2] / 255) * alpha,\n    alpha,\n  ]);\n}\n\n/** @type {Object<string, number>} */\nconst stringToFloatMap = {};\nlet stringToFloatCounter = 0;\n\n/**\n * Returns a stable equivalent number for the string literal.\n * @param {string} string String literal value\n * @return {number} Number equivalent\n */\nexport function getStringNumberEquivalent(string) {\n  if (!(string in stringToFloatMap)) {\n    stringToFloatMap[string] = stringToFloatCounter++;\n  }\n  return stringToFloatMap[string];\n}\n\n/**\n * Returns a stable equivalent number for the string literal, for use in shaders. This number is then\n * converted to be a GLSL-compatible string.\n * Note: with a float precision of `mediump`, the amount of unique strings supported is 16,777,216\n * @param {string} string String literal value\n * @return {string} GLSL-compatible string containing a number\n */\nexport function stringToGlsl(string) {\n  return numberToGlsl(getStringNumberEquivalent(string));\n}\n\n/**\n * Recursively parses a style expression and outputs a GLSL-compatible string. Takes in a parsing context that\n * will be read and modified during the parsing operation.\n * @param {ParsingContext} context Parsing context\n * @param {ExpressionValue} value Value\n * @param {ValueTypes|number} [expectedType] Expected final type (can be several types combined)\n * If omitted, defaults to ValueTypes.NUMBER\n * @return {string} GLSL-compatible output\n */\nexport function expressionToGlsl(context, value, expectedType) {\n  const returnType =\n    expectedType !== undefined ? expectedType : ValueTypes.NUMBER;\n  // operator\n  if (Array.isArray(value) && typeof value[0] === 'string') {\n    const operator = Operators[value[0]];\n    if (operator === undefined) {\n      throw new Error(\n        `Unrecognized expression operator: ${JSON.stringify(value)}`\n      );\n    }\n    return operator.toGlsl(context, value.slice(1), returnType);\n  }\n\n  const possibleType = getValueType(value) & returnType;\n  assertNotEmptyType(value, possibleType, '');\n\n  if ((possibleType & ValueTypes.NUMBER) > 0) {\n    return numberToGlsl(/** @type {number} */ (value));\n  }\n\n  if ((possibleType & ValueTypes.BOOLEAN) > 0) {\n    return value.toString();\n  }\n\n  if ((possibleType & ValueTypes.STRING) > 0) {\n    return stringToGlsl(value.toString());\n  }\n\n  if ((possibleType & ValueTypes.COLOR) > 0) {\n    return colorToGlsl(/** @type {Array<number> | string} */ (value));\n  }\n\n  if ((possibleType & ValueTypes.NUMBER_ARRAY) > 0) {\n    return arrayToGlsl(/** @type {Array<number>} */ (value));\n  }\n\n  throw new Error(\n    `Unexpected expression ${value} (expected type ${printTypes(returnType)})`\n  );\n}\n\nfunction assertNumber(value) {\n  if ((getValueType(value) & ValueTypes.NUMBER) === 0) {\n    throw new Error(\n      `A numeric value was expected, got ${JSON.stringify(value)} instead`\n    );\n  }\n}\nfunction assertNumbers(values) {\n  for (let i = 0; i < values.length; i++) {\n    assertNumber(values[i]);\n  }\n}\nfunction assertString(value) {\n  if ((getValueType(value) & ValueTypes.STRING) === 0) {\n    throw new Error(\n      `A string value was expected, got ${JSON.stringify(value)} instead`\n    );\n  }\n}\nfunction assertBoolean(value) {\n  if ((getValueType(value) & ValueTypes.BOOLEAN) === 0) {\n    throw new Error(\n      `A boolean value was expected, got ${JSON.stringify(value)} instead`\n    );\n  }\n}\nfunction assertArgsCount(args, count) {\n  if (args.length !== count) {\n    throw new Error(\n      `Exactly ${count} arguments were expected, got ${args.length} instead`\n    );\n  }\n}\nfunction assertArgsMinCount(args, count) {\n  if (args.length < count) {\n    throw new Error(\n      `At least ${count} arguments were expected, got ${args.length} instead`\n    );\n  }\n}\nfunction assertArgsMaxCount(args, count) {\n  if (args.length > count) {\n    throw new Error(\n      `At most ${count} arguments were expected, got ${args.length} instead`\n    );\n  }\n}\nfunction assertArgsEven(args) {\n  if (args.length % 2 !== 0) {\n    throw new Error(\n      `An even amount of arguments was expected, got ${JSON.stringify(\n        args\n      )} instead`\n    );\n  }\n}\nfunction assertArgsOdd(args) {\n  if (args.length % 2 === 0) {\n    throw new Error(\n      `An odd amount of arguments was expected, got ${JSON.stringify(\n        args\n      )} instead`\n    );\n  }\n}\nfunction assertNotEmptyType(args, types, descriptor) {\n  if (types === ValueTypes.NONE) {\n    throw new Error(\n      `No matching type was found for the following expression ${descriptor}: ${JSON.stringify(\n        args\n      )}`\n    );\n  }\n}\nfunction assertSingleType(args, types, descriptor) {\n  assertNotEmptyType(args, types, descriptor);\n  if (!isTypeUnique(types)) {\n    throw new Error(\n      `Expected to have a unique type for the following expression ${descriptor}: ${JSON.stringify(\n        args\n      )}\nGot the following types instead: ${printTypes(types)}`\n    );\n  }\n}\nfunction assertOfType(args, types, expectedTypes, descriptor) {\n  if ((types & expectedTypes) === ValueTypes.NONE) {\n    throw new Error(\n      `Expected the ${descriptor} type of the following expression: ${JSON.stringify(\n        args\n      )} to be of the following types: ${printTypes(expectedTypes)}\nGot these types instead: ${printTypes(types)}`\n    );\n  }\n}\n\nOperators['get'] = {\n  getReturnType: function (args) {\n    if (args.length === 2) {\n      const hint = args[1];\n      return getTypeFromHint(/** @type {string} */ (hint));\n    }\n    return ValueTypes.ANY;\n  },\n  toGlsl: function (context, args, expectedType) {\n    assertArgsMinCount(args, 1);\n    assertArgsMaxCount(args, 2);\n    assertString(args[0]);\n    const outputType = expectedType & Operators['get'].getReturnType(args);\n    assertSingleType(['get', ...args], outputType, '');\n    const name = args[0].toString();\n    const existing = context.attributes.find((a) => a.name === name);\n    if (!existing) {\n      context.attributes.push({\n        name: name,\n        type: outputType,\n      });\n    } else if (outputType !== existing.type) {\n      throw new Error(\n        `The following attribute was used in different places with incompatible types: ${name}\nTypes were: ${printTypes(existing.type)} and ${printTypes(outputType)}`\n      );\n    }\n    const prefix = context.inFragmentShader ? 'v_' : 'a_';\n    return prefix + name;\n  },\n};\n\n/**\n * Get the uniform name given a variable name.\n * @param {string} variableName The variable name.\n * @return {string} The uniform name.\n */\nexport function uniformNameForVariable(variableName) {\n  return 'u_var_' + variableName;\n}\n\nOperators['var'] = {\n  getReturnType: function () {\n    return ValueTypes.ANY;\n  },\n  toGlsl: function (context, args, expectedType) {\n    assertArgsCount(args, 1);\n    assertString(args[0]);\n    const name = args[0].toString();\n    if (\n      !context.style.variables ||\n      context.style.variables[name] === undefined\n    ) {\n      throw new Error(\n        `The following variable is missing from the style: ${name}`\n      );\n    }\n    const initialValue = context.style.variables[name];\n    const outputType = expectedType & getValueType(initialValue);\n    assertSingleType(['var', ...args], outputType, '');\n    const existing = context.variables.find((a) => a.name === name);\n    if (!existing) {\n      context.variables.push({\n        name: name,\n        type: outputType,\n      });\n    } else if (outputType !== existing.type) {\n      throw new Error(\n        `The following variable was used in different places with incompatible types: ${name}\nTypes were: ${printTypes(existing.type)} and ${printTypes(outputType)}`\n      );\n    }\n    return uniformNameForVariable(name);\n  },\n};\n\nexport const PALETTE_TEXTURE_ARRAY = 'u_paletteTextures';\n\n// ['palette', index, colors]\nOperators['palette'] = {\n  getReturnType: function () {\n    return ValueTypes.COLOR;\n  },\n  toGlsl: function (context, args) {\n    assertArgsCount(args, 2);\n    assertNumber(args[0]);\n    const index = expressionToGlsl(context, args[0]);\n    const colors = args[1];\n    if (!Array.isArray(colors)) {\n      throw new Error('The second argument of palette must be an array');\n    }\n    const numColors = colors.length;\n    const palette = new Uint8Array(numColors * 4);\n    for (let i = 0; i < numColors; i++) {\n      const candidate = colors[i];\n      /**\n       * @type {import('../color.js').Color}\n       */\n      let color;\n      if (typeof candidate === 'string') {\n        color = fromString(candidate);\n      } else {\n        if (!Array.isArray(candidate)) {\n          throw new Error(\n            'The second argument of palette must be an array of strings or colors'\n          );\n        }\n        const length = candidate.length;\n        if (length === 4) {\n          color = candidate;\n        } else {\n          if (length !== 3) {\n            throw new Error(\n              `Expected palette color to have 3 or 4 values, got ${length}`\n            );\n          }\n          color = [candidate[0], candidate[1], candidate[2], 1];\n        }\n      }\n      const offset = i * 4;\n      palette[offset] = color[0];\n      palette[offset + 1] = color[1];\n      palette[offset + 2] = color[2];\n      palette[offset + 3] = color[3] * 255;\n    }\n    if (!context.paletteTextures) {\n      context.paletteTextures = [];\n    }\n    const paletteName = `${PALETTE_TEXTURE_ARRAY}[${context.paletteTextures.length}]`;\n    const paletteTexture = new PaletteTexture(paletteName, palette);\n    context.paletteTextures.push(paletteTexture);\n    return `texture2D(${paletteName}, vec2((${index} + 0.5) / ${numColors}.0, 0.5))`;\n  },\n};\n\nconst GET_BAND_VALUE_FUNC = 'getBandValue';\n\nOperators['band'] = {\n  getReturnType: function () {\n    return ValueTypes.NUMBER;\n  },\n  toGlsl: function (context, args) {\n    assertArgsMinCount(args, 1);\n    assertArgsMaxCount(args, 3);\n    const band = args[0];\n\n    if (!(GET_BAND_VALUE_FUNC in context.functions)) {\n      let ifBlocks = '';\n      const bandCount = context.bandCount || 1;\n      for (let i = 0; i < bandCount; i++) {\n        const colorIndex = Math.floor(i / 4);\n        let bandIndex = i % 4;\n        if (i === bandCount - 1 && bandIndex === 1) {\n          // LUMINANCE_ALPHA - band 1 assigned to rgb and band 2 assigned to alpha\n          bandIndex = 3;\n        }\n        const textureName = `${Uniforms.TILE_TEXTURE_ARRAY}[${colorIndex}]`;\n        ifBlocks += `\n          if (band == ${i + 1}.0) {\n            return texture2D(${textureName}, v_textureCoord + vec2(dx, dy))[${bandIndex}];\n          }\n        `;\n      }\n\n      context.functions[GET_BAND_VALUE_FUNC] = `\n        float getBandValue(float band, float xOffset, float yOffset) {\n          float dx = xOffset / ${Uniforms.TEXTURE_PIXEL_WIDTH};\n          float dy = yOffset / ${Uniforms.TEXTURE_PIXEL_HEIGHT};\n          ${ifBlocks}\n        }\n      `;\n    }\n\n    const bandExpression = expressionToGlsl(context, band);\n    const xOffsetExpression = expressionToGlsl(context, args[1] || 0);\n    const yOffsetExpression = expressionToGlsl(context, args[2] || 0);\n    return `${GET_BAND_VALUE_FUNC}(${bandExpression}, ${xOffsetExpression}, ${yOffsetExpression})`;\n  },\n};\n\nOperators['time'] = {\n  getReturnType: function () {\n    return ValueTypes.NUMBER;\n  },\n  toGlsl: function (context, args) {\n    assertArgsCount(args, 0);\n    return 'u_time';\n  },\n};\n\nOperators['zoom'] = {\n  getReturnType: function () {\n    return ValueTypes.NUMBER;\n  },\n  toGlsl: function (context, args) {\n    assertArgsCount(args, 0);\n    return 'u_zoom';\n  },\n};\n\nOperators['resolution'] = {\n  getReturnType: function () {\n    return ValueTypes.NUMBER;\n  },\n  toGlsl: function (context, args) {\n    assertArgsCount(args, 0);\n    return 'u_resolution';\n  },\n};\n\nOperators['geometry-type'] = {\n  getReturnType: function () {\n    return ValueTypes.STRING;\n  },\n  toGlsl: function (context, args) {\n    assertArgsCount(args, 0);\n    const name = 'geometryType';\n    const computeType = (geometry) => {\n      const type = geometry.getType();\n      switch (type) {\n        case 'Point':\n        case 'LineString':\n        case 'Polygon':\n          return type;\n        case 'MultiPoint':\n        case 'MultiLineString':\n        case 'MultiPolygon':\n          return type.substring(5);\n        case 'Circle':\n          return 'Polygon';\n        case 'GeometryCollection':\n          return computeType(geometry.getGeometries()[0]);\n        default:\n      }\n    };\n    const existing = context.attributes.find((a) => a.name === name);\n    if (!existing) {\n      context.attributes.push({\n        name: name,\n        type: ValueTypes.STRING,\n        callback: (feature) => {\n          return computeType(feature.getGeometry());\n        },\n      });\n    }\n    const prefix = context.inFragmentShader ? 'v_' : 'a_';\n    return prefix + name;\n  },\n};\n\nOperators['*'] = {\n  getReturnType: function (args) {\n    let outputType = ValueTypes.NUMBER | ValueTypes.COLOR;\n    for (let i = 0; i < args.length; i++) {\n      outputType = outputType & getValueType(args[i]);\n    }\n    return outputType;\n  },\n  toGlsl: function (context, args, expectedType) {\n    assertArgsMinCount(args, 2);\n    let outputType = expectedType;\n    for (let i = 0; i < args.length; i++) {\n      outputType = outputType & getValueType(args[i]);\n    }\n    assertOfType(\n      args,\n      outputType,\n      ValueTypes.NUMBER | ValueTypes.COLOR,\n      'output'\n    );\n    return `(${args\n      .map((arg) => expressionToGlsl(context, arg, outputType))\n      .join(' * ')})`;\n  },\n};\n\nOperators['/'] = {\n  getReturnType: function () {\n    return ValueTypes.NUMBER;\n  },\n  toGlsl: function (context, args) {\n    assertArgsCount(args, 2);\n    assertNumbers(args);\n    return `(${expressionToGlsl(context, args[0])} / ${expressionToGlsl(\n      context,\n      args[1]\n    )})`;\n  },\n};\n\nOperators['+'] = {\n  getReturnType: function () {\n    return ValueTypes.NUMBER;\n  },\n  toGlsl: function (context, args) {\n    assertArgsMinCount(args, 2);\n    assertNumbers(args);\n    return `(${args.map((arg) => expressionToGlsl(context, arg)).join(' + ')})`;\n  },\n};\n\nOperators['-'] = {\n  getReturnType: function () {\n    return ValueTypes.NUMBER;\n  },\n  toGlsl: function (context, args) {\n    assertArgsCount(args, 2);\n    assertNumbers(args);\n    return `(${expressionToGlsl(context, args[0])} - ${expressionToGlsl(\n      context,\n      args[1]\n    )})`;\n  },\n};\n\nOperators['clamp'] = {\n  getReturnType: function () {\n    return ValueTypes.NUMBER;\n  },\n  toGlsl: function (context, args) {\n    assertArgsCount(args, 3);\n    assertNumbers(args);\n    const min = expressionToGlsl(context, args[1]);\n    const max = expressionToGlsl(context, args[2]);\n    return `clamp(${expressionToGlsl(context, args[0])}, ${min}, ${max})`;\n  },\n};\n\nOperators['%'] = {\n  getReturnType: function () {\n    return ValueTypes.NUMBER;\n  },\n  toGlsl: function (context, args) {\n    assertArgsCount(args, 2);\n    assertNumbers(args);\n    return `mod(${expressionToGlsl(context, args[0])}, ${expressionToGlsl(\n      context,\n      args[1]\n    )})`;\n  },\n};\n\nOperators['^'] = {\n  getReturnType: function () {\n    return ValueTypes.NUMBER;\n  },\n  toGlsl: function (context, args) {\n    assertArgsCount(args, 2);\n    assertNumbers(args);\n    return `pow(${expressionToGlsl(context, args[0])}, ${expressionToGlsl(\n      context,\n      args[1]\n    )})`;\n  },\n};\n\nOperators['abs'] = {\n  getReturnType: function () {\n    return ValueTypes.NUMBER;\n  },\n  toGlsl: function (context, args) {\n    assertArgsCount(args, 1);\n    assertNumbers(args);\n    return `abs(${expressionToGlsl(context, args[0])})`;\n  },\n};\n\nOperators['floor'] = {\n  getReturnType: function () {\n    return ValueTypes.NUMBER;\n  },\n  toGlsl: function (context, args) {\n    assertArgsCount(args, 1);\n    assertNumbers(args);\n    return `floor(${expressionToGlsl(context, args[0])})`;\n  },\n};\n\nOperators['round'] = {\n  getReturnType: function () {\n    return ValueTypes.NUMBER;\n  },\n  toGlsl: function (context, args) {\n    assertArgsCount(args, 1);\n    assertNumbers(args);\n    return `floor(${expressionToGlsl(context, args[0])} + 0.5)`;\n  },\n};\n\nOperators['ceil'] = {\n  getReturnType: function () {\n    return ValueTypes.NUMBER;\n  },\n  toGlsl: function (context, args) {\n    assertArgsCount(args, 1);\n    assertNumbers(args);\n    return `ceil(${expressionToGlsl(context, args[0])})`;\n  },\n};\n\nOperators['sin'] = {\n  getReturnType: function () {\n    return ValueTypes.NUMBER;\n  },\n  toGlsl: function (context, args) {\n    assertArgsCount(args, 1);\n    assertNumbers(args);\n    return `sin(${expressionToGlsl(context, args[0])})`;\n  },\n};\n\nOperators['cos'] = {\n  getReturnType: function () {\n    return ValueTypes.NUMBER;\n  },\n  toGlsl: function (context, args) {\n    assertArgsCount(args, 1);\n    assertNumbers(args);\n    return `cos(${expressionToGlsl(context, args[0])})`;\n  },\n};\n\nOperators['atan'] = {\n  getReturnType: function () {\n    return ValueTypes.NUMBER;\n  },\n  toGlsl: function (context, args) {\n    assertArgsMinCount(args, 1);\n    assertArgsMaxCount(args, 2);\n    assertNumbers(args);\n    return args.length === 2\n      ? `atan(${expressionToGlsl(context, args[0])}, ${expressionToGlsl(\n          context,\n          args[1]\n        )})`\n      : `atan(${expressionToGlsl(context, args[0])})`;\n  },\n};\n\nOperators['sqrt'] = {\n  getReturnType: function () {\n    return ValueTypes.NUMBER;\n  },\n  toGlsl: function (context, args) {\n    assertArgsCount(args, 1);\n    assertNumbers(args);\n    return `sqrt(${expressionToGlsl(context, args[0])})`;\n  },\n};\n\nOperators['>'] = {\n  getReturnType: function () {\n    return ValueTypes.BOOLEAN;\n  },\n  toGlsl: function (context, args) {\n    assertArgsCount(args, 2);\n    assertNumbers(args);\n    return `(${expressionToGlsl(context, args[0])} > ${expressionToGlsl(\n      context,\n      args[1]\n    )})`;\n  },\n};\n\nOperators['>='] = {\n  getReturnType: function () {\n    return ValueTypes.BOOLEAN;\n  },\n  toGlsl: function (context, args) {\n    assertArgsCount(args, 2);\n    assertNumbers(args);\n    return `(${expressionToGlsl(context, args[0])} >= ${expressionToGlsl(\n      context,\n      args[1]\n    )})`;\n  },\n};\n\nOperators['<'] = {\n  getReturnType: function () {\n    return ValueTypes.BOOLEAN;\n  },\n  toGlsl: function (context, args) {\n    assertArgsCount(args, 2);\n    assertNumbers(args);\n    return `(${expressionToGlsl(context, args[0])} < ${expressionToGlsl(\n      context,\n      args[1]\n    )})`;\n  },\n};\n\nOperators['<='] = {\n  getReturnType: function () {\n    return ValueTypes.BOOLEAN;\n  },\n  toGlsl: function (context, args) {\n    assertArgsCount(args, 2);\n    assertNumbers(args);\n    return `(${expressionToGlsl(context, args[0])} <= ${expressionToGlsl(\n      context,\n      args[1]\n    )})`;\n  },\n};\n\nfunction getEqualOperator(operator) {\n  return {\n    getReturnType: function () {\n      return ValueTypes.BOOLEAN;\n    },\n    toGlsl: function (context, args) {\n      assertArgsCount(args, 2);\n\n      // find common type\n      let type = ValueTypes.ANY;\n      for (let i = 0; i < args.length; i++) {\n        type &= getValueType(args[i]);\n      }\n      if (type === ValueTypes.NONE) {\n        throw new Error(\n          `All arguments should be of compatible type, got ${JSON.stringify(\n            args\n          )} instead`\n        );\n      }\n\n      // Since it's not possible to have color types here, we can leave it out\n      // This fixes issues in case the value type is ambiguously detected as a color (e.g. the string 'red')\n      type &= ~ValueTypes.COLOR;\n\n      return `(${expressionToGlsl(\n        context,\n        args[0],\n        type\n      )} ${operator} ${expressionToGlsl(context, args[1], type)})`;\n    },\n  };\n}\n\nOperators['=='] = getEqualOperator('==');\n\nOperators['!='] = getEqualOperator('!=');\n\nOperators['!'] = {\n  getReturnType: function () {\n    return ValueTypes.BOOLEAN;\n  },\n  toGlsl: function (context, args) {\n    assertArgsCount(args, 1);\n    assertBoolean(args[0]);\n    return `(!${expressionToGlsl(context, args[0], ValueTypes.BOOLEAN)})`;\n  },\n};\n\nfunction getDecisionOperator(operator) {\n  return {\n    getReturnType: function () {\n      return ValueTypes.BOOLEAN;\n    },\n    toGlsl: function (context, args) {\n      assertArgsMinCount(args, 2);\n      for (let i = 0; i < args.length; i++) {\n        assertBoolean(args[i]);\n      }\n      let result = args\n        .map((arg) => expressionToGlsl(context, arg, ValueTypes.BOOLEAN))\n        .join(` ${operator} `);\n      result = `(${result})`;\n      return result;\n    },\n  };\n}\n\nOperators['all'] = getDecisionOperator('&&');\n\nOperators['any'] = getDecisionOperator('||');\n\nOperators['between'] = {\n  getReturnType: function () {\n    return ValueTypes.BOOLEAN;\n  },\n  toGlsl: function (context, args) {\n    assertArgsCount(args, 3);\n    assertNumbers(args);\n    const min = expressionToGlsl(context, args[1]);\n    const max = expressionToGlsl(context, args[2]);\n    const value = expressionToGlsl(context, args[0]);\n    return `(${value} >= ${min} && ${value} <= ${max})`;\n  },\n};\n\nOperators['array'] = {\n  getReturnType: function () {\n    return ValueTypes.NUMBER_ARRAY;\n  },\n  toGlsl: function (context, args) {\n    assertArgsMinCount(args, 2);\n    assertArgsMaxCount(args, 4);\n    assertNumbers(args);\n    const parsedArgs = args.map(function (val) {\n      return expressionToGlsl(context, val);\n    });\n    return `vec${args.length}(${parsedArgs.join(', ')})`;\n  },\n};\n\nOperators['color'] = {\n  getReturnType: function () {\n    return ValueTypes.COLOR;\n  },\n  toGlsl: function (context, args) {\n    assertArgsMinCount(args, 3);\n    assertArgsMaxCount(args, 4);\n    assertNumbers(args);\n    const parsedArgs = args\n      .slice(0, 3)\n      .map((val) => `${expressionToGlsl(context, val)} / 255.0`);\n    if (args.length === 3) {\n      return `vec4(${parsedArgs.join(', ')}, 1.0)`;\n    }\n    const alpha = expressionToGlsl(context, args[3]);\n    return `(${alpha} * vec4(${parsedArgs.join(', ')}, 1.0))`;\n  },\n};\n\nOperators['interpolate'] = {\n  getReturnType: function (args) {\n    let type = ValueTypes.COLOR | ValueTypes.NUMBER;\n    for (let i = 3; i < args.length; i += 2) {\n      type = type & getValueType(args[i]);\n    }\n    return type;\n  },\n  toGlsl: function (context, args, expectedType) {\n    assertArgsEven(args);\n    assertArgsMinCount(args, 6);\n\n    // validate interpolation type\n    const type = args[0];\n    let interpolation;\n    switch (type[0]) {\n      case 'linear':\n        interpolation = 1;\n        break;\n      case 'exponential':\n        interpolation = type[1];\n        break;\n      default:\n        interpolation = null;\n    }\n    if (!interpolation) {\n      throw new Error(\n        `Invalid interpolation type for \"interpolate\" operator, received: ${JSON.stringify(\n          type\n        )}`\n      );\n    }\n\n    // compute input/output types\n    const inputType = ValueTypes.NUMBER;\n    const outputType =\n      Operators['interpolate'].getReturnType(args) & expectedType;\n    assertSingleType(['interpolate', ...args], outputType, 'output');\n\n    const input = expressionToGlsl(context, args[1], inputType);\n    const exponent = numberToGlsl(interpolation);\n\n    let result = '';\n    for (let i = 2; i < args.length - 2; i += 2) {\n      const stop1 = expressionToGlsl(context, args[i], inputType);\n      const output1 =\n        result || expressionToGlsl(context, args[i + 1], outputType);\n      const stop2 = expressionToGlsl(context, args[i + 2], inputType);\n      const output2 = expressionToGlsl(context, args[i + 3], outputType);\n      let ratio;\n      if (interpolation === 1) {\n        ratio = `(${input} - ${stop1}) / (${stop2} - ${stop1})`;\n      } else {\n        ratio = `(pow(${exponent}, (${input} - ${stop1})) - 1.0) / (pow(${exponent}, (${stop2} - ${stop1})) - 1.0)`;\n      }\n      result = `mix(${output1}, ${output2}, clamp(${ratio}, 0.0, 1.0))`;\n    }\n    return result;\n  },\n};\n\nOperators['match'] = {\n  getReturnType: function (args) {\n    let type = ValueTypes.ANY;\n    for (let i = 2; i < args.length; i += 2) {\n      type = type & getValueType(args[i]);\n    }\n    type = type & getValueType(args[args.length - 1]);\n    return type;\n  },\n  toGlsl: function (context, args, expectedType) {\n    assertArgsEven(args);\n    assertArgsMinCount(args, 4);\n\n    let inputType = getValueType(args[0]);\n    for (let i = 1; i < args.length - 1; i += 2) {\n      inputType = inputType & getValueType(args[i]);\n    }\n    assertOfType(\n      ['match', ...args],\n      inputType,\n      ValueTypes.STRING | ValueTypes.NUMBER | ValueTypes.BOOLEAN,\n      'input'\n    );\n    inputType =\n      (ValueTypes.STRING | ValueTypes.NUMBER | ValueTypes.BOOLEAN) & inputType;\n\n    const outputType = Operators['match'].getReturnType(args) & expectedType;\n    assertSingleType(['match', ...args], outputType, 'output');\n\n    const input = expressionToGlsl(context, args[0], inputType);\n    const fallback = expressionToGlsl(\n      context,\n      args[args.length - 1],\n      outputType\n    );\n    let result = null;\n    for (let i = args.length - 3; i >= 1; i -= 2) {\n      const match = expressionToGlsl(context, args[i], inputType);\n      const output = expressionToGlsl(context, args[i + 1], outputType);\n      result = `(${input} == ${match} ? ${output} : ${result || fallback})`;\n    }\n    return result;\n  },\n};\n\nOperators['case'] = {\n  getReturnType: function (args) {\n    let type = ValueTypes.ANY;\n    for (let i = 1; i < args.length; i += 2) {\n      type = type & getValueType(args[i]);\n    }\n    type = type & getValueType(args[args.length - 1]);\n    return type;\n  },\n  toGlsl: function (context, args, expectedType) {\n    assertArgsOdd(args);\n    assertArgsMinCount(args, 3);\n\n    const outputType = Operators['case'].getReturnType(args) & expectedType;\n    assertSingleType(['case', ...args], outputType, 'output');\n    for (let i = 0; i < args.length - 1; i += 2) {\n      assertBoolean(args[i]);\n    }\n\n    const fallback = expressionToGlsl(\n      context,\n      args[args.length - 1],\n      outputType\n    );\n    let result = null;\n    for (let i = args.length - 3; i >= 0; i -= 2) {\n      const condition = expressionToGlsl(context, args[i], ValueTypes.BOOLEAN);\n      const output = expressionToGlsl(context, args[i + 1], outputType);\n      result = `(${condition} ? ${output} : ${result || fallback})`;\n    }\n    return result;\n  },\n};\n\nOperators['in'] = {\n  getReturnType: function (args) {\n    return ValueTypes.BOOLEAN;\n  },\n  toGlsl: function (context, args) {\n    assertArgsCount(args, 2);\n    const needle = args[0];\n    let haystack = args[1];\n    if (!Array.isArray(haystack)) {\n      throw new Error(\n        `The \"in\" operator expects an array literal as its second argument.`\n      );\n    }\n    if (typeof haystack[0] === 'string') {\n      if (haystack[0] !== 'literal') {\n        throw new Error(\n          `For the \"in\" operator, a string array should be wrapped in a \"literal\" operator to disambiguate from expressions.`\n        );\n      }\n      if (!Array.isArray(haystack[1])) {\n        throw new Error(\n          `The \"in\" operator was provided a literal value which was not an array as second argument.`\n        );\n      }\n      haystack = haystack[1];\n    }\n\n    let inputType = getValueType(needle);\n    for (let i = 0; i < haystack.length - 1; i += 1) {\n      inputType = inputType & getValueType(haystack[i]);\n    }\n    assertOfType(\n      ['match', ...args],\n      inputType,\n      ValueTypes.STRING | ValueTypes.NUMBER | ValueTypes.BOOLEAN,\n      'input'\n    );\n    inputType =\n      (ValueTypes.STRING | ValueTypes.NUMBER | ValueTypes.BOOLEAN) & inputType;\n\n    const funcName = computeOperatorFunctionName('in', context);\n    const tests = [];\n    for (let i = 0; i < haystack.length; i += 1) {\n      tests.push(\n        `  if (inputValue == ${expressionToGlsl(\n          context,\n          haystack[i],\n          inputType\n        )}) { return true; }`\n      );\n    }\n    context.functions[funcName] = `bool ${funcName}(float inputValue) {\n${tests.join('\\n')}\n  return false;\n}`;\n    return `${funcName}(${expressionToGlsl(context, needle, inputType)})`;\n  },\n};\n"],"mappings":";;;;AAAA;AACA;AACA;AACA;;AAEA,OAAOA,cAAc,MAAM,4BAA4B;AACvD,SAAQC,QAAQ,QAAO,gCAAgC;AACvD,SAAQC,OAAO,EAAEC,UAAU,EAAEC,aAAa,QAAO,aAAa;;AAE9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO,MAAMC,UAAU,GAAG;EACxBC,MAAM,EAAE,OAAO;EACfC,MAAM,EAAE,OAAO;EACfC,KAAK,EAAE,OAAO;EACdC,OAAO,EAAE,OAAO;EAChBC,YAAY,EAAE,OAAO;EACrBC,GAAG,EAAE,OAAO;EACZC,IAAI,EAAE;AACR,CAAC;;AAED;AACA;AACA;AACA;AACA,SAASC,eAAeA,CAACC,QAAQ,EAAE;EACjC,QAAQA,QAAQ;IACd,KAAK,QAAQ;MACX,OAAOT,UAAU,CAACE,MAAM;IAC1B,KAAK,OAAO;MACV,OAAOF,UAAU,CAACG,KAAK;IACzB,KAAK,QAAQ;MACX,OAAOH,UAAU,CAACC,MAAM;IAC1B,KAAK,SAAS;MACZ,OAAOD,UAAU,CAACI,OAAO;IAC3B,KAAK,UAAU;MACb,OAAOJ,UAAU,CAACK,YAAY;IAChC;MACE,MAAM,IAAIK,KAAK,CAAE,2BAA0BD,QAAS,EAAC,CAAC;EAC1D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"},"metadata":{},"sourceType":"module","externalDependencies":[]}