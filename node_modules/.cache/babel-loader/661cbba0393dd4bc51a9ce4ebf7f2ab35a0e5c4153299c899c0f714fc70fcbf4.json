{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\n/**\n * @module ol/geom/flat/interiorpoint\n */\nimport { ascending } from '../../array.js';\nimport { linearRingsContainsXY } from './contains.js';\n\n/**\n * Calculates a point that is likely to lie in the interior of the linear rings.\n * Inspired by JTS's com.vividsolutions.jts.geom.Geometry#getInteriorPoint.\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array<number>} ends Ends.\n * @param {number} stride Stride.\n * @param {Array<number>} flatCenters Flat centers.\n * @param {number} flatCentersOffset Flat center offset.\n * @param {Array<number>} [dest] Destination.\n * @return {Array<number>} Destination point as XYM coordinate, where M is the\n * length of the horizontal intersection that the point belongs to.\n */\nexport function getInteriorPointOfArray(flatCoordinates, offset, ends, stride, flatCenters, flatCentersOffset, dest) {\n  let i, ii, x, x1, x2, y1, y2;\n  const y = flatCenters[flatCentersOffset + 1];\n  /** @type {Array<number>} */\n  const intersections = [];\n  // Calculate intersections with the horizontal line\n  for (let r = 0, rr = ends.length; r < rr; ++r) {\n    const end = ends[r];\n    x1 = flatCoordinates[end - stride];\n    y1 = flatCoordinates[end - stride + 1];\n    for (i = offset; i < end; i += stride) {\n      x2 = flatCoordinates[i];\n      y2 = flatCoordinates[i + 1];\n      if (y <= y1 && y2 <= y || y1 <= y && y <= y2) {\n        x = (y - y1) / (y2 - y1) * (x2 - x1) + x1;\n        intersections.push(x);\n      }\n      x1 = x2;\n      y1 = y2;\n    }\n  }\n  // Find the longest segment of the horizontal line that has its center point\n  // inside the linear ring.\n  let pointX = NaN;\n  let maxSegmentLength = -Infinity;\n  intersections.sort(ascending);\n  x1 = intersections[0];\n  for (i = 1, ii = intersections.length; i < ii; ++i) {\n    x2 = intersections[i];\n    const segmentLength = Math.abs(x2 - x1);\n    if (segmentLength > maxSegmentLength) {\n      x = (x1 + x2) / 2;\n      if (linearRingsContainsXY(flatCoordinates, offset, ends, stride, x, y)) {\n        pointX = x;\n        maxSegmentLength = segmentLength;\n      }\n    }\n    x1 = x2;\n  }\n  if (isNaN(pointX)) {\n    // There is no horizontal line that has its center point inside the linear\n    // ring.  Use the center of the the linear ring's extent.\n    pointX = flatCenters[flatCentersOffset];\n  }\n  if (dest) {\n    dest.push(pointX, y, maxSegmentLength);\n    return dest;\n  }\n  return [pointX, y, maxSegmentLength];\n}\n\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array<Array<number>>} endss Endss.\n * @param {number} stride Stride.\n * @param {Array<number>} flatCenters Flat centers.\n * @return {Array<number>} Interior points as XYM coordinates, where M is the\n * length of the horizontal intersection that the point belongs to.\n */\nexport function getInteriorPointsOfMultiArray(flatCoordinates, offset, endss, stride, flatCenters) {\n  let interiorPoints = [];\n  for (let i = 0, ii = endss.length; i < ii; ++i) {\n    const ends = endss[i];\n    interiorPoints = getInteriorPointOfArray(flatCoordinates, offset, ends, stride, flatCenters, 2 * i, interiorPoints);\n    offset = ends[ends.length - 1];\n  }\n  return interiorPoints;\n}","map":{"version":3,"names":["ascending","linearRingsContainsXY","getInteriorPointOfArray","flatCoordinates","offset","ends","stride","flatCenters","flatCentersOffset","dest","i","ii","x","x1","x2","y1","y2","y","intersections","r","rr","length","end","push","pointX","NaN","maxSegmentLength","Infinity","sort","segmentLength","Math","abs","isNaN","getInteriorPointsOfMultiArray","endss","interiorPoints"],"sources":["E:/Desktop/SceneryPlatform_v3.0_LTS/node_modules/ol/geom/flat/interiorpoint.js"],"sourcesContent":["/**\n * @module ol/geom/flat/interiorpoint\n */\nimport {ascending} from '../../array.js';\nimport {linearRingsContainsXY} from './contains.js';\n\n/**\n * Calculates a point that is likely to lie in the interior of the linear rings.\n * Inspired by JTS's com.vividsolutions.jts.geom.Geometry#getInteriorPoint.\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array<number>} ends Ends.\n * @param {number} stride Stride.\n * @param {Array<number>} flatCenters Flat centers.\n * @param {number} flatCentersOffset Flat center offset.\n * @param {Array<number>} [dest] Destination.\n * @return {Array<number>} Destination point as XYM coordinate, where M is the\n * length of the horizontal intersection that the point belongs to.\n */\nexport function getInteriorPointOfArray(\n  flatCoordinates,\n  offset,\n  ends,\n  stride,\n  flatCenters,\n  flatCentersOffset,\n  dest\n) {\n  let i, ii, x, x1, x2, y1, y2;\n  const y = flatCenters[flatCentersOffset + 1];\n  /** @type {Array<number>} */\n  const intersections = [];\n  // Calculate intersections with the horizontal line\n  for (let r = 0, rr = ends.length; r < rr; ++r) {\n    const end = ends[r];\n    x1 = flatCoordinates[end - stride];\n    y1 = flatCoordinates[end - stride + 1];\n    for (i = offset; i < end; i += stride) {\n      x2 = flatCoordinates[i];\n      y2 = flatCoordinates[i + 1];\n      if ((y <= y1 && y2 <= y) || (y1 <= y && y <= y2)) {\n        x = ((y - y1) / (y2 - y1)) * (x2 - x1) + x1;\n        intersections.push(x);\n      }\n      x1 = x2;\n      y1 = y2;\n    }\n  }\n  // Find the longest segment of the horizontal line that has its center point\n  // inside the linear ring.\n  let pointX = NaN;\n  let maxSegmentLength = -Infinity;\n  intersections.sort(ascending);\n  x1 = intersections[0];\n  for (i = 1, ii = intersections.length; i < ii; ++i) {\n    x2 = intersections[i];\n    const segmentLength = Math.abs(x2 - x1);\n    if (segmentLength > maxSegmentLength) {\n      x = (x1 + x2) / 2;\n      if (linearRingsContainsXY(flatCoordinates, offset, ends, stride, x, y)) {\n        pointX = x;\n        maxSegmentLength = segmentLength;\n      }\n    }\n    x1 = x2;\n  }\n  if (isNaN(pointX)) {\n    // There is no horizontal line that has its center point inside the linear\n    // ring.  Use the center of the the linear ring's extent.\n    pointX = flatCenters[flatCentersOffset];\n  }\n  if (dest) {\n    dest.push(pointX, y, maxSegmentLength);\n    return dest;\n  }\n  return [pointX, y, maxSegmentLength];\n}\n\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array<Array<number>>} endss Endss.\n * @param {number} stride Stride.\n * @param {Array<number>} flatCenters Flat centers.\n * @return {Array<number>} Interior points as XYM coordinates, where M is the\n * length of the horizontal intersection that the point belongs to.\n */\nexport function getInteriorPointsOfMultiArray(\n  flatCoordinates,\n  offset,\n  endss,\n  stride,\n  flatCenters\n) {\n  let interiorPoints = [];\n  for (let i = 0, ii = endss.length; i < ii; ++i) {\n    const ends = endss[i];\n    interiorPoints = getInteriorPointOfArray(\n      flatCoordinates,\n      offset,\n      ends,\n      stride,\n      flatCenters,\n      2 * i,\n      interiorPoints\n    );\n    offset = ends[ends.length - 1];\n  }\n  return interiorPoints;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}