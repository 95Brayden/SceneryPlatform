{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\n/**\n * @module ol/render/canvas/LineStringBuilder\n */\nimport CanvasBuilder from './Builder.js';\nimport CanvasInstruction, { beginPathInstruction, strokeInstruction } from './Instruction.js';\nimport { defaultLineDash, defaultLineDashOffset } from '../canvas.js';\nclass CanvasLineStringBuilder extends CanvasBuilder {\n  /**\n   * @param {number} tolerance Tolerance.\n   * @param {import(\"../../extent.js\").Extent} maxExtent Maximum extent.\n   * @param {number} resolution Resolution.\n   * @param {number} pixelRatio Pixel ratio.\n   */\n  constructor(tolerance, maxExtent, resolution, pixelRatio) {\n    super(tolerance, maxExtent, resolution, pixelRatio);\n  }\n\n  /**\n   * @param {Array<number>} flatCoordinates Flat coordinates.\n   * @param {number} offset Offset.\n   * @param {number} end End.\n   * @param {number} stride Stride.\n   * @private\n   * @return {number} end.\n   */\n  drawFlatCoordinates_(flatCoordinates, offset, end, stride) {\n    const myBegin = this.coordinates.length;\n    const myEnd = this.appendFlatLineCoordinates(flatCoordinates, offset, end, stride, false, false);\n    const moveToLineToInstruction = [CanvasInstruction.MOVE_TO_LINE_TO, myBegin, myEnd];\n    this.instructions.push(moveToLineToInstruction);\n    this.hitDetectionInstructions.push(moveToLineToInstruction);\n    return end;\n  }\n\n  /**\n   * @param {import(\"../../geom/LineString.js\").default|import(\"../Feature.js\").default} lineStringGeometry Line string geometry.\n   * @param {import(\"../../Feature.js\").FeatureLike} feature Feature.\n   */\n  drawLineString(lineStringGeometry, feature) {\n    const state = this.state;\n    const strokeStyle = state.strokeStyle;\n    const lineWidth = state.lineWidth;\n    if (strokeStyle === undefined || lineWidth === undefined) {\n      return;\n    }\n    this.updateStrokeStyle(state, this.applyStroke);\n    this.beginGeometry(lineStringGeometry, feature);\n    this.hitDetectionInstructions.push([CanvasInstruction.SET_STROKE_STYLE, state.strokeStyle, state.lineWidth, state.lineCap, state.lineJoin, state.miterLimit, defaultLineDash, defaultLineDashOffset], beginPathInstruction);\n    const flatCoordinates = lineStringGeometry.getFlatCoordinates();\n    const stride = lineStringGeometry.getStride();\n    this.drawFlatCoordinates_(flatCoordinates, 0, flatCoordinates.length, stride);\n    this.hitDetectionInstructions.push(strokeInstruction);\n    this.endGeometry(feature);\n  }\n\n  /**\n   * @param {import(\"../../geom/MultiLineString.js\").default|import(\"../Feature.js\").default} multiLineStringGeometry MultiLineString geometry.\n   * @param {import(\"../../Feature.js\").FeatureLike} feature Feature.\n   */\n  drawMultiLineString(multiLineStringGeometry, feature) {\n    const state = this.state;\n    const strokeStyle = state.strokeStyle;\n    const lineWidth = state.lineWidth;\n    if (strokeStyle === undefined || lineWidth === undefined) {\n      return;\n    }\n    this.updateStrokeStyle(state, this.applyStroke);\n    this.beginGeometry(multiLineStringGeometry, feature);\n    this.hitDetectionInstructions.push([CanvasInstruction.SET_STROKE_STYLE, state.strokeStyle, state.lineWidth, state.lineCap, state.lineJoin, state.miterLimit, defaultLineDash, defaultLineDashOffset], beginPathInstruction);\n    const ends = multiLineStringGeometry.getEnds();\n    const flatCoordinates = multiLineStringGeometry.getFlatCoordinates();\n    const stride = multiLineStringGeometry.getStride();\n    let offset = 0;\n    for (let i = 0, ii = ends.length; i < ii; ++i) {\n      offset = this.drawFlatCoordinates_(flatCoordinates, offset, /** @type {number} */ends[i], stride);\n    }\n    this.hitDetectionInstructions.push(strokeInstruction);\n    this.endGeometry(feature);\n  }\n\n  /**\n   * @return {import(\"../canvas.js\").SerializableInstructions} the serializable instructions.\n   */\n  finish() {\n    const state = this.state;\n    if (state.lastStroke != undefined && state.lastStroke != this.coordinates.length) {\n      this.instructions.push(strokeInstruction);\n    }\n    this.reverseHitDetectionInstructions();\n    this.state = null;\n    return super.finish();\n  }\n\n  /**\n   * @param {import(\"../canvas.js\").FillStrokeState} state State.\n   */\n  applyStroke(state) {\n    if (state.lastStroke != undefined && state.lastStroke != this.coordinates.length) {\n      this.instructions.push(strokeInstruction);\n      state.lastStroke = this.coordinates.length;\n    }\n    state.lastStroke = 0;\n    super.applyStroke(state);\n    this.instructions.push(beginPathInstruction);\n  }\n}\nexport default CanvasLineStringBuilder;","map":{"version":3,"names":["CanvasBuilder","CanvasInstruction","beginPathInstruction","strokeInstruction","defaultLineDash","defaultLineDashOffset","CanvasLineStringBuilder","constructor","tolerance","maxExtent","resolution","pixelRatio","drawFlatCoordinates_","flatCoordinates","offset","end","stride","myBegin","coordinates","length","myEnd","appendFlatLineCoordinates","moveToLineToInstruction","MOVE_TO_LINE_TO","instructions","push","hitDetectionInstructions","drawLineString","lineStringGeometry","feature","state","strokeStyle","lineWidth","undefined","updateStrokeStyle","applyStroke","beginGeometry","SET_STROKE_STYLE","lineCap","lineJoin","miterLimit","getFlatCoordinates","getStride","endGeometry","drawMultiLineString","multiLineStringGeometry","ends","getEnds","i","ii","finish","lastStroke","reverseHitDetectionInstructions"],"sources":["E:/Desktop/scenerymonitor/node_modules/ol/render/canvas/LineStringBuilder.js"],"sourcesContent":["/**\n * @module ol/render/canvas/LineStringBuilder\n */\nimport CanvasBuilder from './Builder.js';\nimport CanvasInstruction, {\n  beginPathInstruction,\n  strokeInstruction,\n} from './Instruction.js';\nimport {defaultLineDash, defaultLineDashOffset} from '../canvas.js';\n\nclass CanvasLineStringBuilder extends CanvasBuilder {\n  /**\n   * @param {number} tolerance Tolerance.\n   * @param {import(\"../../extent.js\").Extent} maxExtent Maximum extent.\n   * @param {number} resolution Resolution.\n   * @param {number} pixelRatio Pixel ratio.\n   */\n  constructor(tolerance, maxExtent, resolution, pixelRatio) {\n    super(tolerance, maxExtent, resolution, pixelRatio);\n  }\n\n  /**\n   * @param {Array<number>} flatCoordinates Flat coordinates.\n   * @param {number} offset Offset.\n   * @param {number} end End.\n   * @param {number} stride Stride.\n   * @private\n   * @return {number} end.\n   */\n  drawFlatCoordinates_(flatCoordinates, offset, end, stride) {\n    const myBegin = this.coordinates.length;\n    const myEnd = this.appendFlatLineCoordinates(\n      flatCoordinates,\n      offset,\n      end,\n      stride,\n      false,\n      false\n    );\n    const moveToLineToInstruction = [\n      CanvasInstruction.MOVE_TO_LINE_TO,\n      myBegin,\n      myEnd,\n    ];\n    this.instructions.push(moveToLineToInstruction);\n    this.hitDetectionInstructions.push(moveToLineToInstruction);\n    return end;\n  }\n\n  /**\n   * @param {import(\"../../geom/LineString.js\").default|import(\"../Feature.js\").default} lineStringGeometry Line string geometry.\n   * @param {import(\"../../Feature.js\").FeatureLike} feature Feature.\n   */\n  drawLineString(lineStringGeometry, feature) {\n    const state = this.state;\n    const strokeStyle = state.strokeStyle;\n    const lineWidth = state.lineWidth;\n    if (strokeStyle === undefined || lineWidth === undefined) {\n      return;\n    }\n    this.updateStrokeStyle(state, this.applyStroke);\n    this.beginGeometry(lineStringGeometry, feature);\n    this.hitDetectionInstructions.push(\n      [\n        CanvasInstruction.SET_STROKE_STYLE,\n        state.strokeStyle,\n        state.lineWidth,\n        state.lineCap,\n        state.lineJoin,\n        state.miterLimit,\n        defaultLineDash,\n        defaultLineDashOffset,\n      ],\n      beginPathInstruction\n    );\n    const flatCoordinates = lineStringGeometry.getFlatCoordinates();\n    const stride = lineStringGeometry.getStride();\n    this.drawFlatCoordinates_(\n      flatCoordinates,\n      0,\n      flatCoordinates.length,\n      stride\n    );\n    this.hitDetectionInstructions.push(strokeInstruction);\n    this.endGeometry(feature);\n  }\n\n  /**\n   * @param {import(\"../../geom/MultiLineString.js\").default|import(\"../Feature.js\").default} multiLineStringGeometry MultiLineString geometry.\n   * @param {import(\"../../Feature.js\").FeatureLike} feature Feature.\n   */\n  drawMultiLineString(multiLineStringGeometry, feature) {\n    const state = this.state;\n    const strokeStyle = state.strokeStyle;\n    const lineWidth = state.lineWidth;\n    if (strokeStyle === undefined || lineWidth === undefined) {\n      return;\n    }\n    this.updateStrokeStyle(state, this.applyStroke);\n    this.beginGeometry(multiLineStringGeometry, feature);\n    this.hitDetectionInstructions.push(\n      [\n        CanvasInstruction.SET_STROKE_STYLE,\n        state.strokeStyle,\n        state.lineWidth,\n        state.lineCap,\n        state.lineJoin,\n        state.miterLimit,\n        defaultLineDash,\n        defaultLineDashOffset,\n      ],\n      beginPathInstruction\n    );\n    const ends = multiLineStringGeometry.getEnds();\n    const flatCoordinates = multiLineStringGeometry.getFlatCoordinates();\n    const stride = multiLineStringGeometry.getStride();\n    let offset = 0;\n    for (let i = 0, ii = ends.length; i < ii; ++i) {\n      offset = this.drawFlatCoordinates_(\n        flatCoordinates,\n        offset,\n        /** @type {number} */ (ends[i]),\n        stride\n      );\n    }\n    this.hitDetectionInstructions.push(strokeInstruction);\n    this.endGeometry(feature);\n  }\n\n  /**\n   * @return {import(\"../canvas.js\").SerializableInstructions} the serializable instructions.\n   */\n  finish() {\n    const state = this.state;\n    if (\n      state.lastStroke != undefined &&\n      state.lastStroke != this.coordinates.length\n    ) {\n      this.instructions.push(strokeInstruction);\n    }\n    this.reverseHitDetectionInstructions();\n    this.state = null;\n    return super.finish();\n  }\n\n  /**\n   * @param {import(\"../canvas.js\").FillStrokeState} state State.\n   */\n  applyStroke(state) {\n    if (\n      state.lastStroke != undefined &&\n      state.lastStroke != this.coordinates.length\n    ) {\n      this.instructions.push(strokeInstruction);\n      state.lastStroke = this.coordinates.length;\n    }\n    state.lastStroke = 0;\n    super.applyStroke(state);\n    this.instructions.push(beginPathInstruction);\n  }\n}\n\nexport default CanvasLineStringBuilder;\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}