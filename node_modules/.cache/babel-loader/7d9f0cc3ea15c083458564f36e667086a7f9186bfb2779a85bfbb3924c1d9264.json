{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\n/**\n * @module ol/source/ogcTileUtil\n */\n\nimport TileGrid from '../tilegrid/TileGrid.js';\nimport { getJSON, resolveUrl } from '../net.js';\nimport { get as getProjection } from '../proj.js';\nimport { getIntersection as intersectExtents } from '../extent.js';\n\n/**\n * See https://ogcapi.ogc.org/tiles/.\n */\n\n/**\n * @typedef {'map' | 'vector'} TileType\n */\n\n/**\n * @typedef {'topLeft' | 'bottomLeft'} CornerOfOrigin\n */\n\n/**\n * @typedef {Object} TileSet\n * @property {TileType} dataType Type of data represented in the tileset.\n * @property {string} [tileMatrixSetDefinition] Reference to a tile matrix set definition.\n * @property {TileMatrixSet} [tileMatrixSet] Tile matrix set definition.\n * @property {Array<TileMatrixSetLimit>} [tileMatrixSetLimits] Tile matrix set limits.\n * @property {Array<Link>} links Tileset links.\n */\n\n/**\n * @typedef {Object} Link\n * @property {string} rel The link rel attribute.\n * @property {string} href The link URL.\n * @property {string} type The link type.\n */\n\n/**\n * @typedef {Object} TileMatrixSetLimit\n * @property {string} tileMatrix The tile matrix id.\n * @property {number} minTileRow The minimum tile row.\n * @property {number} maxTileRow The maximum tile row.\n * @property {number} minTileCol The minimum tile column.\n * @property {number} maxTileCol The maximum tile column.\n */\n\n/**\n * @typedef {Object} TileMatrixSet\n * @property {string} id The tile matrix set identifier.\n * @property {string} crs The coordinate reference system.\n * @property {Array<TileMatrix>} tileMatrices Array of tile matrices.\n */\n\n/**\n * @typedef {Object} TileMatrix\n * @property {string} id The tile matrix identifier.\n * @property {number} cellSize The pixel resolution (map units per pixel).\n * @property {Array<number>} pointOfOrigin The map location of the matrix origin.\n * @property {CornerOfOrigin} [cornerOfOrigin='topLeft'] The corner of the matrix that represents the origin ('topLeft' or 'bottomLeft').\n * @property {number} matrixWidth The number of columns.\n * @property {number} matrixHeight The number of rows.\n * @property {number} tileWidth The pixel width of a tile.\n * @property {number} tileHeight The pixel height of a tile.\n */\n\n/**\n * @type {Object<string, boolean>}\n */\nconst knownMapMediaTypes = {\n  'image/png': true,\n  'image/jpeg': true,\n  'image/gif': true,\n  'image/webp': true\n};\n\n/**\n * @type {Object<string, boolean>}\n */\nconst knownVectorMediaTypes = {\n  'application/vnd.mapbox-vector-tile': true,\n  'application/geo+json': true\n};\n\n/**\n * @typedef {Object} TileSetInfo\n * @property {string} urlTemplate The tile URL template.\n * @property {import(\"../tilegrid/TileGrid.js\").default} grid The tile grid.\n * @property {import(\"../Tile.js\").UrlFunction} urlFunction The tile URL function.\n */\n\n/**\n * @typedef {Object} SourceInfo\n * @property {string} url The tile set URL.\n * @property {string} mediaType The preferred tile media type.\n * @property {Array<string>} [supportedMediaTypes] The supported media types.\n * @property {import(\"../proj/Projection.js\").default} projection The source projection.\n * @property {Object} [context] Optional context for constructing the URL.\n */\n\n/**\n * @param {Array<Link>} links Tileset links.\n * @param {string} [mediaType] The preferred media type.\n * @return {string} The tile URL template.\n */\nexport function getMapTileUrlTemplate(links, mediaType) {\n  let tileUrlTemplate;\n  let fallbackUrlTemplate;\n  for (let i = 0; i < links.length; ++i) {\n    const link = links[i];\n    if (link.rel === 'item') {\n      if (link.type === mediaType) {\n        tileUrlTemplate = link.href;\n        break;\n      }\n      if (knownMapMediaTypes[link.type]) {\n        fallbackUrlTemplate = link.href;\n      } else if (!fallbackUrlTemplate && link.type.startsWith('image/')) {\n        fallbackUrlTemplate = link.href;\n      }\n    }\n  }\n  if (!tileUrlTemplate) {\n    if (fallbackUrlTemplate) {\n      tileUrlTemplate = fallbackUrlTemplate;\n    } else {\n      throw new Error('Could not find \"item\" link');\n    }\n  }\n  return tileUrlTemplate;\n}\n\n/**\n * @param {Array<Link>} links Tileset links.\n * @param {string} [mediaType] The preferred media type.\n * @param {Array<string>} [supportedMediaTypes] The media types supported by the parser.\n * @return {string} The tile URL template.\n */\nexport function getVectorTileUrlTemplate(links, mediaType, supportedMediaTypes) {\n  let tileUrlTemplate;\n  let fallbackUrlTemplate;\n\n  /**\n   * Lookup of URL by media type.\n   * @type {Object<string, string>}\n   */\n  const hrefLookup = {};\n  for (let i = 0; i < links.length; ++i) {\n    const link = links[i];\n    hrefLookup[link.type] = link.href;\n    if (link.rel === 'item') {\n      if (link.type === mediaType) {\n        tileUrlTemplate = link.href;\n        break;\n      }\n      if (knownVectorMediaTypes[link.type]) {\n        fallbackUrlTemplate = link.href;\n      }\n    }\n  }\n  if (!tileUrlTemplate && supportedMediaTypes) {\n    for (let i = 0; i < supportedMediaTypes.length; ++i) {\n      const supportedMediaType = supportedMediaTypes[i];\n      if (hrefLookup[supportedMediaType]) {\n        tileUrlTemplate = hrefLookup[supportedMediaType];\n        break;\n      }\n    }\n  }\n  if (!tileUrlTemplate) {\n    if (fallbackUrlTemplate) {\n      tileUrlTemplate = fallbackUrlTemplate;\n    } else {\n      throw new Error('Could not find \"item\" link');\n    }\n  }\n  return tileUrlTemplate;\n}\n\n/**\n * @param {SourceInfo} sourceInfo The source info.\n * @param {TileMatrixSet} tileMatrixSet Tile matrix set.\n * @param {string} tileUrlTemplate Tile URL template.\n * @param {Array<TileMatrixSetLimit>} [tileMatrixSetLimits] Tile matrix set limits.\n * @return {TileSetInfo} Tile set info.\n */\nfunction parseTileMatrixSet(sourceInfo, tileMatrixSet, tileUrlTemplate, tileMatrixSetLimits) {\n  let projection = sourceInfo.projection;\n  if (!projection) {\n    projection = getProjection(tileMatrixSet.crs);\n    if (!projection) {\n      throw new Error(`Unsupported CRS: ${tileMatrixSet.crs}`);\n    }\n  }\n  const backwards = projection.getAxisOrientation().substr(0, 2) !== 'en';\n  const matrices = tileMatrixSet.tileMatrices;\n\n  /**\n   * @type {Object<string, TileMatrix>}\n   */\n  const matrixLookup = {};\n  for (let i = 0; i < matrices.length; ++i) {\n    const matrix = matrices[i];\n    matrixLookup[matrix.id] = matrix;\n  }\n\n  /**\n   * @type {Object<string, TileMatrixSetLimit>}\n   */\n  const limitLookup = {};\n\n  /**\n   * @type {Array<string>}\n   */\n  const matrixIds = [];\n  if (tileMatrixSetLimits) {\n    for (let i = 0; i < tileMatrixSetLimits.length; ++i) {\n      const limit = tileMatrixSetLimits[i];\n      const id = limit.tileMatrix;\n      matrixIds.push(id);\n      limitLookup[id] = limit;\n    }\n  } else {\n    for (let i = 0; i < matrices.length; ++i) {\n      const id = matrices[i].id;\n      matrixIds.push(id);\n    }\n  }\n  const length = matrixIds.length;\n  const origins = new Array(length);\n  const resolutions = new Array(length);\n  const sizes = new Array(length);\n  const tileSizes = new Array(length);\n  const extent = [-Infinity, -Infinity, Infinity, Infinity];\n  for (let i = 0; i < length; ++i) {\n    const id = matrixIds[i];\n    const matrix = matrixLookup[id];\n    const origin = matrix.pointOfOrigin;\n    if (backwards) {\n      origins[i] = [origin[1], origin[0]];\n    } else {\n      origins[i] = origin;\n    }\n    resolutions[i] = matrix.cellSize;\n    sizes[i] = [matrix.matrixWidth, matrix.matrixHeight];\n    tileSizes[i] = [matrix.tileWidth, matrix.tileHeight];\n    const limit = limitLookup[id];\n    if (limit) {\n      const tileMapWidth = matrix.cellSize * matrix.tileWidth;\n      const minX = origins[i][0] + limit.minTileCol * tileMapWidth;\n      const maxX = origins[i][0] + (limit.maxTileCol + 1) * tileMapWidth;\n      const tileMapHeight = matrix.cellSize * matrix.tileHeight;\n      const upsideDown = matrix.cornerOfOrigin === 'bottomLeft';\n      let minY;\n      let maxY;\n      if (upsideDown) {\n        minY = origins[i][1] + limit.minTileRow * tileMapHeight;\n        maxY = origins[i][1] + (limit.maxTileRow + 1) * tileMapHeight;\n      } else {\n        minY = origins[i][1] - (limit.maxTileRow + 1) * tileMapHeight;\n        maxY = origins[i][1] - limit.minTileRow * tileMapHeight;\n      }\n      intersectExtents(extent, [minX, minY, maxX, maxY], extent);\n    }\n  }\n  const tileGrid = new TileGrid({\n    origins: origins,\n    resolutions: resolutions,\n    sizes: sizes,\n    tileSizes: tileSizes,\n    extent: tileMatrixSetLimits ? extent : undefined\n  });\n  const context = sourceInfo.context;\n  const base = sourceInfo.url;\n  function tileUrlFunction(tileCoord, pixelRatio, projection) {\n    if (!tileCoord) {\n      return undefined;\n    }\n    const id = matrixIds[tileCoord[0]];\n    const matrix = matrixLookup[id];\n    const upsideDown = matrix.cornerOfOrigin === 'bottomLeft';\n    const localContext = {\n      tileMatrix: id,\n      tileCol: tileCoord[1],\n      tileRow: upsideDown ? -tileCoord[2] - 1 : tileCoord[2]\n    };\n    if (tileMatrixSetLimits) {\n      const limit = limitLookup[matrix.id];\n      if (localContext.tileCol < limit.minTileCol || localContext.tileCol > limit.maxTileCol || localContext.tileRow < limit.minTileRow || localContext.tileRow > limit.maxTileRow) {\n        return undefined;\n      }\n    }\n    Object.assign(localContext, context);\n    const url = tileUrlTemplate.replace(/\\{(\\w+?)\\}/g, function (m, p) {\n      return localContext[p];\n    });\n    return resolveUrl(base, url);\n  }\n  return {\n    grid: tileGrid,\n    urlTemplate: tileUrlTemplate,\n    urlFunction: tileUrlFunction\n  };\n}\n\n/**\n * @param {SourceInfo} sourceInfo The source info.\n * @param {TileSet} tileSet Tile set.\n * @return {TileSetInfo|Promise<TileSetInfo>} Tile set info.\n */\nfunction parseTileSetMetadata(sourceInfo, tileSet) {\n  const tileMatrixSetLimits = tileSet.tileMatrixSetLimits;\n  let tileUrlTemplate;\n  if (tileSet.dataType === 'map') {\n    tileUrlTemplate = getMapTileUrlTemplate(tileSet.links, sourceInfo.mediaType);\n  } else if (tileSet.dataType === 'vector') {\n    tileUrlTemplate = getVectorTileUrlTemplate(tileSet.links, sourceInfo.mediaType, sourceInfo.supportedMediaTypes);\n  } else {\n    throw new Error('Expected tileset data type to be \"map\" or \"vector\"');\n  }\n  if (tileSet.tileMatrixSet) {\n    return parseTileMatrixSet(sourceInfo, tileSet.tileMatrixSet, tileUrlTemplate, tileMatrixSetLimits);\n  }\n  const tileMatrixSetLink = tileSet.links.find(link => link.rel === 'http://www.opengis.net/def/rel/ogc/1.0/tiling-scheme');\n  if (!tileMatrixSetLink) {\n    throw new Error('Expected http://www.opengis.net/def/rel/ogc/1.0/tiling-scheme link or tileMatrixSet');\n  }\n  const tileMatrixSetDefinition = tileMatrixSetLink.href;\n  const url = resolveUrl(sourceInfo.url, tileMatrixSetDefinition);\n  return getJSON(url).then(function (tileMatrixSet) {\n    return parseTileMatrixSet(sourceInfo, tileMatrixSet, tileUrlTemplate, tileMatrixSetLimits);\n  });\n}\n\n/**\n * @param {SourceInfo} sourceInfo Source info.\n * @return {Promise<TileSetInfo>} Tile set info.\n */\nexport function getTileSetInfo(sourceInfo) {\n  return getJSON(sourceInfo.url).then(function (tileSet) {\n    return parseTileSetMetadata(sourceInfo, tileSet);\n  });\n}","map":{"version":3,"names":["TileGrid","getJSON","resolveUrl","get","getProjection","getIntersection","intersectExtents","knownMapMediaTypes","knownVectorMediaTypes","getMapTileUrlTemplate","links","mediaType","tileUrlTemplate","fallbackUrlTemplate","i","length","link","rel","type","href","startsWith","Error","getVectorTileUrlTemplate","supportedMediaTypes","hrefLookup","supportedMediaType","parseTileMatrixSet","sourceInfo","tileMatrixSet","tileMatrixSetLimits","projection","crs","backwards","getAxisOrientation","substr","matrices","tileMatrices","matrixLookup","matrix","id","limitLookup","matrixIds","limit","tileMatrix","push","origins","Array","resolutions","sizes","tileSizes","extent","Infinity","origin","pointOfOrigin","cellSize","matrixWidth","matrixHeight","tileWidth","tileHeight","tileMapWidth","minX","minTileCol","maxX","maxTileCol","tileMapHeight","upsideDown","cornerOfOrigin","minY","maxY","minTileRow","maxTileRow","tileGrid","undefined","context","base","url","tileUrlFunction","tileCoord","pixelRatio","localContext","tileCol","tileRow","Object","assign","replace","m","p","grid","urlTemplate","urlFunction","parseTileSetMetadata","tileSet","dataType","tileMatrixSetLink","find","tileMatrixSetDefinition","then","getTileSetInfo"],"sources":["E:/Desktop/SceneryPlatform_v3.0_LTS/node_modules/ol/source/ogcTileUtil.js"],"sourcesContent":["/**\n * @module ol/source/ogcTileUtil\n */\n\nimport TileGrid from '../tilegrid/TileGrid.js';\nimport {getJSON, resolveUrl} from '../net.js';\nimport {get as getProjection} from '../proj.js';\nimport {getIntersection as intersectExtents} from '../extent.js';\n\n/**\n * See https://ogcapi.ogc.org/tiles/.\n */\n\n/**\n * @typedef {'map' | 'vector'} TileType\n */\n\n/**\n * @typedef {'topLeft' | 'bottomLeft'} CornerOfOrigin\n */\n\n/**\n * @typedef {Object} TileSet\n * @property {TileType} dataType Type of data represented in the tileset.\n * @property {string} [tileMatrixSetDefinition] Reference to a tile matrix set definition.\n * @property {TileMatrixSet} [tileMatrixSet] Tile matrix set definition.\n * @property {Array<TileMatrixSetLimit>} [tileMatrixSetLimits] Tile matrix set limits.\n * @property {Array<Link>} links Tileset links.\n */\n\n/**\n * @typedef {Object} Link\n * @property {string} rel The link rel attribute.\n * @property {string} href The link URL.\n * @property {string} type The link type.\n */\n\n/**\n * @typedef {Object} TileMatrixSetLimit\n * @property {string} tileMatrix The tile matrix id.\n * @property {number} minTileRow The minimum tile row.\n * @property {number} maxTileRow The maximum tile row.\n * @property {number} minTileCol The minimum tile column.\n * @property {number} maxTileCol The maximum tile column.\n */\n\n/**\n * @typedef {Object} TileMatrixSet\n * @property {string} id The tile matrix set identifier.\n * @property {string} crs The coordinate reference system.\n * @property {Array<TileMatrix>} tileMatrices Array of tile matrices.\n */\n\n/**\n * @typedef {Object} TileMatrix\n * @property {string} id The tile matrix identifier.\n * @property {number} cellSize The pixel resolution (map units per pixel).\n * @property {Array<number>} pointOfOrigin The map location of the matrix origin.\n * @property {CornerOfOrigin} [cornerOfOrigin='topLeft'] The corner of the matrix that represents the origin ('topLeft' or 'bottomLeft').\n * @property {number} matrixWidth The number of columns.\n * @property {number} matrixHeight The number of rows.\n * @property {number} tileWidth The pixel width of a tile.\n * @property {number} tileHeight The pixel height of a tile.\n */\n\n/**\n * @type {Object<string, boolean>}\n */\nconst knownMapMediaTypes = {\n  'image/png': true,\n  'image/jpeg': true,\n  'image/gif': true,\n  'image/webp': true,\n};\n\n/**\n * @type {Object<string, boolean>}\n */\nconst knownVectorMediaTypes = {\n  'application/vnd.mapbox-vector-tile': true,\n  'application/geo+json': true,\n};\n\n/**\n * @typedef {Object} TileSetInfo\n * @property {string} urlTemplate The tile URL template.\n * @property {import(\"../tilegrid/TileGrid.js\").default} grid The tile grid.\n * @property {import(\"../Tile.js\").UrlFunction} urlFunction The tile URL function.\n */\n\n/**\n * @typedef {Object} SourceInfo\n * @property {string} url The tile set URL.\n * @property {string} mediaType The preferred tile media type.\n * @property {Array<string>} [supportedMediaTypes] The supported media types.\n * @property {import(\"../proj/Projection.js\").default} projection The source projection.\n * @property {Object} [context] Optional context for constructing the URL.\n */\n\n/**\n * @param {Array<Link>} links Tileset links.\n * @param {string} [mediaType] The preferred media type.\n * @return {string} The tile URL template.\n */\nexport function getMapTileUrlTemplate(links, mediaType) {\n  let tileUrlTemplate;\n  let fallbackUrlTemplate;\n  for (let i = 0; i < links.length; ++i) {\n    const link = links[i];\n    if (link.rel === 'item') {\n      if (link.type === mediaType) {\n        tileUrlTemplate = link.href;\n        break;\n      }\n      if (knownMapMediaTypes[link.type]) {\n        fallbackUrlTemplate = link.href;\n      } else if (!fallbackUrlTemplate && link.type.startsWith('image/')) {\n        fallbackUrlTemplate = link.href;\n      }\n    }\n  }\n\n  if (!tileUrlTemplate) {\n    if (fallbackUrlTemplate) {\n      tileUrlTemplate = fallbackUrlTemplate;\n    } else {\n      throw new Error('Could not find \"item\" link');\n    }\n  }\n\n  return tileUrlTemplate;\n}\n\n/**\n * @param {Array<Link>} links Tileset links.\n * @param {string} [mediaType] The preferred media type.\n * @param {Array<string>} [supportedMediaTypes] The media types supported by the parser.\n * @return {string} The tile URL template.\n */\nexport function getVectorTileUrlTemplate(\n  links,\n  mediaType,\n  supportedMediaTypes\n) {\n  let tileUrlTemplate;\n  let fallbackUrlTemplate;\n\n  /**\n   * Lookup of URL by media type.\n   * @type {Object<string, string>}\n   */\n  const hrefLookup = {};\n\n  for (let i = 0; i < links.length; ++i) {\n    const link = links[i];\n    hrefLookup[link.type] = link.href;\n    if (link.rel === 'item') {\n      if (link.type === mediaType) {\n        tileUrlTemplate = link.href;\n        break;\n      }\n      if (knownVectorMediaTypes[link.type]) {\n        fallbackUrlTemplate = link.href;\n      }\n    }\n  }\n\n  if (!tileUrlTemplate && supportedMediaTypes) {\n    for (let i = 0; i < supportedMediaTypes.length; ++i) {\n      const supportedMediaType = supportedMediaTypes[i];\n      if (hrefLookup[supportedMediaType]) {\n        tileUrlTemplate = hrefLookup[supportedMediaType];\n        break;\n      }\n    }\n  }\n\n  if (!tileUrlTemplate) {\n    if (fallbackUrlTemplate) {\n      tileUrlTemplate = fallbackUrlTemplate;\n    } else {\n      throw new Error('Could not find \"item\" link');\n    }\n  }\n\n  return tileUrlTemplate;\n}\n\n/**\n * @param {SourceInfo} sourceInfo The source info.\n * @param {TileMatrixSet} tileMatrixSet Tile matrix set.\n * @param {string} tileUrlTemplate Tile URL template.\n * @param {Array<TileMatrixSetLimit>} [tileMatrixSetLimits] Tile matrix set limits.\n * @return {TileSetInfo} Tile set info.\n */\nfunction parseTileMatrixSet(\n  sourceInfo,\n  tileMatrixSet,\n  tileUrlTemplate,\n  tileMatrixSetLimits\n) {\n  let projection = sourceInfo.projection;\n  if (!projection) {\n    projection = getProjection(tileMatrixSet.crs);\n    if (!projection) {\n      throw new Error(`Unsupported CRS: ${tileMatrixSet.crs}`);\n    }\n  }\n  const backwards = projection.getAxisOrientation().substr(0, 2) !== 'en';\n\n  const matrices = tileMatrixSet.tileMatrices;\n\n  /**\n   * @type {Object<string, TileMatrix>}\n   */\n  const matrixLookup = {};\n  for (let i = 0; i < matrices.length; ++i) {\n    const matrix = matrices[i];\n    matrixLookup[matrix.id] = matrix;\n  }\n\n  /**\n   * @type {Object<string, TileMatrixSetLimit>}\n   */\n  const limitLookup = {};\n\n  /**\n   * @type {Array<string>}\n   */\n  const matrixIds = [];\n\n  if (tileMatrixSetLimits) {\n    for (let i = 0; i < tileMatrixSetLimits.length; ++i) {\n      const limit = tileMatrixSetLimits[i];\n      const id = limit.tileMatrix;\n      matrixIds.push(id);\n      limitLookup[id] = limit;\n    }\n  } else {\n    for (let i = 0; i < matrices.length; ++i) {\n      const id = matrices[i].id;\n      matrixIds.push(id);\n    }\n  }\n\n  const length = matrixIds.length;\n  const origins = new Array(length);\n  const resolutions = new Array(length);\n  const sizes = new Array(length);\n  const tileSizes = new Array(length);\n  const extent = [-Infinity, -Infinity, Infinity, Infinity];\n\n  for (let i = 0; i < length; ++i) {\n    const id = matrixIds[i];\n    const matrix = matrixLookup[id];\n    const origin = matrix.pointOfOrigin;\n    if (backwards) {\n      origins[i] = [origin[1], origin[0]];\n    } else {\n      origins[i] = origin;\n    }\n    resolutions[i] = matrix.cellSize;\n    sizes[i] = [matrix.matrixWidth, matrix.matrixHeight];\n    tileSizes[i] = [matrix.tileWidth, matrix.tileHeight];\n    const limit = limitLookup[id];\n    if (limit) {\n      const tileMapWidth = matrix.cellSize * matrix.tileWidth;\n      const minX = origins[i][0] + limit.minTileCol * tileMapWidth;\n      const maxX = origins[i][0] + (limit.maxTileCol + 1) * tileMapWidth;\n\n      const tileMapHeight = matrix.cellSize * matrix.tileHeight;\n      const upsideDown = matrix.cornerOfOrigin === 'bottomLeft';\n\n      let minY;\n      let maxY;\n      if (upsideDown) {\n        minY = origins[i][1] + limit.minTileRow * tileMapHeight;\n        maxY = origins[i][1] + (limit.maxTileRow + 1) * tileMapHeight;\n      } else {\n        minY = origins[i][1] - (limit.maxTileRow + 1) * tileMapHeight;\n        maxY = origins[i][1] - limit.minTileRow * tileMapHeight;\n      }\n\n      intersectExtents(extent, [minX, minY, maxX, maxY], extent);\n    }\n  }\n\n  const tileGrid = new TileGrid({\n    origins: origins,\n    resolutions: resolutions,\n    sizes: sizes,\n    tileSizes: tileSizes,\n    extent: tileMatrixSetLimits ? extent : undefined,\n  });\n\n  const context = sourceInfo.context;\n  const base = sourceInfo.url;\n\n  function tileUrlFunction(tileCoord, pixelRatio, projection) {\n    if (!tileCoord) {\n      return undefined;\n    }\n\n    const id = matrixIds[tileCoord[0]];\n    const matrix = matrixLookup[id];\n    const upsideDown = matrix.cornerOfOrigin === 'bottomLeft';\n\n    const localContext = {\n      tileMatrix: id,\n      tileCol: tileCoord[1],\n      tileRow: upsideDown ? -tileCoord[2] - 1 : tileCoord[2],\n    };\n\n    if (tileMatrixSetLimits) {\n      const limit = limitLookup[matrix.id];\n      if (\n        localContext.tileCol < limit.minTileCol ||\n        localContext.tileCol > limit.maxTileCol ||\n        localContext.tileRow < limit.minTileRow ||\n        localContext.tileRow > limit.maxTileRow\n      ) {\n        return undefined;\n      }\n    }\n\n    Object.assign(localContext, context);\n\n    const url = tileUrlTemplate.replace(/\\{(\\w+?)\\}/g, function (m, p) {\n      return localContext[p];\n    });\n\n    return resolveUrl(base, url);\n  }\n\n  return {\n    grid: tileGrid,\n    urlTemplate: tileUrlTemplate,\n    urlFunction: tileUrlFunction,\n  };\n}\n\n/**\n * @param {SourceInfo} sourceInfo The source info.\n * @param {TileSet} tileSet Tile set.\n * @return {TileSetInfo|Promise<TileSetInfo>} Tile set info.\n */\nfunction parseTileSetMetadata(sourceInfo, tileSet) {\n  const tileMatrixSetLimits = tileSet.tileMatrixSetLimits;\n  let tileUrlTemplate;\n\n  if (tileSet.dataType === 'map') {\n    tileUrlTemplate = getMapTileUrlTemplate(\n      tileSet.links,\n      sourceInfo.mediaType\n    );\n  } else if (tileSet.dataType === 'vector') {\n    tileUrlTemplate = getVectorTileUrlTemplate(\n      tileSet.links,\n      sourceInfo.mediaType,\n      sourceInfo.supportedMediaTypes\n    );\n  } else {\n    throw new Error('Expected tileset data type to be \"map\" or \"vector\"');\n  }\n\n  if (tileSet.tileMatrixSet) {\n    return parseTileMatrixSet(\n      sourceInfo,\n      tileSet.tileMatrixSet,\n      tileUrlTemplate,\n      tileMatrixSetLimits\n    );\n  }\n\n  const tileMatrixSetLink = tileSet.links.find(\n    (link) =>\n      link.rel === 'http://www.opengis.net/def/rel/ogc/1.0/tiling-scheme'\n  );\n  if (!tileMatrixSetLink) {\n    throw new Error(\n      'Expected http://www.opengis.net/def/rel/ogc/1.0/tiling-scheme link or tileMatrixSet'\n    );\n  }\n  const tileMatrixSetDefinition = tileMatrixSetLink.href;\n\n  const url = resolveUrl(sourceInfo.url, tileMatrixSetDefinition);\n  return getJSON(url).then(function (tileMatrixSet) {\n    return parseTileMatrixSet(\n      sourceInfo,\n      tileMatrixSet,\n      tileUrlTemplate,\n      tileMatrixSetLimits\n    );\n  });\n}\n\n/**\n * @param {SourceInfo} sourceInfo Source info.\n * @return {Promise<TileSetInfo>} Tile set info.\n */\nexport function getTileSetInfo(sourceInfo) {\n  return getJSON(sourceInfo.url).then(function (tileSet) {\n    return parseTileSetMetadata(sourceInfo, tileSet);\n  });\n}\n"],"mappings":";AAAA;AACA;AACA;;AAEA,OAAOA,QAAQ,MAAM,yBAAyB;AAC9C,SAAQC,OAAO,EAAEC,UAAU,QAAO,WAAW;AAC7C,SAAQC,GAAG,IAAIC,aAAa,QAAO,YAAY;AAC/C,SAAQC,eAAe,IAAIC,gBAAgB,QAAO,cAAc;;AAEhE;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAMC,kBAAkB,GAAG;EACzB,WAAW,EAAE,IAAI;EACjB,YAAY,EAAE,IAAI;EAClB,WAAW,EAAE,IAAI;EACjB,YAAY,EAAE;AAChB,CAAC;;AAED;AACA;AACA;AACA,MAAMC,qBAAqB,GAAG;EAC5B,oCAAoC,EAAE,IAAI;EAC1C,sBAAsB,EAAE;AAC1B,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASC,qBAAqBA,CAACC,KAAK,EAAEC,SAAS,EAAE;EACtD,IAAIC,eAAe;EACnB,IAAIC,mBAAmB;EACvB,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGJ,KAAK,CAACK,MAAM,EAAE,EAAED,CAAC,EAAE;IACrC,MAAME,IAAI,GAAGN,KAAK,CAACI,CAAC,CAAC;IACrB,IAAIE,IAAI,CAACC,GAAG,KAAK,MAAM,EAAE;MACvB,IAAID,IAAI,CAACE,IAAI,KAAKP,SAAS,EAAE;QAC3BC,eAAe,GAAGI,IAAI,CAACG,IAAI;QAC3B;MACF;MACA,IAAIZ,kBAAkB,CAACS,IAAI,CAACE,IAAI,CAAC,EAAE;QACjCL,mBAAmB,GAAGG,IAAI,CAACG,IAAI;MACjC,CAAC,MAAM,IAAI,CAACN,mBAAmB,IAAIG,IAAI,CAACE,IAAI,CAACE,UAAU,CAAC,QAAQ,CAAC,EAAE;QACjEP,mBAAmB,GAAGG,IAAI,CAACG,IAAI;MACjC;IACF;EACF;EAEA,IAAI,CAACP,eAAe,EAAE;IACpB,IAAIC,mBAAmB,EAAE;MACvBD,eAAe,GAAGC,mBAAmB;IACvC,CAAC,MAAM;MACL,MAAM,IAAIQ,KAAK,CAAC,4BAA4B,CAAC;IAC/C;EACF;EAEA,OAAOT,eAAe;AACxB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASU,wBAAwBA,CACtCZ,KAAK,EACLC,SAAS,EACTY,mBAAmB,EACnB;EACA,IAAIX,eAAe;EACnB,IAAIC,mBAAmB;;EAEvB;AACF;AACA;AACA;EACE,MAAMW,UAAU,GAAG,CAAC,CAAC;EAErB,KAAK,IAAIV,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGJ,KAAK,CAACK,MAAM,EAAE,EAAED,CAAC,EAAE;IACrC,MAAME,IAAI,GAAGN,KAAK,CAACI,CAAC,CAAC;IACrBU,UAAU,CAACR,IAAI,CAACE,IAAI,CAAC,GAAGF,IAAI,CAACG,IAAI;IACjC,IAAIH,IAAI,CAACC,GAAG,KAAK,MAAM,EAAE;MACvB,IAAID,IAAI,CAACE,IAAI,KAAKP,SAAS,EAAE;QAC3BC,eAAe,GAAGI,IAAI,CAACG,IAAI;QAC3B;MACF;MACA,IAAIX,qBAAqB,CAACQ,IAAI,CAACE,IAAI,CAAC,EAAE;QACpCL,mBAAmB,GAAGG,IAAI,CAACG,IAAI;MACjC;IACF;EACF;EAEA,IAAI,CAACP,eAAe,IAAIW,mBAAmB,EAAE;IAC3C,KAAK,IAAIT,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGS,mBAAmB,CAACR,MAAM,EAAE,EAAED,CAAC,EAAE;MACnD,MAAMW,kBAAkB,GAAGF,mBAAmB,CAACT,CAAC,CAAC;MACjD,IAAIU,UAAU,CAACC,kBAAkB,CAAC,EAAE;QAClCb,eAAe,GAAGY,UAAU,CAACC,kBAAkB,CAAC;QAChD;MACF;IACF;EACF;EAEA,IAAI,CAACb,eAAe,EAAE;IACpB,IAAIC,mBAAmB,EAAE;MACvBD,eAAe,GAAGC,mBAAmB;IACvC,CAAC,MAAM;MACL,MAAM,IAAIQ,KAAK,CAAC,4BAA4B,CAAC;IAC/C;EACF;EAEA,OAAOT,eAAe;AACxB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASc,kBAAkBA,CACzBC,UAAU,EACVC,aAAa,EACbhB,eAAe,EACfiB,mBAAmB,EACnB;EACA,IAAIC,UAAU,GAAGH,UAAU,CAACG,UAAU;EACtC,IAAI,CAACA,UAAU,EAAE;IACfA,UAAU,GAAG1B,aAAa,CAACwB,aAAa,CAACG,GAAG,CAAC;IAC7C,IAAI,CAACD,UAAU,EAAE;MACf,MAAM,IAAIT,KAAK,CAAE,oBAAmBO,aAAa,CAACG,GAAI,EAAC,CAAC;IAC1D;EACF;EACA,MAAMC,SAAS,GAAGF,UAAU,CAACG,kBAAkB,CAAC,CAAC,CAACC,MAAM,CAAC,CAAC,EAAE,CAAC,CAAC,KAAK,IAAI;EAEvE,MAAMC,QAAQ,GAAGP,aAAa,CAACQ,YAAY;;EAE3C;AACF;AACA;EACE,MAAMC,YAAY,GAAG,CAAC,CAAC;EACvB,KAAK,IAAIvB,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGqB,QAAQ,CAACpB,MAAM,EAAE,EAAED,CAAC,EAAE;IACxC,MAAMwB,MAAM,GAAGH,QAAQ,CAACrB,CAAC,CAAC;IAC1BuB,YAAY,CAACC,MAAM,CAACC,EAAE,CAAC,GAAGD,MAAM;EAClC;;EAEA;AACF;AACA;EACE,MAAME,WAAW,GAAG,CAAC,CAAC;;EAEtB;AACF;AACA;EACE,MAAMC,SAAS,GAAG,EAAE;EAEpB,IAAIZ,mBAAmB,EAAE;IACvB,KAAK,IAAIf,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGe,mBAAmB,CAACd,MAAM,EAAE,EAAED,CAAC,EAAE;MACnD,MAAM4B,KAAK,GAAGb,mBAAmB,CAACf,CAAC,CAAC;MACpC,MAAMyB,EAAE,GAAGG,KAAK,CAACC,UAAU;MAC3BF,SAAS,CAACG,IAAI,CAACL,EAAE,CAAC;MAClBC,WAAW,CAACD,EAAE,CAAC,GAAGG,KAAK;IACzB;EACF,CAAC,MAAM;IACL,KAAK,IAAI5B,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGqB,QAAQ,CAACpB,MAAM,EAAE,EAAED,CAAC,EAAE;MACxC,MAAMyB,EAAE,GAAGJ,QAAQ,CAACrB,CAAC,CAAC,CAACyB,EAAE;MACzBE,SAAS,CAACG,IAAI,CAACL,EAAE,CAAC;IACpB;EACF;EAEA,MAAMxB,MAAM,GAAG0B,SAAS,CAAC1B,MAAM;EAC/B,MAAM8B,OAAO,GAAG,IAAIC,KAAK,CAAC/B,MAAM,CAAC;EACjC,MAAMgC,WAAW,GAAG,IAAID,KAAK,CAAC/B,MAAM,CAAC;EACrC,MAAMiC,KAAK,GAAG,IAAIF,KAAK,CAAC/B,MAAM,CAAC;EAC/B,MAAMkC,SAAS,GAAG,IAAIH,KAAK,CAAC/B,MAAM,CAAC;EACnC,MAAMmC,MAAM,GAAG,CAAC,CAACC,QAAQ,EAAE,CAACA,QAAQ,EAAEA,QAAQ,EAAEA,QAAQ,CAAC;EAEzD,KAAK,IAAIrC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGC,MAAM,EAAE,EAAED,CAAC,EAAE;IAC/B,MAAMyB,EAAE,GAAGE,SAAS,CAAC3B,CAAC,CAAC;IACvB,MAAMwB,MAAM,GAAGD,YAAY,CAACE,EAAE,CAAC;IAC/B,MAAMa,MAAM,GAAGd,MAAM,CAACe,aAAa;IACnC,IAAIrB,SAAS,EAAE;MACba,OAAO,CAAC/B,CAAC,CAAC,GAAG,CAACsC,MAAM,CAAC,CAAC,CAAC,EAAEA,MAAM,CAAC,CAAC,CAAC,CAAC;IACrC,CAAC,MAAM;MACLP,OAAO,CAAC/B,CAAC,CAAC,GAAGsC,MAAM;IACrB;IACAL,WAAW,CAACjC,CAAC,CAAC,GAAGwB,MAAM,CAACgB,QAAQ;IAChCN,KAAK,CAAClC,CAAC,CAAC,GAAG,CAACwB,MAAM,CAACiB,WAAW,EAAEjB,MAAM,CAACkB,YAAY,CAAC;IACpDP,SAAS,CAACnC,CAAC,CAAC,GAAG,CAACwB,MAAM,CAACmB,SAAS,EAAEnB,MAAM,CAACoB,UAAU,CAAC;IACpD,MAAMhB,KAAK,GAAGF,WAAW,CAACD,EAAE,CAAC;IAC7B,IAAIG,KAAK,EAAE;MACT,MAAMiB,YAAY,GAAGrB,MAAM,CAACgB,QAAQ,GAAGhB,MAAM,CAACmB,SAAS;MACvD,MAAMG,IAAI,GAAGf,OAAO,CAAC/B,CAAC,CAAC,CAAC,CAAC,CAAC,GAAG4B,KAAK,CAACmB,UAAU,GAAGF,YAAY;MAC5D,MAAMG,IAAI,GAAGjB,OAAO,CAAC/B,CAAC,CAAC,CAAC,CAAC,CAAC,GAAG,CAAC4B,KAAK,CAACqB,UAAU,GAAG,CAAC,IAAIJ,YAAY;MAElE,MAAMK,aAAa,GAAG1B,MAAM,CAACgB,QAAQ,GAAGhB,MAAM,CAACoB,UAAU;MACzD,MAAMO,UAAU,GAAG3B,MAAM,CAAC4B,cAAc,KAAK,YAAY;MAEzD,IAAIC,IAAI;MACR,IAAIC,IAAI;MACR,IAAIH,UAAU,EAAE;QACdE,IAAI,GAAGtB,OAAO,CAAC/B,CAAC,CAAC,CAAC,CAAC,CAAC,GAAG4B,KAAK,CAAC2B,UAAU,GAAGL,aAAa;QACvDI,IAAI,GAAGvB,OAAO,CAAC/B,CAAC,CAAC,CAAC,CAAC,CAAC,GAAG,CAAC4B,KAAK,CAAC4B,UAAU,GAAG,CAAC,IAAIN,aAAa;MAC/D,CAAC,MAAM;QACLG,IAAI,GAAGtB,OAAO,CAAC/B,CAAC,CAAC,CAAC,CAAC,CAAC,GAAG,CAAC4B,KAAK,CAAC4B,UAAU,GAAG,CAAC,IAAIN,aAAa;QAC7DI,IAAI,GAAGvB,OAAO,CAAC/B,CAAC,CAAC,CAAC,CAAC,CAAC,GAAG4B,KAAK,CAAC2B,UAAU,GAAGL,aAAa;MACzD;MAEA1D,gBAAgB,CAAC4C,MAAM,EAAE,CAACU,IAAI,EAAEO,IAAI,EAAEL,IAAI,EAAEM,IAAI,CAAC,EAAElB,MAAM,CAAC;IAC5D;EACF;EAEA,MAAMqB,QAAQ,GAAG,IAAIvE,QAAQ,CAAC;IAC5B6C,OAAO,EAAEA,OAAO;IAChBE,WAAW,EAAEA,WAAW;IACxBC,KAAK,EAAEA,KAAK;IACZC,SAAS,EAAEA,SAAS;IACpBC,MAAM,EAAErB,mBAAmB,GAAGqB,MAAM,GAAGsB;EACzC,CAAC,CAAC;EAEF,MAAMC,OAAO,GAAG9C,UAAU,CAAC8C,OAAO;EAClC,MAAMC,IAAI,GAAG/C,UAAU,CAACgD,GAAG;EAE3B,SAASC,eAAeA,CAACC,SAAS,EAAEC,UAAU,EAAEhD,UAAU,EAAE;IAC1D,IAAI,CAAC+C,SAAS,EAAE;MACd,OAAOL,SAAS;IAClB;IAEA,MAAMjC,EAAE,GAAGE,SAAS,CAACoC,SAAS,CAAC,CAAC,CAAC,CAAC;IAClC,MAAMvC,MAAM,GAAGD,YAAY,CAACE,EAAE,CAAC;IAC/B,MAAM0B,UAAU,GAAG3B,MAAM,CAAC4B,cAAc,KAAK,YAAY;IAEzD,MAAMa,YAAY,GAAG;MACnBpC,UAAU,EAAEJ,EAAE;MACdyC,OAAO,EAAEH,SAAS,CAAC,CAAC,CAAC;MACrBI,OAAO,EAAEhB,UAAU,GAAG,CAACY,SAAS,CAAC,CAAC,CAAC,GAAG,CAAC,GAAGA,SAAS,CAAC,CAAC;IACvD,CAAC;IAED,IAAIhD,mBAAmB,EAAE;MACvB,MAAMa,KAAK,GAAGF,WAAW,CAACF,MAAM,CAACC,EAAE,CAAC;MACpC,IACEwC,YAAY,CAACC,OAAO,GAAGtC,KAAK,CAACmB,UAAU,IACvCkB,YAAY,CAACC,OAAO,GAAGtC,KAAK,CAACqB,UAAU,IACvCgB,YAAY,CAACE,OAAO,GAAGvC,KAAK,CAAC2B,UAAU,IACvCU,YAAY,CAACE,OAAO,GAAGvC,KAAK,CAAC4B,UAAU,EACvC;QACA,OAAOE,SAAS;MAClB;IACF;IAEAU,MAAM,CAACC,MAAM,CAACJ,YAAY,EAAEN,OAAO,CAAC;IAEpC,MAAME,GAAG,GAAG/D,eAAe,CAACwE,OAAO,CAAC,aAAa,EAAE,UAAUC,CAAC,EAAEC,CAAC,EAAE;MACjE,OAAOP,YAAY,CAACO,CAAC,CAAC;IACxB,CAAC,CAAC;IAEF,OAAOpF,UAAU,CAACwE,IAAI,EAAEC,GAAG,CAAC;EAC9B;EAEA,OAAO;IACLY,IAAI,EAAEhB,QAAQ;IACdiB,WAAW,EAAE5E,eAAe;IAC5B6E,WAAW,EAAEb;EACf,CAAC;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA,SAASc,oBAAoBA,CAAC/D,UAAU,EAAEgE,OAAO,EAAE;EACjD,MAAM9D,mBAAmB,GAAG8D,OAAO,CAAC9D,mBAAmB;EACvD,IAAIjB,eAAe;EAEnB,IAAI+E,OAAO,CAACC,QAAQ,KAAK,KAAK,EAAE;IAC9BhF,eAAe,GAAGH,qBAAqB,CACrCkF,OAAO,CAACjF,KAAK,EACbiB,UAAU,CAAChB,SACb,CAAC;EACH,CAAC,MAAM,IAAIgF,OAAO,CAACC,QAAQ,KAAK,QAAQ,EAAE;IACxChF,eAAe,GAAGU,wBAAwB,CACxCqE,OAAO,CAACjF,KAAK,EACbiB,UAAU,CAAChB,SAAS,EACpBgB,UAAU,CAACJ,mBACb,CAAC;EACH,CAAC,MAAM;IACL,MAAM,IAAIF,KAAK,CAAC,oDAAoD,CAAC;EACvE;EAEA,IAAIsE,OAAO,CAAC/D,aAAa,EAAE;IACzB,OAAOF,kBAAkB,CACvBC,UAAU,EACVgE,OAAO,CAAC/D,aAAa,EACrBhB,eAAe,EACfiB,mBACF,CAAC;EACH;EAEA,MAAMgE,iBAAiB,GAAGF,OAAO,CAACjF,KAAK,CAACoF,IAAI,CACzC9E,IAAI,IACHA,IAAI,CAACC,GAAG,KAAK,sDACjB,CAAC;EACD,IAAI,CAAC4E,iBAAiB,EAAE;IACtB,MAAM,IAAIxE,KAAK,CACb,qFACF,CAAC;EACH;EACA,MAAM0E,uBAAuB,GAAGF,iBAAiB,CAAC1E,IAAI;EAEtD,MAAMwD,GAAG,GAAGzE,UAAU,CAACyB,UAAU,CAACgD,GAAG,EAAEoB,uBAAuB,CAAC;EAC/D,OAAO9F,OAAO,CAAC0E,GAAG,CAAC,CAACqB,IAAI,CAAC,UAAUpE,aAAa,EAAE;IAChD,OAAOF,kBAAkB,CACvBC,UAAU,EACVC,aAAa,EACbhB,eAAe,EACfiB,mBACF,CAAC;EACH,CAAC,CAAC;AACJ;;AAEA;AACA;AACA;AACA;AACA,OAAO,SAASoE,cAAcA,CAACtE,UAAU,EAAE;EACzC,OAAO1B,OAAO,CAAC0B,UAAU,CAACgD,GAAG,CAAC,CAACqB,IAAI,CAAC,UAAUL,OAAO,EAAE;IACrD,OAAOD,oBAAoB,CAAC/D,UAAU,EAAEgE,OAAO,CAAC;EAClD,CAAC,CAAC;AACJ"},"metadata":{},"sourceType":"module","externalDependencies":[]}