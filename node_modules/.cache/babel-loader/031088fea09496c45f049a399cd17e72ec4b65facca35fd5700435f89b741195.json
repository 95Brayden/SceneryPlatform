{"ast":null,"code":"/**\n * @module ol/expr/cpu\n */\n\nimport { LiteralExpression, Ops, overlapsType, parse, typeName } from './expression.js';\n\n/**\n * @fileoverview This module includes functions to build expressions for evaluation on the CPU.\n * Building is composed of two steps: parsing and compiling.  The parsing step takes an encoded\n * expression and returns an instance of one of the expression classes.  The compiling step takes\n * the expression instance and returns a function that can be evaluated in to return a literal\n * value.  The evaluator function should do as little allocation and work as possible.\n */\n\n/**\n * @typedef {Object} EvaluationContext\n * @property {Object} properties The values for properties used in 'get' expressions.\n * @property {Object} variables The values for variables used in 'var' expressions.\n * @property {number} resolution The map resolution.\n */\n\n/**\n * @return {EvaluationContext} A new evaluation context.\n */\nexport function newEvaluationContext() {\n  return {\n    variables: {},\n    properties: {},\n    resolution: NaN\n  };\n}\n\n/**\n * @typedef {function(EvaluationContext):import(\"./expression.js\").LiteralValue} ExpressionEvaluator\n */\n\n/**\n * @typedef {function(EvaluationContext):boolean} BooleanEvaluator\n */\n\n/**\n * @typedef {function(EvaluationContext):number} NumberEvaluator\n */\n\n/**\n * @typedef {function(EvaluationContext):string} StringEvaluator\n */\n\n/**\n * @typedef {function(EvaluationContext):(Array<number>|string)} ColorLikeEvaluator\n */\n\n/**\n * @typedef {function(EvaluationContext):Array<number>} NumberArrayEvaluator\n */\n\n/**\n * @typedef {function(EvaluationContext):Array<number>} CoordinateEvaluator\n */\n\n/**\n * @typedef {function(EvaluationContext):(Array<number>|number)} SizeLikeEvaluator\n */\n\n/**\n * @param {import('./expression.js').EncodedExpression} encoded The encoded expression.\n * @param {number} type The expected type.\n * @param {import('./expression.js').ParsingContext} context The parsing context.\n * @return {ExpressionEvaluator} The expression evaluator.\n */\nexport function buildExpression(encoded, type, context) {\n  const expression = parse(encoded, context);\n  if (!overlapsType(type, expression.type)) {\n    const expected = typeName(type);\n    const actual = typeName(expression.type);\n    throw new Error(`Expected expression to be of type ${expected}, got ${actual}`);\n  }\n  return compileExpression(expression, context);\n}\n\n/**\n * @param {import(\"./expression.js\").Expression} expression The expression.\n * @param {import('./expression.js').ParsingContext} context The parsing context.\n * @return {ExpressionEvaluator} The evaluator function.\n */\nfunction compileExpression(expression, context) {\n  if (expression instanceof LiteralExpression) {\n    return function () {\n      return expression.value;\n    };\n  }\n  const operator = expression.operator;\n  switch (operator) {\n    case Ops.Number:\n    case Ops.String:\n      {\n        return compileAssertionExpression(expression, context);\n      }\n    case Ops.Get:\n    case Ops.Var:\n      {\n        return compileAccessorExpression(expression, context);\n      }\n    case Ops.Resolution:\n      {\n        return context => context.resolution;\n      }\n    case Ops.Any:\n    case Ops.All:\n    case Ops.Not:\n      {\n        return compileLogicalExpression(expression, context);\n      }\n    case Ops.Equal:\n    case Ops.NotEqual:\n    case Ops.LessThan:\n    case Ops.LessThanOrEqualTo:\n    case Ops.GreaterThan:\n    case Ops.GreaterThanOrEqualTo:\n      {\n        return compileComparisonExpression(expression, context);\n      }\n    case Ops.Multiply:\n    case Ops.Divide:\n    case Ops.Add:\n    case Ops.Subtract:\n    case Ops.Clamp:\n    case Ops.Mod:\n    case Ops.Pow:\n    case Ops.Abs:\n    case Ops.Floor:\n    case Ops.Ceil:\n    case Ops.Round:\n    case Ops.Sin:\n    case Ops.Cos:\n    case Ops.Atan:\n    case Ops.Sqrt:\n      {\n        return compileNumericExpression(expression, context);\n      }\n    case Ops.Match:\n      {\n        return compileMatchExpression(expression, context);\n      }\n    default:\n      {\n        throw new Error(`Unsupported operator ${operator}`);\n      }\n  }\n}\n\n/**\n * @param {import('./expression.js').CallExpression} expression The call expression.\n * @param {import('./expression.js').ParsingContext} context The parsing context.\n * @return {ExpressionEvaluator} The evaluator function.\n */\nfunction compileAssertionExpression(expression, context) {\n  const type = expression.operator;\n  const length = expression.args.length;\n  const args = new Array(length);\n  for (let i = 0; i < length; ++i) {\n    args[i] = compileExpression(expression.args[i], context);\n  }\n  switch (type) {\n    case Ops.Number:\n    case Ops.String:\n      {\n        return context => {\n          for (let i = 0; i < length; ++i) {\n            const value = args[i](context);\n            if (typeof value === type) {\n              return value;\n            }\n          }\n          throw new Error(`Expected one of the values to be a ${type}`);\n        };\n      }\n    default:\n      {\n        throw new Error(`Unsupported assertion operator ${type}`);\n      }\n  }\n}\n\n/**\n * @param {import('./expression.js').CallExpression} expression The call expression.\n * @param {import('./expression.js').ParsingContext} context The parsing context.\n * @return {ExpressionEvaluator} The evaluator function.\n */\nfunction compileAccessorExpression(expression, context) {\n  const nameExpression = expression.args[0];\n  if (!(nameExpression instanceof LiteralExpression)) {\n    throw new Error('Expected literal name');\n  }\n  const name = nameExpression.value;\n  if (typeof name !== 'string') {\n    throw new Error('Expected string name');\n  }\n  switch (expression.operator) {\n    case Ops.Get:\n      {\n        return context => context.properties[name];\n      }\n    case Ops.Var:\n      {\n        return context => context.variables[name];\n      }\n    default:\n      {\n        throw new Error(`Unsupported accessor operator ${expression.operator}`);\n      }\n  }\n}\n\n/**\n * @param {import('./expression.js').CallExpression} expression The call expression.\n * @param {import('./expression.js').ParsingContext} context The parsing context.\n * @return {BooleanEvaluator} The evaluator function.\n */\nfunction compileComparisonExpression(expression, context) {\n  const op = expression.operator;\n  const left = compileExpression(expression.args[0], context);\n  const right = compileExpression(expression.args[1], context);\n  switch (op) {\n    case Ops.Equal:\n      {\n        return context => left(context) === right(context);\n      }\n    case Ops.NotEqual:\n      {\n        return context => left(context) !== right(context);\n      }\n    case Ops.LessThan:\n      {\n        return context => left(context) < right(context);\n      }\n    case Ops.LessThanOrEqualTo:\n      {\n        return context => left(context) <= right(context);\n      }\n    case Ops.GreaterThan:\n      {\n        return context => left(context) > right(context);\n      }\n    case Ops.GreaterThanOrEqualTo:\n      {\n        return context => left(context) >= right(context);\n      }\n    default:\n      {\n        throw new Error(`Unsupported comparison operator ${op}`);\n      }\n  }\n}\n\n/**\n * @param {import('./expression.js').CallExpression} expression The call expression.\n * @param {import('./expression.js').ParsingContext} context The parsing context.\n * @return {BooleanEvaluator} The evaluator function.\n */\nfunction compileLogicalExpression(expression, context) {\n  const op = expression.operator;\n  const length = expression.args.length;\n  const args = new Array(length);\n  for (let i = 0; i < length; ++i) {\n    args[i] = compileExpression(expression.args[i], context);\n  }\n  switch (op) {\n    case Ops.Any:\n      {\n        return context => {\n          for (let i = 0; i < length; ++i) {\n            if (args[i](context)) {\n              return true;\n            }\n          }\n          return false;\n        };\n      }\n    case Ops.All:\n      {\n        return context => {\n          for (let i = 0; i < length; ++i) {\n            if (!args[i](context)) {\n              return false;\n            }\n          }\n          return true;\n        };\n      }\n    case Ops.Not:\n      {\n        return context => !args[0](context);\n      }\n    default:\n      {\n        throw new Error(`Unsupported logical operator ${op}`);\n      }\n  }\n}\n\n/**\n * @param {import('./expression.js').CallExpression} expression The call expression.\n * @param {import('./expression.js').ParsingContext} context The parsing context.\n * @return {NumberEvaluator} The evaluator function.\n */\nfunction compileNumericExpression(expression, context) {\n  const op = expression.operator;\n  const length = expression.args.length;\n  const args = new Array(length);\n  for (let i = 0; i < length; ++i) {\n    args[i] = compileExpression(expression.args[i], context);\n  }\n  switch (op) {\n    case Ops.Multiply:\n      {\n        return context => {\n          let value = 1;\n          for (let i = 0; i < length; ++i) {\n            value *= args[i](context);\n          }\n          return value;\n        };\n      }\n    case Ops.Divide:\n      {\n        return context => args[0](context) / args[1](context);\n      }\n    case Ops.Add:\n      {\n        return context => {\n          let value = 0;\n          for (let i = 0; i < length; ++i) {\n            value += args[i](context);\n          }\n          return value;\n        };\n      }\n    case Ops.Subtract:\n      {\n        return context => args[0](context) - args[1](context);\n      }\n    case Ops.Clamp:\n      {\n        return context => {\n          const value = args[0](context);\n          const min = args[1](context);\n          if (value < min) {\n            return min;\n          }\n          const max = args[2](context);\n          if (value > max) {\n            return max;\n          }\n          return value;\n        };\n      }\n    case Ops.Mod:\n      {\n        return context => args[0](context) % args[1](context);\n      }\n    case Ops.Pow:\n      {\n        return context => Math.pow(args[0](context), args[1](context));\n      }\n    case Ops.Abs:\n      {\n        return context => Math.abs(args[0](context));\n      }\n    case Ops.Floor:\n      {\n        return context => Math.floor(args[0](context));\n      }\n    case Ops.Ceil:\n      {\n        return context => Math.ceil(args[0](context));\n      }\n    case Ops.Round:\n      {\n        return context => Math.round(args[0](context));\n      }\n    case Ops.Sin:\n      {\n        return context => Math.sin(args[0](context));\n      }\n    case Ops.Cos:\n      {\n        return context => Math.cos(args[0](context));\n      }\n    case Ops.Atan:\n      {\n        if (length === 2) {\n          return context => Math.atan2(args[0](context), args[1](context));\n        }\n        return context => Math.atan(args[0](context));\n      }\n    case Ops.Sqrt:\n      {\n        return context => Math.sqrt(args[0](context));\n      }\n    default:\n      {\n        throw new Error(`Unsupported numeric operator ${op}`);\n      }\n  }\n}\n\n/**\n * @param {import('./expression.js').CallExpression} expression The call expression.\n * @param {import('./expression.js').ParsingContext} context The parsing context.\n * @return {ExpressionEvaluator} The evaluator function.\n */\nfunction compileMatchExpression(expression, context) {\n  const length = expression.args.length;\n  const args = new Array(length);\n  for (let i = 0; i < length; ++i) {\n    args[i] = compileExpression(expression.args[i], context);\n  }\n  return context => {\n    const value = args[0](context);\n    for (let i = 1; i < length; i += 2) {\n      if (value === args[i](context)) {\n        return args[i + 1](context);\n      }\n    }\n    return args[length - 1](context);\n  };\n}","map":{"version":3,"names":["LiteralExpression","Ops","overlapsType","parse","typeName","newEvaluationContext","variables","properties","resolution","NaN","buildExpression","encoded","type","context","expression","expected","actual","Error","compileExpression","value","operator","Number","String","compileAssertionExpression","Get","Var","compileAccessorExpression","Resolution","Any","All","Not","compileLogicalExpression","Equal","NotEqual","LessThan","LessThanOrEqualTo","GreaterThan","GreaterThanOrEqualTo","compileComparisonExpression","Multiply","Divide","Add","Subtract","Clamp","Mod","Pow","Abs","Floor","Ceil","Round","Sin","Cos","Atan","Sqrt","compileNumericExpression","Match","compileMatchExpression","length","args","Array","i","nameExpression","name","op","left","right","min","max","Math","pow","abs","floor","ceil","round","sin","cos","atan2","atan","sqrt"],"sources":["E:/Desktop/SceneryPlatform_v3.0_LTS/node_modules/ol/expr/cpu.js"],"sourcesContent":["/**\n * @module ol/expr/cpu\n */\n\nimport {\n  LiteralExpression,\n  Ops,\n  overlapsType,\n  parse,\n  typeName,\n} from './expression.js';\n\n/**\n * @fileoverview This module includes functions to build expressions for evaluation on the CPU.\n * Building is composed of two steps: parsing and compiling.  The parsing step takes an encoded\n * expression and returns an instance of one of the expression classes.  The compiling step takes\n * the expression instance and returns a function that can be evaluated in to return a literal\n * value.  The evaluator function should do as little allocation and work as possible.\n */\n\n/**\n * @typedef {Object} EvaluationContext\n * @property {Object} properties The values for properties used in 'get' expressions.\n * @property {Object} variables The values for variables used in 'var' expressions.\n * @property {number} resolution The map resolution.\n */\n\n/**\n * @return {EvaluationContext} A new evaluation context.\n */\nexport function newEvaluationContext() {\n  return {\n    variables: {},\n    properties: {},\n    resolution: NaN,\n  };\n}\n\n/**\n * @typedef {function(EvaluationContext):import(\"./expression.js\").LiteralValue} ExpressionEvaluator\n */\n\n/**\n * @typedef {function(EvaluationContext):boolean} BooleanEvaluator\n */\n\n/**\n * @typedef {function(EvaluationContext):number} NumberEvaluator\n */\n\n/**\n * @typedef {function(EvaluationContext):string} StringEvaluator\n */\n\n/**\n * @typedef {function(EvaluationContext):(Array<number>|string)} ColorLikeEvaluator\n */\n\n/**\n * @typedef {function(EvaluationContext):Array<number>} NumberArrayEvaluator\n */\n\n/**\n * @typedef {function(EvaluationContext):Array<number>} CoordinateEvaluator\n */\n\n/**\n * @typedef {function(EvaluationContext):(Array<number>|number)} SizeLikeEvaluator\n */\n\n/**\n * @param {import('./expression.js').EncodedExpression} encoded The encoded expression.\n * @param {number} type The expected type.\n * @param {import('./expression.js').ParsingContext} context The parsing context.\n * @return {ExpressionEvaluator} The expression evaluator.\n */\nexport function buildExpression(encoded, type, context) {\n  const expression = parse(encoded, context);\n  if (!overlapsType(type, expression.type)) {\n    const expected = typeName(type);\n    const actual = typeName(expression.type);\n    throw new Error(\n      `Expected expression to be of type ${expected}, got ${actual}`\n    );\n  }\n  return compileExpression(expression, context);\n}\n\n/**\n * @param {import(\"./expression.js\").Expression} expression The expression.\n * @param {import('./expression.js').ParsingContext} context The parsing context.\n * @return {ExpressionEvaluator} The evaluator function.\n */\nfunction compileExpression(expression, context) {\n  if (expression instanceof LiteralExpression) {\n    return function () {\n      return expression.value;\n    };\n  }\n  const operator = expression.operator;\n  switch (operator) {\n    case Ops.Number:\n    case Ops.String: {\n      return compileAssertionExpression(expression, context);\n    }\n    case Ops.Get:\n    case Ops.Var: {\n      return compileAccessorExpression(expression, context);\n    }\n    case Ops.Resolution: {\n      return (context) => context.resolution;\n    }\n    case Ops.Any:\n    case Ops.All:\n    case Ops.Not: {\n      return compileLogicalExpression(expression, context);\n    }\n    case Ops.Equal:\n    case Ops.NotEqual:\n    case Ops.LessThan:\n    case Ops.LessThanOrEqualTo:\n    case Ops.GreaterThan:\n    case Ops.GreaterThanOrEqualTo: {\n      return compileComparisonExpression(expression, context);\n    }\n    case Ops.Multiply:\n    case Ops.Divide:\n    case Ops.Add:\n    case Ops.Subtract:\n    case Ops.Clamp:\n    case Ops.Mod:\n    case Ops.Pow:\n    case Ops.Abs:\n    case Ops.Floor:\n    case Ops.Ceil:\n    case Ops.Round:\n    case Ops.Sin:\n    case Ops.Cos:\n    case Ops.Atan:\n    case Ops.Sqrt: {\n      return compileNumericExpression(expression, context);\n    }\n    case Ops.Match: {\n      return compileMatchExpression(expression, context);\n    }\n    default: {\n      throw new Error(`Unsupported operator ${operator}`);\n    }\n  }\n}\n\n/**\n * @param {import('./expression.js').CallExpression} expression The call expression.\n * @param {import('./expression.js').ParsingContext} context The parsing context.\n * @return {ExpressionEvaluator} The evaluator function.\n */\nfunction compileAssertionExpression(expression, context) {\n  const type = expression.operator;\n  const length = expression.args.length;\n\n  const args = new Array(length);\n  for (let i = 0; i < length; ++i) {\n    args[i] = compileExpression(expression.args[i], context);\n  }\n  switch (type) {\n    case Ops.Number:\n    case Ops.String: {\n      return (context) => {\n        for (let i = 0; i < length; ++i) {\n          const value = args[i](context);\n          if (typeof value === type) {\n            return value;\n          }\n        }\n        throw new Error(`Expected one of the values to be a ${type}`);\n      };\n    }\n    default: {\n      throw new Error(`Unsupported assertion operator ${type}`);\n    }\n  }\n}\n\n/**\n * @param {import('./expression.js').CallExpression} expression The call expression.\n * @param {import('./expression.js').ParsingContext} context The parsing context.\n * @return {ExpressionEvaluator} The evaluator function.\n */\nfunction compileAccessorExpression(expression, context) {\n  const nameExpression = expression.args[0];\n  if (!(nameExpression instanceof LiteralExpression)) {\n    throw new Error('Expected literal name');\n  }\n  const name = nameExpression.value;\n  if (typeof name !== 'string') {\n    throw new Error('Expected string name');\n  }\n  switch (expression.operator) {\n    case Ops.Get: {\n      return (context) => context.properties[name];\n    }\n    case Ops.Var: {\n      return (context) => context.variables[name];\n    }\n    default: {\n      throw new Error(`Unsupported accessor operator ${expression.operator}`);\n    }\n  }\n}\n\n/**\n * @param {import('./expression.js').CallExpression} expression The call expression.\n * @param {import('./expression.js').ParsingContext} context The parsing context.\n * @return {BooleanEvaluator} The evaluator function.\n */\nfunction compileComparisonExpression(expression, context) {\n  const op = expression.operator;\n  const left = compileExpression(expression.args[0], context);\n  const right = compileExpression(expression.args[1], context);\n  switch (op) {\n    case Ops.Equal: {\n      return (context) => left(context) === right(context);\n    }\n    case Ops.NotEqual: {\n      return (context) => left(context) !== right(context);\n    }\n    case Ops.LessThan: {\n      return (context) => left(context) < right(context);\n    }\n    case Ops.LessThanOrEqualTo: {\n      return (context) => left(context) <= right(context);\n    }\n    case Ops.GreaterThan: {\n      return (context) => left(context) > right(context);\n    }\n    case Ops.GreaterThanOrEqualTo: {\n      return (context) => left(context) >= right(context);\n    }\n    default: {\n      throw new Error(`Unsupported comparison operator ${op}`);\n    }\n  }\n}\n\n/**\n * @param {import('./expression.js').CallExpression} expression The call expression.\n * @param {import('./expression.js').ParsingContext} context The parsing context.\n * @return {BooleanEvaluator} The evaluator function.\n */\nfunction compileLogicalExpression(expression, context) {\n  const op = expression.operator;\n  const length = expression.args.length;\n\n  const args = new Array(length);\n  for (let i = 0; i < length; ++i) {\n    args[i] = compileExpression(expression.args[i], context);\n  }\n  switch (op) {\n    case Ops.Any: {\n      return (context) => {\n        for (let i = 0; i < length; ++i) {\n          if (args[i](context)) {\n            return true;\n          }\n        }\n        return false;\n      };\n    }\n    case Ops.All: {\n      return (context) => {\n        for (let i = 0; i < length; ++i) {\n          if (!args[i](context)) {\n            return false;\n          }\n        }\n        return true;\n      };\n    }\n    case Ops.Not: {\n      return (context) => !args[0](context);\n    }\n    default: {\n      throw new Error(`Unsupported logical operator ${op}`);\n    }\n  }\n}\n\n/**\n * @param {import('./expression.js').CallExpression} expression The call expression.\n * @param {import('./expression.js').ParsingContext} context The parsing context.\n * @return {NumberEvaluator} The evaluator function.\n */\nfunction compileNumericExpression(expression, context) {\n  const op = expression.operator;\n  const length = expression.args.length;\n\n  const args = new Array(length);\n  for (let i = 0; i < length; ++i) {\n    args[i] = compileExpression(expression.args[i], context);\n  }\n  switch (op) {\n    case Ops.Multiply: {\n      return (context) => {\n        let value = 1;\n        for (let i = 0; i < length; ++i) {\n          value *= args[i](context);\n        }\n        return value;\n      };\n    }\n    case Ops.Divide: {\n      return (context) => args[0](context) / args[1](context);\n    }\n    case Ops.Add: {\n      return (context) => {\n        let value = 0;\n        for (let i = 0; i < length; ++i) {\n          value += args[i](context);\n        }\n        return value;\n      };\n    }\n    case Ops.Subtract: {\n      return (context) => args[0](context) - args[1](context);\n    }\n    case Ops.Clamp: {\n      return (context) => {\n        const value = args[0](context);\n        const min = args[1](context);\n        if (value < min) {\n          return min;\n        }\n        const max = args[2](context);\n        if (value > max) {\n          return max;\n        }\n        return value;\n      };\n    }\n    case Ops.Mod: {\n      return (context) => args[0](context) % args[1](context);\n    }\n    case Ops.Pow: {\n      return (context) => Math.pow(args[0](context), args[1](context));\n    }\n    case Ops.Abs: {\n      return (context) => Math.abs(args[0](context));\n    }\n    case Ops.Floor: {\n      return (context) => Math.floor(args[0](context));\n    }\n    case Ops.Ceil: {\n      return (context) => Math.ceil(args[0](context));\n    }\n    case Ops.Round: {\n      return (context) => Math.round(args[0](context));\n    }\n    case Ops.Sin: {\n      return (context) => Math.sin(args[0](context));\n    }\n    case Ops.Cos: {\n      return (context) => Math.cos(args[0](context));\n    }\n    case Ops.Atan: {\n      if (length === 2) {\n        return (context) => Math.atan2(args[0](context), args[1](context));\n      }\n      return (context) => Math.atan(args[0](context));\n    }\n    case Ops.Sqrt: {\n      return (context) => Math.sqrt(args[0](context));\n    }\n    default: {\n      throw new Error(`Unsupported numeric operator ${op}`);\n    }\n  }\n}\n\n/**\n * @param {import('./expression.js').CallExpression} expression The call expression.\n * @param {import('./expression.js').ParsingContext} context The parsing context.\n * @return {ExpressionEvaluator} The evaluator function.\n */\nfunction compileMatchExpression(expression, context) {\n  const length = expression.args.length;\n  const args = new Array(length);\n  for (let i = 0; i < length; ++i) {\n    args[i] = compileExpression(expression.args[i], context);\n  }\n  return (context) => {\n    const value = args[0](context);\n    for (let i = 1; i < length; i += 2) {\n      if (value === args[i](context)) {\n        return args[i + 1](context);\n      }\n    }\n    return args[length - 1](context);\n  };\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}