{"ast":null,"code":"/**\n * @module ol/resolutionconstraint\n */\nimport { clamp } from './math.js';\nimport { getHeight, getWidth } from './extent.js';\nimport { linearFindNearest } from './array.js';\n\n/**\n * @typedef {function((number|undefined), number, import(\"./size.js\").Size, boolean=): (number|undefined)} Type\n */\n\n/**\n * Returns a modified resolution taking into account the viewport size and maximum\n * allowed extent.\n * @param {number} resolution Resolution\n * @param {import(\"./extent.js\").Extent} maxExtent Maximum allowed extent.\n * @param {import(\"./size.js\").Size} viewportSize Viewport size.\n * @param {boolean} showFullExtent Whether to show the full extent.\n * @return {number} Capped resolution.\n */\nfunction getViewportClampedResolution(resolution, maxExtent, viewportSize, showFullExtent) {\n  const xResolution = getWidth(maxExtent) / viewportSize[0];\n  const yResolution = getHeight(maxExtent) / viewportSize[1];\n  if (showFullExtent) {\n    return Math.min(resolution, Math.max(xResolution, yResolution));\n  }\n  return Math.min(resolution, Math.min(xResolution, yResolution));\n}\n\n/**\n * Returns a modified resolution to be between maxResolution and minResolution while\n * still allowing the value to be slightly out of bounds.\n * Note: the computation is based on the logarithm function (ln):\n *  - at 1, ln(x) is 0\n *  - above 1, ln(x) keeps increasing but at a much slower pace than x\n * The final result is clamped to prevent getting too far away from bounds.\n * @param {number} resolution Resolution.\n * @param {number} maxResolution Max resolution.\n * @param {number} minResolution Min resolution.\n * @return {number} Smoothed resolution.\n */\nfunction getSmoothClampedResolution(resolution, maxResolution, minResolution) {\n  let result = Math.min(resolution, maxResolution);\n  const ratio = 50;\n  result *= Math.log(1 + ratio * Math.max(0, resolution / maxResolution - 1)) / ratio + 1;\n  if (minResolution) {\n    result = Math.max(result, minResolution);\n    result /= Math.log(1 + ratio * Math.max(0, minResolution / resolution - 1)) / ratio + 1;\n  }\n  return clamp(result, minResolution / 2, maxResolution * 2);\n}\n\n/**\n * @param {Array<number>} resolutions Resolutions.\n * @param {boolean} [smooth] If true, the view will be able to slightly exceed resolution limits. Default: true.\n * @param {import(\"./extent.js\").Extent} [maxExtent] Maximum allowed extent.\n * @param {boolean} [showFullExtent] If true, allows us to show the full extent. Default: false.\n * @return {Type} Zoom function.\n */\nexport function createSnapToResolutions(resolutions, smooth, maxExtent, showFullExtent) {\n  smooth = smooth !== undefined ? smooth : true;\n  return (\n    /**\n     * @param {number|undefined} resolution Resolution.\n     * @param {number} direction Direction.\n     * @param {import(\"./size.js\").Size} size Viewport size.\n     * @param {boolean} [isMoving] True if an interaction or animation is in progress.\n     * @return {number|undefined} Resolution.\n     */\n    function (resolution, direction, size, isMoving) {\n      if (resolution !== undefined) {\n        const maxResolution = resolutions[0];\n        const minResolution = resolutions[resolutions.length - 1];\n        const cappedMaxRes = maxExtent ? getViewportClampedResolution(maxResolution, maxExtent, size, showFullExtent) : maxResolution;\n\n        // during interacting or animating, allow intermediary values\n        if (isMoving) {\n          if (!smooth) {\n            return clamp(resolution, minResolution, cappedMaxRes);\n          }\n          return getSmoothClampedResolution(resolution, cappedMaxRes, minResolution);\n        }\n        const capped = Math.min(cappedMaxRes, resolution);\n        const z = Math.floor(linearFindNearest(resolutions, capped, direction));\n        if (resolutions[z] > cappedMaxRes && z < resolutions.length - 1) {\n          return resolutions[z + 1];\n        }\n        return resolutions[z];\n      }\n      return undefined;\n    }\n  );\n}\n\n/**\n * @param {number} power Power.\n * @param {number} maxResolution Maximum resolution.\n * @param {number} [minResolution] Minimum resolution.\n * @param {boolean} [smooth] If true, the view will be able to slightly exceed resolution limits. Default: true.\n * @param {import(\"./extent.js\").Extent} [maxExtent] Maximum allowed extent.\n * @param {boolean} [showFullExtent] If true, allows us to show the full extent. Default: false.\n * @return {Type} Zoom function.\n */\nexport function createSnapToPower(power, maxResolution, minResolution, smooth, maxExtent, showFullExtent) {\n  smooth = smooth !== undefined ? smooth : true;\n  minResolution = minResolution !== undefined ? minResolution : 0;\n  return (\n    /**\n     * @param {number|undefined} resolution Resolution.\n     * @param {number} direction Direction.\n     * @param {import(\"./size.js\").Size} size Viewport size.\n     * @param {boolean} [isMoving] True if an interaction or animation is in progress.\n     * @return {number|undefined} Resolution.\n     */\n    function (resolution, direction, size, isMoving) {\n      if (resolution !== undefined) {\n        const cappedMaxRes = maxExtent ? getViewportClampedResolution(maxResolution, maxExtent, size, showFullExtent) : maxResolution;\n\n        // during interacting or animating, allow intermediary values\n        if (isMoving) {\n          if (!smooth) {\n            return clamp(resolution, minResolution, cappedMaxRes);\n          }\n          return getSmoothClampedResolution(resolution, cappedMaxRes, minResolution);\n        }\n        const tolerance = 1e-9;\n        const minZoomLevel = Math.ceil(Math.log(maxResolution / cappedMaxRes) / Math.log(power) - tolerance);\n        const offset = -direction * (0.5 - tolerance) + 0.5;\n        const capped = Math.min(cappedMaxRes, resolution);\n        const cappedZoomLevel = Math.floor(Math.log(maxResolution / capped) / Math.log(power) + offset);\n        const zoomLevel = Math.max(minZoomLevel, cappedZoomLevel);\n        const newResolution = maxResolution / Math.pow(power, zoomLevel);\n        return clamp(newResolution, minResolution, cappedMaxRes);\n      }\n      return undefined;\n    }\n  );\n}\n\n/**\n * @param {number} maxResolution Max resolution.\n * @param {number} minResolution Min resolution.\n * @param {boolean} [smooth] If true, the view will be able to slightly exceed resolution limits. Default: true.\n * @param {import(\"./extent.js\").Extent} [maxExtent] Maximum allowed extent.\n * @param {boolean} [showFullExtent] If true, allows us to show the full extent. Default: false.\n * @return {Type} Zoom function.\n */\nexport function createMinMaxResolution(maxResolution, minResolution, smooth, maxExtent, showFullExtent) {\n  smooth = smooth !== undefined ? smooth : true;\n  return (\n    /**\n     * @param {number|undefined} resolution Resolution.\n     * @param {number} direction Direction.\n     * @param {import(\"./size.js\").Size} size Viewport size.\n     * @param {boolean} [isMoving] True if an interaction or animation is in progress.\n     * @return {number|undefined} Resolution.\n     */\n    function (resolution, direction, size, isMoving) {\n      if (resolution !== undefined) {\n        const cappedMaxRes = maxExtent ? getViewportClampedResolution(maxResolution, maxExtent, size, showFullExtent) : maxResolution;\n        if (!smooth || !isMoving) {\n          return clamp(resolution, minResolution, cappedMaxRes);\n        }\n        return getSmoothClampedResolution(resolution, cappedMaxRes, minResolution);\n      }\n      return undefined;\n    }\n  );\n}","map":{"version":3,"names":["clamp","getHeight","getWidth","linearFindNearest","getViewportClampedResolution","resolution","maxExtent","viewportSize","showFullExtent","xResolution","yResolution","Math","min","max","getSmoothClampedResolution","maxResolution","minResolution","result","ratio","log","createSnapToResolutions","resolutions","smooth","undefined","direction","size","isMoving","length","cappedMaxRes","capped","z","floor","createSnapToPower","power","tolerance","minZoomLevel","ceil","offset","cappedZoomLevel","zoomLevel","newResolution","pow","createMinMaxResolution"],"sources":["E:/Desktop/scenerymonitor/node_modules/ol/resolutionconstraint.js"],"sourcesContent":["/**\n * @module ol/resolutionconstraint\n */\nimport {clamp} from './math.js';\nimport {getHeight, getWidth} from './extent.js';\nimport {linearFindNearest} from './array.js';\n\n/**\n * @typedef {function((number|undefined), number, import(\"./size.js\").Size, boolean=): (number|undefined)} Type\n */\n\n/**\n * Returns a modified resolution taking into account the viewport size and maximum\n * allowed extent.\n * @param {number} resolution Resolution\n * @param {import(\"./extent.js\").Extent} maxExtent Maximum allowed extent.\n * @param {import(\"./size.js\").Size} viewportSize Viewport size.\n * @param {boolean} showFullExtent Whether to show the full extent.\n * @return {number} Capped resolution.\n */\nfunction getViewportClampedResolution(\n  resolution,\n  maxExtent,\n  viewportSize,\n  showFullExtent\n) {\n  const xResolution = getWidth(maxExtent) / viewportSize[0];\n  const yResolution = getHeight(maxExtent) / viewportSize[1];\n\n  if (showFullExtent) {\n    return Math.min(resolution, Math.max(xResolution, yResolution));\n  }\n  return Math.min(resolution, Math.min(xResolution, yResolution));\n}\n\n/**\n * Returns a modified resolution to be between maxResolution and minResolution while\n * still allowing the value to be slightly out of bounds.\n * Note: the computation is based on the logarithm function (ln):\n *  - at 1, ln(x) is 0\n *  - above 1, ln(x) keeps increasing but at a much slower pace than x\n * The final result is clamped to prevent getting too far away from bounds.\n * @param {number} resolution Resolution.\n * @param {number} maxResolution Max resolution.\n * @param {number} minResolution Min resolution.\n * @return {number} Smoothed resolution.\n */\nfunction getSmoothClampedResolution(resolution, maxResolution, minResolution) {\n  let result = Math.min(resolution, maxResolution);\n  const ratio = 50;\n\n  result *=\n    Math.log(1 + ratio * Math.max(0, resolution / maxResolution - 1)) / ratio +\n    1;\n  if (minResolution) {\n    result = Math.max(result, minResolution);\n    result /=\n      Math.log(1 + ratio * Math.max(0, minResolution / resolution - 1)) /\n        ratio +\n      1;\n  }\n  return clamp(result, minResolution / 2, maxResolution * 2);\n}\n\n/**\n * @param {Array<number>} resolutions Resolutions.\n * @param {boolean} [smooth] If true, the view will be able to slightly exceed resolution limits. Default: true.\n * @param {import(\"./extent.js\").Extent} [maxExtent] Maximum allowed extent.\n * @param {boolean} [showFullExtent] If true, allows us to show the full extent. Default: false.\n * @return {Type} Zoom function.\n */\nexport function createSnapToResolutions(\n  resolutions,\n  smooth,\n  maxExtent,\n  showFullExtent\n) {\n  smooth = smooth !== undefined ? smooth : true;\n  return (\n    /**\n     * @param {number|undefined} resolution Resolution.\n     * @param {number} direction Direction.\n     * @param {import(\"./size.js\").Size} size Viewport size.\n     * @param {boolean} [isMoving] True if an interaction or animation is in progress.\n     * @return {number|undefined} Resolution.\n     */\n    function (resolution, direction, size, isMoving) {\n      if (resolution !== undefined) {\n        const maxResolution = resolutions[0];\n        const minResolution = resolutions[resolutions.length - 1];\n        const cappedMaxRes = maxExtent\n          ? getViewportClampedResolution(\n              maxResolution,\n              maxExtent,\n              size,\n              showFullExtent\n            )\n          : maxResolution;\n\n        // during interacting or animating, allow intermediary values\n        if (isMoving) {\n          if (!smooth) {\n            return clamp(resolution, minResolution, cappedMaxRes);\n          }\n          return getSmoothClampedResolution(\n            resolution,\n            cappedMaxRes,\n            minResolution\n          );\n        }\n\n        const capped = Math.min(cappedMaxRes, resolution);\n        const z = Math.floor(linearFindNearest(resolutions, capped, direction));\n        if (resolutions[z] > cappedMaxRes && z < resolutions.length - 1) {\n          return resolutions[z + 1];\n        }\n        return resolutions[z];\n      }\n      return undefined;\n    }\n  );\n}\n\n/**\n * @param {number} power Power.\n * @param {number} maxResolution Maximum resolution.\n * @param {number} [minResolution] Minimum resolution.\n * @param {boolean} [smooth] If true, the view will be able to slightly exceed resolution limits. Default: true.\n * @param {import(\"./extent.js\").Extent} [maxExtent] Maximum allowed extent.\n * @param {boolean} [showFullExtent] If true, allows us to show the full extent. Default: false.\n * @return {Type} Zoom function.\n */\nexport function createSnapToPower(\n  power,\n  maxResolution,\n  minResolution,\n  smooth,\n  maxExtent,\n  showFullExtent\n) {\n  smooth = smooth !== undefined ? smooth : true;\n  minResolution = minResolution !== undefined ? minResolution : 0;\n\n  return (\n    /**\n     * @param {number|undefined} resolution Resolution.\n     * @param {number} direction Direction.\n     * @param {import(\"./size.js\").Size} size Viewport size.\n     * @param {boolean} [isMoving] True if an interaction or animation is in progress.\n     * @return {number|undefined} Resolution.\n     */\n    function (resolution, direction, size, isMoving) {\n      if (resolution !== undefined) {\n        const cappedMaxRes = maxExtent\n          ? getViewportClampedResolution(\n              maxResolution,\n              maxExtent,\n              size,\n              showFullExtent\n            )\n          : maxResolution;\n\n        // during interacting or animating, allow intermediary values\n        if (isMoving) {\n          if (!smooth) {\n            return clamp(resolution, minResolution, cappedMaxRes);\n          }\n          return getSmoothClampedResolution(\n            resolution,\n            cappedMaxRes,\n            minResolution\n          );\n        }\n\n        const tolerance = 1e-9;\n        const minZoomLevel = Math.ceil(\n          Math.log(maxResolution / cappedMaxRes) / Math.log(power) - tolerance\n        );\n        const offset = -direction * (0.5 - tolerance) + 0.5;\n        const capped = Math.min(cappedMaxRes, resolution);\n        const cappedZoomLevel = Math.floor(\n          Math.log(maxResolution / capped) / Math.log(power) + offset\n        );\n        const zoomLevel = Math.max(minZoomLevel, cappedZoomLevel);\n        const newResolution = maxResolution / Math.pow(power, zoomLevel);\n        return clamp(newResolution, minResolution, cappedMaxRes);\n      }\n      return undefined;\n    }\n  );\n}\n\n/**\n * @param {number} maxResolution Max resolution.\n * @param {number} minResolution Min resolution.\n * @param {boolean} [smooth] If true, the view will be able to slightly exceed resolution limits. Default: true.\n * @param {import(\"./extent.js\").Extent} [maxExtent] Maximum allowed extent.\n * @param {boolean} [showFullExtent] If true, allows us to show the full extent. Default: false.\n * @return {Type} Zoom function.\n */\nexport function createMinMaxResolution(\n  maxResolution,\n  minResolution,\n  smooth,\n  maxExtent,\n  showFullExtent\n) {\n  smooth = smooth !== undefined ? smooth : true;\n\n  return (\n    /**\n     * @param {number|undefined} resolution Resolution.\n     * @param {number} direction Direction.\n     * @param {import(\"./size.js\").Size} size Viewport size.\n     * @param {boolean} [isMoving] True if an interaction or animation is in progress.\n     * @return {number|undefined} Resolution.\n     */\n    function (resolution, direction, size, isMoving) {\n      if (resolution !== undefined) {\n        const cappedMaxRes = maxExtent\n          ? getViewportClampedResolution(\n              maxResolution,\n              maxExtent,\n              size,\n              showFullExtent\n            )\n          : maxResolution;\n\n        if (!smooth || !isMoving) {\n          return clamp(resolution, minResolution, cappedMaxRes);\n        }\n        return getSmoothClampedResolution(\n          resolution,\n          cappedMaxRes,\n          minResolution\n        );\n      }\n      return undefined;\n    }\n  );\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}