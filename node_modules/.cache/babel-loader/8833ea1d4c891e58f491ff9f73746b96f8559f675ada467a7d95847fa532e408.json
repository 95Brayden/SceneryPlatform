{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\n/**\n * Utilities for parsing literal style objects\n * @module ol/webgl/styleparser\n */\nimport { ShaderBuilder } from './ShaderBuilder.js';\nimport { ValueTypes, arrayToGlsl, expressionToGlsl, getStringNumberEquivalent, stringToGlsl, uniformNameForVariable } from '../style/expressions.js';\nimport { asArray } from '../color.js';\nimport { getUid } from '../util.js';\n\n/**\n * Packs all components of a color into a two-floats array\n * @param {import(\"../color.js\").Color|string} color Color as array of numbers or string\n * @return {Array<number>} Vec2 array containing the color in compressed form\n */\nexport function packColor(color) {\n  const array = asArray(color);\n  const r = array[0] * 256;\n  const g = array[1];\n  const b = array[2] * 256;\n  const a = Math.round(array[3] * 255);\n  return [r + g, b + a];\n}\nconst UNPACK_COLOR_FN = `vec4 unpackColor(vec2 packedColor) {\n  return fract(packedColor[1] / 256.0) * vec4(\n    fract(floor(packedColor[0] / 256.0) / 256.0),\n    fract(packedColor[0] / 256.0),\n    fract(floor(packedColor[1] / 256.0) / 256.0),\n    1.0\n  );\n}`;\n\n/**\n * @param {ValueTypes} type Value type\n * @return {1|2|3|4} The amount of components for this value\n */\nfunction getGlslSizeFromType(type) {\n  if (type === ValueTypes.COLOR) {\n    return 2;\n  }\n  if (type === ValueTypes.NUMBER_ARRAY) {\n    return 4;\n  }\n  return 1;\n}\n\n/**\n * @param {ValueTypes} type Value type\n * @return {'float'|'vec2'|'vec3'|'vec4'} The corresponding GLSL type for this value\n */\nfunction getGlslTypeFromType(type) {\n  const size = getGlslSizeFromType(type);\n  if (size > 1) {\n    return (/** @type {'vec2'|'vec3'|'vec4'} */`vec${size}`\n    );\n  }\n  return 'float';\n}\n\n/**\n * @param {import(\"../style/literal.js\").LiteralStyle} style Style\n * @param {ShaderBuilder} builder Shader builder\n * @param {import(\"../style/expressions.js\").ParsingContext} vertContext Vertex shader parsing context\n * @param {'shape-'|'circle-'|'icon-'} prefix Properties prefix\n */\nfunction parseCommonSymbolProperties(style, builder, vertContext, prefix) {\n  let radius;\n  if (`${prefix}radius` in style && prefix !== 'icon-') {\n    radius = expressionToGlsl(vertContext, style[`${prefix}radius`], ValueTypes.NUMBER);\n  } else if (`${prefix}radius1` in style && prefix === 'shape-') {\n    radius = expressionToGlsl(vertContext, style[`${prefix}radius1`], ValueTypes.NUMBER);\n  }\n  if (radius !== undefined) {\n    if (`${prefix}stroke-width` in style) {\n      radius = `(${radius} + ${expressionToGlsl(vertContext, style[`${prefix}stroke-width`], ValueTypes.NUMBER)} * 0.5)`;\n    }\n    builder.setSymbolSizeExpression(`vec2(${radius} * 2. + 0.5)`); // adding some padding for antialiasing\n  }\n\n  if (`${prefix}scale` in style) {\n    const scale = expressionToGlsl(vertContext, style[`${prefix}scale`], ValueTypes.NUMBER | ValueTypes.NUMBER_ARRAY);\n    builder.setSymbolSizeExpression(`${builder.getSymbolSizeExpression()} * ${scale}`);\n  }\n  if (`${prefix}displacement` in style) {\n    builder.setSymbolOffsetExpression(expressionToGlsl(vertContext, style[`${prefix}displacement`], ValueTypes.NUMBER_ARRAY));\n  }\n  if (`${prefix}rotation` in style) {\n    builder.setSymbolRotationExpression(expressionToGlsl(vertContext, style[`${prefix}rotation`], ValueTypes.NUMBER));\n  }\n  if (`${prefix}rotate-with-view` in style) {\n    builder.setSymbolRotateWithView(!!style[`${prefix}rotate-with-view`]);\n  }\n}\n\n/**\n * @param {string} distanceField The distance field expression\n * @param {string|null} fillColor The fill color expression; null if no fill\n * @param {string|null} strokeColor The stroke color expression; null if no stroke\n * @param {string|null} strokeWidth The stroke width expression; null if no stroke\n * @param {string|null} opacity The opacity expression; null if no stroke\n * @return {string} The final color expression, based on the distance field and given params\n */\nfunction getColorFromDistanceField(distanceField, fillColor, strokeColor, strokeWidth, opacity) {\n  let color = 'vec4(0.)';\n  if (fillColor !== null) {\n    color = fillColor;\n  }\n  if (strokeColor !== null && strokeWidth !== null) {\n    const strokeFillRatio = `smoothstep(-${strokeWidth} + 0.63, -${strokeWidth} - 0.58, ${distanceField})`;\n    color = `mix(${strokeColor}, ${color}, ${strokeFillRatio})`;\n  }\n  const shapeOpacity = `(1.0 - smoothstep(-0.63, 0.58, ${distanceField}))`;\n  let result = `${color} * ${shapeOpacity}`;\n  if (opacity !== null) {\n    result = `${result} * ${opacity}`;\n  }\n  return result;\n}\n\n/**\n * @param {import(\"../style/literal.js\").LiteralStyle} style Style\n * @param {ShaderBuilder} builder Shader builder\n * @param {Object<string,import(\"../webgl/Helper\").UniformValue>} uniforms Uniforms\n * @param {import(\"../style/expressions.js\").ParsingContext} vertContext Vertex shader parsing context\n * @param {import(\"../style/expressions.js\").ParsingContext} fragContext Fragment shader parsing context\n */\nfunction parseCircleProperties(style, builder, uniforms, vertContext, fragContext) {\n  // this function takes in screen coordinates in pixels and returns the signed distance field\n  // (0 on the boundary, negative inside the circle, positive outside, values in pixels)\n  fragContext.functions['circleDistanceField'] = `float circleDistanceField(vec2 point, float radius) {\n  return length(point) - radius;\n}`;\n  parseCommonSymbolProperties(style, builder, vertContext, 'circle-');\n\n  // OPACITY\n  let opacity = null;\n  if ('circle-opacity' in style) {\n    opacity = expressionToGlsl(fragContext, style['circle-opacity'], ValueTypes.NUMBER);\n  }\n\n  // SCALE\n  let currentPoint = 'coordsPx';\n  if ('circle-scale' in style) {\n    const scale = expressionToGlsl(fragContext, style['circle-scale'], ValueTypes.NUMBER | ValueTypes.NUMBER_ARRAY);\n    currentPoint = `coordsPx / ${scale}`;\n  }\n\n  // FILL COLOR\n  let fillColor = null;\n  if ('circle-fill-color' in style) {\n    fillColor = expressionToGlsl(fragContext, style['circle-fill-color'], ValueTypes.COLOR);\n  }\n\n  // STROKE COLOR\n  let strokeColor = null;\n  if ('circle-stroke-color' in style) {\n    strokeColor = expressionToGlsl(fragContext, style['circle-stroke-color'], ValueTypes.COLOR);\n  }\n\n  // RADIUS\n  let radius = expressionToGlsl(fragContext, style['circle-radius'], ValueTypes.NUMBER);\n\n  // STROKE WIDTH\n  let strokeWidth = null;\n  if ('circle-stroke-width' in style) {\n    strokeWidth = expressionToGlsl(fragContext, style['circle-stroke-width'], ValueTypes.NUMBER);\n    radius = `(${radius} + ${strokeWidth} * 0.5)`;\n  }\n\n  // FINAL COLOR\n  const distanceField = `circleDistanceField(${currentPoint}, ${radius})`;\n  const colorExpression = getColorFromDistanceField(distanceField, fillColor, strokeColor, strokeWidth, opacity);\n  builder.setSymbolColorExpression(colorExpression);\n}\n\n/**\n * @param {import(\"../style/literal.js\").LiteralStyle} style Style\n * @param {ShaderBuilder} builder Shader builder\n * @param {Object<string,import(\"../webgl/Helper\").UniformValue>} uniforms Uniforms\n * @param {import(\"../style/expressions.js\").ParsingContext} vertContext Vertex shader parsing context\n * @param {import(\"../style/expressions.js\").ParsingContext} fragContext Fragment shader parsing context\n */\nfunction parseShapeProperties(style, builder, uniforms, vertContext, fragContext) {\n  fragContext.functions['round'] = `float round(float v) {\n  return sign(v) * floor(abs(v) + 0.5);\n}`;\n\n  // these functions take in screen coordinates in pixels and returns the signed distance field\n  // (0 on the boundary, negative inside the circle, positive outside, values in pixels)\n  // inspired by https://github.com/zranger1/PixelblazePatterns/blob/master/Toolkit/sdf2d.md#n-sided-regular-polygon\n  fragContext.functions['starDistanceField'] = `float starDistanceField(vec2 point, float numPoints, float radiusIn, float radiusOut, float angle) {\n  float startAngle = -PI * 0.5 + angle; // tip starts upwards and rotates clockwise with angle\n  float c = cos(startAngle);\n  float s = sin(startAngle);\n  vec2 pointRotated = vec2(c * point.x - s * point.y, s * point.x + c * point.y); \n  float alpha = TWO_PI / numPoints; // the angle of one sector\n  float beta = atan(pointRotated.y, pointRotated.x);\n  float gamma = round(beta / alpha) * alpha; // angle in sector\n  c = cos(-gamma);\n  s = sin(-gamma);\n  vec2 inSector = vec2(c * pointRotated.x - s * pointRotated.y, abs(s * pointRotated.x + c * pointRotated.y));\n  vec2 tipToPoint = inSector + vec2(-radiusOut, 0.);\n  vec2 edgeNormal = vec2(radiusIn * sin(alpha * 0.5), -radiusIn * cos(alpha * 0.5) + radiusOut);\n  return dot(normalize(edgeNormal), tipToPoint);\n}`;\n  fragContext.functions['regularDistanceField'] = `float regularDistanceField(vec2 point, float numPoints, float radius, float angle) {\n  float startAngle = -PI * 0.5 + angle; // tip starts upwards and rotates clockwise with angle\n  float c = cos(startAngle);\n  float s = sin(startAngle);\n  vec2 pointRotated = vec2(c * point.x - s * point.y, s * point.x + c * point.y); \n  float alpha = TWO_PI / numPoints; // the angle of one sector\n  float radiusIn = radius * cos(PI / numPoints);\n  float beta = atan(pointRotated.y, pointRotated.x);\n  float gamma = round((beta - alpha * 0.5) / alpha) * alpha + alpha * 0.5; // angle in sector from mid\n  c = cos(-gamma);\n  s = sin(-gamma);\n  vec2 inSector = vec2(c * pointRotated.x - s * pointRotated.y, abs(s * pointRotated.x + c * pointRotated.y));\n  return inSector.x - radiusIn;\n}`;\n  parseCommonSymbolProperties(style, builder, vertContext, 'shape-');\n\n  // OPACITY\n  let opacity = null;\n  if ('shape-opacity' in style) {\n    opacity = expressionToGlsl(fragContext, style['shape-opacity'], ValueTypes.NUMBER);\n  }\n\n  // SCALE\n  let currentPoint = 'coordsPx';\n  if ('shape-scale' in style) {\n    const scale = expressionToGlsl(fragContext, style['shape-scale'], ValueTypes.NUMBER | ValueTypes.NUMBER_ARRAY);\n    currentPoint = `coordsPx / ${scale}`;\n  }\n\n  // FILL COLOR\n  let fillColor = null;\n  if ('shape-fill-color' in style) {\n    fillColor = expressionToGlsl(fragContext, style['shape-fill-color'], ValueTypes.COLOR);\n  }\n\n  // STROKE COLOR\n  let strokeColor = null;\n  if ('shape-stroke-color' in style) {\n    strokeColor = expressionToGlsl(fragContext, style['shape-stroke-color'], ValueTypes.COLOR);\n  }\n\n  // STROKE WIDTH\n  let strokeWidth = null;\n  if ('shape-stroke-width' in style) {\n    strokeWidth = expressionToGlsl(fragContext, style['shape-stroke-width'], ValueTypes.NUMBER);\n  }\n\n  // SHAPE TYPE\n  const numPoints = expressionToGlsl(fragContext, style['shape-points'], ValueTypes.NUMBER);\n  let angle = '0.';\n  if ('shape-angle' in style) {\n    angle = expressionToGlsl(fragContext, style['shape-angle'], ValueTypes.NUMBER);\n  }\n  let shapeField;\n  if ('shape-radius' in style) {\n    let radius = expressionToGlsl(fragContext, style['shape-radius'], ValueTypes.NUMBER);\n    if (strokeWidth !== null) {\n      radius = `${radius} + ${strokeWidth} * 0.5`;\n    }\n    shapeField = `regularDistanceField(${currentPoint}, ${numPoints}, ${radius}, ${angle})`;\n  } else {\n    let radiusOuter = expressionToGlsl(fragContext, style['shape-radius1'], ValueTypes.NUMBER);\n    let radiusInner = expressionToGlsl(fragContext, style['shape-radius2'], ValueTypes.NUMBER);\n    if (strokeWidth !== null) {\n      radiusOuter = `${radiusOuter} + ${strokeWidth} * 0.5`;\n      radiusInner = `${radiusInner} + ${strokeWidth} * 0.5`;\n    }\n    shapeField = `starDistanceField(${currentPoint}, ${numPoints}, ${radiusInner}, ${radiusOuter}, ${angle})`;\n  }\n\n  // FINAL COLOR\n  const colorExpression = getColorFromDistanceField(shapeField, fillColor, strokeColor, strokeWidth, opacity);\n  builder.setSymbolColorExpression(colorExpression);\n}\n\n/**\n * @param {import(\"../style/literal.js\").LiteralStyle} style Style\n * @param {ShaderBuilder} builder Shader builder\n * @param {Object<string,import(\"../webgl/Helper\").UniformValue>} uniforms Uniforms\n * @param {import(\"../style/expressions.js\").ParsingContext} vertContext Vertex shader parsing context\n * @param {import(\"../style/expressions.js\").ParsingContext} fragContext Fragment shader parsing context\n */\nfunction parseIconProperties(style, builder, uniforms, vertContext, fragContext) {\n  fragContext.functions['samplePremultiplied'] = `vec4 samplePremultiplied(sampler2D sampler, vec2 texCoord) {\n  vec4 color = texture2D(sampler, texCoord);\n  return vec4(color.rgb * color.a, color.a);\n}`;\n\n  // COLOR\n  let color = 'vec4(1.0)';\n  if ('icon-color' in style) {\n    color = expressionToGlsl(fragContext, style['icon-color'], ValueTypes.COLOR);\n  }\n\n  // OPACITY\n  if ('icon-opacity' in style) {\n    color = `${color} * ${expressionToGlsl(fragContext, style['icon-opacity'], ValueTypes.NUMBER)}`;\n  }\n\n  // IMAGE & SIZE\n  let image;\n  let size;\n  const textureId = getUid(style);\n  if ('icon-src' in style) {\n    image = new Image();\n    image.crossOrigin = style['icon-cross-origin'] === undefined ? 'anonymous' : style['icon-cross-origin'];\n    image.src = style['icon-src'];\n    // the size is provided asynchronously using a uniform\n    uniforms[`u_texture${textureId}_size`] = () => {\n      return image.complete ? [image.width, image.height] : [0, 0];\n    };\n    size = `u_texture${textureId}_size`;\n    builder.addUniform(`vec2 u_texture${textureId}_size`);\n  } else {\n    image = style['icon-img'];\n    if (image instanceof HTMLImageElement) {\n      if (image.complete && image.width && image.height) {\n        size = arrayToGlsl([image.width, image.height]);\n      } else {\n        // the size is provided asynchronously using a uniform\n        uniforms[`u_texture${textureId}_size`] = () => {\n          return image.complete ? [image.width, image.height] : [0, 0];\n        };\n        size = `u_texture${textureId}_size`;\n      }\n    } else {\n      size = arrayToGlsl([image.width, image.height]);\n    }\n  }\n  uniforms[`u_texture${textureId}`] = image;\n  builder.addUniform(`sampler2D u_texture${textureId}`).setSymbolColorExpression(`${color} * samplePremultiplied(u_texture${textureId}, v_texCoord)`).setSymbolSizeExpression(size);\n\n  // override size if width/height were specified\n  if ('icon-width' in style && 'icon-height' in style) {\n    builder.setSymbolSizeExpression(`vec2(${expressionToGlsl(vertContext, style['icon-width'], ValueTypes.NUMBER)}, ${expressionToGlsl(vertContext, style['icon-height'], ValueTypes.NUMBER)})`);\n  }\n\n  // tex coord\n  if ('icon-offset' in style && 'icon-size' in style) {\n    let offset = expressionToGlsl(vertContext, style['icon-offset'], ValueTypes.NUMBER_ARRAY);\n    const sampleSize = expressionToGlsl(vertContext, style['icon-size'], ValueTypes.NUMBER_ARRAY);\n    const fullsize = builder.getSymbolSizeExpression();\n    builder.setSymbolSizeExpression(sampleSize);\n    if ('icon-offset-origin' in style) {\n      switch (style['icon-offset-origin']) {\n        case 'top-right':\n          offset = `vec2(v_quadSizePx.x, 0.) + ${sampleSize} * vec2(-1., 0.) + ${offset} * vec2(-1., 1.)`;\n          break;\n        case 'bottom-left':\n          offset = `vec2(0., v_quadSizePx.y) + ${sampleSize} * vec2(0., -1.) + ${offset} * vec2(1., -1.)`;\n          break;\n        case 'bottom-right':\n          offset = `v_quadSizePx - ${sampleSize} - ${offset}`;\n          break;\n        default: // pass\n      }\n    }\n\n    builder.setTextureCoordinateExpression(`(vec4((${offset}).xyxy) + vec4(0., 0., ${sampleSize})) / (${fullsize}).xyxy`);\n  }\n  parseCommonSymbolProperties(style, builder, vertContext, 'icon-');\n  if ('icon-anchor' in style) {\n    const anchor = expressionToGlsl(vertContext, style['icon-anchor'], ValueTypes.NUMBER_ARRAY);\n    let scale = `1.0`;\n    if (`icon-scale` in style) {\n      scale = expressionToGlsl(vertContext, style[`icon-scale`], ValueTypes.NUMBER | ValueTypes.NUMBER_ARRAY);\n    }\n    let shiftPx;\n    if (style['icon-anchor-x-units'] === 'pixels' && style['icon-anchor-y-units'] === 'pixels') {\n      shiftPx = `${anchor} * ${scale}`;\n    } else if (style['icon-anchor-x-units'] === 'pixels') {\n      shiftPx = `${anchor} * vec2(vec2(${scale}).x, v_quadSizePx.y)`;\n    } else if (style['icon-anchor-y-units'] === 'pixels') {\n      shiftPx = `${anchor} * vec2(v_quadSizePx.x, vec2(${scale}).x)`;\n    } else {\n      shiftPx = `${anchor} * v_quadSizePx`;\n    }\n    // default origin is top-left\n    let offsetPx = `v_quadSizePx * vec2(0.5, -0.5) + ${shiftPx} * vec2(-1., 1.)`;\n    if ('icon-anchor-origin' in style) {\n      switch (style['icon-anchor-origin']) {\n        case 'top-right':\n          offsetPx = `v_quadSizePx * -0.5 + ${shiftPx}`;\n          break;\n        case 'bottom-left':\n          offsetPx = `v_quadSizePx * 0.5 - ${shiftPx}`;\n          break;\n        case 'bottom-right':\n          offsetPx = `v_quadSizePx * vec2(-0.5, 0.5) + ${shiftPx} * vec2(1., -1.)`;\n          break;\n        default: // pass\n      }\n    }\n\n    builder.setSymbolOffsetExpression(`${builder.getSymbolOffsetExpression()} + ${offsetPx}`);\n  }\n}\n\n/**\n * @param {import(\"../style/literal.js\").LiteralStyle} style Style\n * @param {ShaderBuilder} builder Shader Builder\n * @param {Object<string,import(\"../webgl/Helper\").UniformValue>} uniforms Uniforms\n * @param {import(\"../style/expressions.js\").ParsingContext} vertContext Vertex shader parsing context\n * @param {import(\"../style/expressions.js\").ParsingContext} fragContext Fragment shader parsing context\n */\nfunction parseStrokeProperties(style, builder, uniforms, vertContext, fragContext) {\n  if ('stroke-color' in style) {\n    builder.setStrokeColorExpression(expressionToGlsl(fragContext, style['stroke-color'], ValueTypes.COLOR));\n  }\n  if ('stroke-width' in style) {\n    builder.setStrokeWidthExpression(expressionToGlsl(vertContext, style['stroke-width'], ValueTypes.NUMBER));\n  }\n  if ('stroke-offset' in style) {\n    builder.setStrokeOffsetExpression(expressionToGlsl(vertContext, style['stroke-offset'], ValueTypes.NUMBER));\n  }\n  if ('stroke-line-cap' in style) {\n    builder.setStrokeCapExpression(expressionToGlsl(vertContext, style['stroke-line-cap'], ValueTypes.STRING));\n  }\n  if ('stroke-line-join' in style) {\n    builder.setStrokeJoinExpression(expressionToGlsl(vertContext, style['stroke-line-join'], ValueTypes.STRING));\n  }\n  if ('stroke-miter-limit' in style) {\n    builder.setStrokeMiterLimitExpression(expressionToGlsl(vertContext, style['stroke-miter-limit'], ValueTypes.NUMBER));\n  }\n  if ('stroke-line-dash' in style) {\n    fragContext.functions['getSingleDashDistance'] = `float getSingleDashDistance(float distance, float radius, float dashOffset, float dashLength, float dashLengthTotal, float capType) {\n  float localDistance = mod(distance, dashLengthTotal);\n  float distanceSegment = abs(localDistance - dashOffset - dashLength * 0.5) - dashLength * 0.5;\n  distanceSegment = min(distanceSegment, dashLengthTotal - localDistance);\n  if (capType == ${stringToGlsl('square')}) {\n    distanceSegment -= v_width * 0.5;\n  } else if (capType == ${stringToGlsl('round')}) {\n    distanceSegment = min(distanceSegment, sqrt(distanceSegment * distanceSegment + radius * radius) - v_width * 0.5);\n  }\n  return distanceSegment;\n}`;\n    let dashPattern = style['stroke-line-dash'].map(v => expressionToGlsl(fragContext, v, ValueTypes.NUMBER));\n    // if pattern has odd length, concatenate it with itself to be even\n    if (dashPattern.length % 2 === 1) {\n      dashPattern = [...dashPattern, ...dashPattern];\n    }\n    let offsetExpression = '0.';\n    if ('stroke-line-dash-offset' in style) {\n      offsetExpression = expressionToGlsl(vertContext, style['stroke-line-dash-offset'], ValueTypes.NUMBER);\n    }\n\n    // define a function for this dash specifically (identified using a simple hash)\n    // see https://stackoverflow.com/questions/7616461/generate-a-hash-from-string-in-javascript\n    let uniqueDashKey = JSON.stringify(style['stroke-line-dash']).split('').reduce((prev, curr) => (prev << 5) - prev + curr.charCodeAt(0), 0);\n    uniqueDashKey = uniqueDashKey >>> 0;\n    const dashFunctionName = `dashDistanceField_${uniqueDashKey}`;\n    const dashLengthsDef = dashPattern.map((v, i) => `float dashLength${i} = ${v};`);\n    const totalLengthDef = dashPattern.map((v, i) => `dashLength${i}`).join(' + ');\n    let currentDashOffset = '0.';\n    let distanceExpression = `getSingleDashDistance(distance, radius, ${currentDashOffset}, dashLength0, totalDashLength, capType)`;\n    for (let i = 2; i < dashPattern.length; i += 2) {\n      currentDashOffset = `${currentDashOffset} + dashLength${i - 2} + dashLength${i - 1}`;\n      distanceExpression = `min(${distanceExpression}, getSingleDashDistance(distance, radius, ${currentDashOffset}, dashLength${i}, totalDashLength, capType))`;\n    }\n    fragContext.functions[dashFunctionName] = `float ${dashFunctionName}(float distance, float radius, float capType) {\n  ${dashLengthsDef.join('\\n  ')}\n  float totalDashLength = ${totalLengthDef};\n  return ${distanceExpression};\n}`;\n    builder.setStrokeDistanceFieldExpression(`${dashFunctionName}(currentLengthPx + ${offsetExpression}, currentRadiusPx, capType)`);\n  }\n}\n\n/**\n * @param {import(\"../style/literal.js\").LiteralStyle} style Style\n * @param {ShaderBuilder} builder Shader Builder\n * @param {Object<string,import(\"../webgl/Helper\").UniformValue>} uniforms Uniforms\n * @param {import(\"../style/expressions.js\").ParsingContext} vertContext Vertex shader parsing context\n * @param {import(\"../style/expressions.js\").ParsingContext} fragContext Fragment shader parsing context\n */\nfunction parseFillProperties(style, builder, uniforms, vertContext, fragContext) {\n  if ('fill-color' in style) {\n    builder.setFillColorExpression(expressionToGlsl(fragContext, style['fill-color'], ValueTypes.COLOR));\n  }\n}\n\n/**\n * @typedef {Object} StyleParseResult\n * @property {ShaderBuilder} builder Shader builder pre-configured according to a given style\n * @property {import(\"../render/webgl/VectorStyleRenderer.js\").UniformDefinitions} uniforms Uniform definitions\n * @property {import(\"../render/webgl/VectorStyleRenderer.js\").AttributeDefinitions} attributes Attribute definitions\n */\n\n/**\n * Parses a {@link import(\"../style/literal.js\").LiteralStyle} object and returns a {@link ShaderBuilder}\n * object that has been configured according to the given style, as well as `attributes` and `uniforms`\n * arrays to be fed to the `WebGLPointsRenderer` class.\n *\n * Also returns `uniforms` and `attributes` properties as expected by the\n * {@link module:ol/renderer/webgl/PointsLayer~WebGLPointsLayerRenderer}.\n *\n * @param {import(\"../style/literal.js\").LiteralStyle} style Literal style.\n * @return {StyleParseResult} Result containing shader params, attributes and uniforms.\n */\nexport function parseLiteralStyle(style) {\n  /**\n   * @type {import(\"../style/expressions.js\").ParsingContext}\n   */\n  const vertContext = {\n    inFragmentShader: false,\n    variables: [],\n    attributes: [],\n    functions: {},\n    style: style\n  };\n\n  /**\n   * @type {import(\"../style/expressions.js\").ParsingContext}\n   */\n  const fragContext = {\n    inFragmentShader: true,\n    variables: vertContext.variables,\n    attributes: [],\n    functions: {},\n    style: style\n  };\n  const builder = new ShaderBuilder();\n\n  /** @type {Object<string,import(\"../webgl/Helper\").UniformValue>} */\n  const uniforms = {};\n  if ('icon-src' in style || 'icon-img' in style) {\n    parseIconProperties(style, builder, uniforms, vertContext, fragContext);\n  } else if ('shape-points' in style) {\n    parseShapeProperties(style, builder, uniforms, vertContext, fragContext);\n  } else if ('circle-radius' in style) {\n    parseCircleProperties(style, builder, uniforms, vertContext, fragContext);\n  }\n  parseStrokeProperties(style, builder, uniforms, vertContext, fragContext);\n  parseFillProperties(style, builder, uniforms, vertContext, fragContext);\n  if (style.filter) {\n    const parsedFilter = expressionToGlsl(fragContext, style.filter, ValueTypes.BOOLEAN);\n    builder.setFragmentDiscardExpression(`!${parsedFilter}`);\n  }\n\n  // define one uniform per variable\n  fragContext.variables.forEach(function (variable) {\n    const uniformName = uniformNameForVariable(variable.name);\n    builder.addUniform(`${getGlslTypeFromType(variable.type)} ${uniformName}`);\n    let callback;\n    if (variable.type === ValueTypes.STRING) {\n      callback = () => getStringNumberEquivalent( /** @type {string} */style.variables[variable.name]);\n    } else if (variable.type === ValueTypes.COLOR) {\n      callback = () => packColor([...asArray( /** @type {string|Array<number>} */style.variables[variable.name] || '#eee')]);\n    } else if (variable.type === ValueTypes.BOOLEAN) {\n      callback = () => /** @type {boolean} */style.variables[variable.name] ? 1.0 : 0.0;\n    } else {\n      callback = () => /** @type {number} */style.variables[variable.name];\n    }\n    uniforms[uniformName] = callback;\n  });\n\n  // for each feature attribute used in the fragment shader, define a varying that will be used to pass data\n  // from the vertex to the fragment shader, as well as an attribute in the vertex shader (if not already present)\n  fragContext.attributes.forEach(function (attribute) {\n    if (!vertContext.attributes.find(a => a.name === attribute.name)) {\n      vertContext.attributes.push(attribute);\n    }\n    let type = getGlslTypeFromType(attribute.type);\n    let expression = `a_${attribute.name}`;\n    if (attribute.type === ValueTypes.COLOR) {\n      type = 'vec4';\n      expression = `unpackColor(${expression})`;\n      builder.addVertexShaderFunction(UNPACK_COLOR_FN);\n    }\n    builder.addVarying(`v_${attribute.name}`, type, expression);\n  });\n\n  // for each feature attribute used in the vertex shader, define an attribute in the vertex shader.\n  vertContext.attributes.forEach(function (attribute) {\n    builder.addAttribute(`${getGlslTypeFromType(attribute.type)} a_${attribute.name}`);\n  });\n  const attributes = vertContext.attributes.map(function (attribute) {\n    let callback;\n    if (attribute.callback) {\n      callback = attribute.callback;\n    } else if (attribute.type === ValueTypes.STRING) {\n      callback = feature => getStringNumberEquivalent(feature.get(attribute.name));\n    } else if (attribute.type === ValueTypes.COLOR) {\n      callback = feature => packColor([...asArray(feature.get(attribute.name) || '#eee')]);\n    } else if (attribute.type === ValueTypes.BOOLEAN) {\n      callback = feature => feature.get(attribute.name) ? 1.0 : 0.0;\n    } else {\n      callback = feature => feature.get(attribute.name);\n    }\n    return {\n      name: attribute.name,\n      size: getGlslSizeFromType(attribute.type),\n      callback\n    };\n  });\n\n  // add functions that were collected in the parsing contexts\n  for (const functionName in vertContext.functions) {\n    builder.addVertexShaderFunction(vertContext.functions[functionName]);\n  }\n  for (const functionName in fragContext.functions) {\n    builder.addFragmentShaderFunction(fragContext.functions[functionName]);\n  }\n  return {\n    builder: builder,\n    attributes: attributes.reduce((prev, curr) => ({\n      ...prev,\n      [curr.name]: {\n        callback: curr.callback,\n        size: curr.size\n      }\n    }), {}),\n    uniforms: uniforms\n  };\n}","map":{"version":3,"names":["ShaderBuilder","ValueTypes","arrayToGlsl","expressionToGlsl","getStringNumberEquivalent","stringToGlsl","uniformNameForVariable","asArray","getUid","packColor","color","array","r","g","b","a","Math","round","UNPACK_COLOR_FN","getGlslSizeFromType","type","COLOR","NUMBER_ARRAY","getGlslTypeFromType","size","parseCommonSymbolProperties","style","builder","vertContext","prefix","radius","NUMBER","undefined","setSymbolSizeExpression","scale","getSymbolSizeExpression","setSymbolOffsetExpression","setSymbolRotationExpression","setSymbolRotateWithView","getColorFromDistanceField","distanceField","fillColor","strokeColor","strokeWidth","opacity","strokeFillRatio","shapeOpacity","result","parseCircleProperties","uniforms","fragContext","functions","currentPoint","colorExpression","setSymbolColorExpression","parseShapeProperties","numPoints","angle","shapeField","radiusOuter","radiusInner","parseIconProperties","image","textureId","Image","crossOrigin","src","complete","width","height","addUniform","HTMLImageElement","offset","sampleSize","fullsize","setTextureCoordinateExpression","anchor","shiftPx","offsetPx","getSymbolOffsetExpression","parseStrokeProperties","setStrokeColorExpression","setStrokeWidthExpression","setStrokeOffsetExpression","setStrokeCapExpression","STRING","setStrokeJoinExpression","setStrokeMiterLimitExpression","dashPattern","map","v","length","offsetExpression","uniqueDashKey","JSON","stringify","split","reduce","prev","curr","charCodeAt","dashFunctionName","dashLengthsDef","i","totalLengthDef","join","currentDashOffset","distanceExpression","setStrokeDistanceFieldExpression","parseFillProperties","setFillColorExpression","parseLiteralStyle","inFragmentShader","variables","attributes","filter","parsedFilter","BOOLEAN","setFragmentDiscardExpression","forEach","variable","uniformName","name","callback","attribute","find","push","expression","addVertexShaderFunction","addVarying","addAttribute","feature","get","functionName","addFragmentShaderFunction"],"sources":["E:/Desktop/scenerymonitor/node_modules/ol/webgl/styleparser.js"],"sourcesContent":["/**\n * Utilities for parsing literal style objects\n * @module ol/webgl/styleparser\n */\nimport {ShaderBuilder} from './ShaderBuilder.js';\nimport {\n  ValueTypes,\n  arrayToGlsl,\n  expressionToGlsl,\n  getStringNumberEquivalent,\n  stringToGlsl,\n  uniformNameForVariable,\n} from '../style/expressions.js';\nimport {asArray} from '../color.js';\nimport {getUid} from '../util.js';\n\n/**\n * Packs all components of a color into a two-floats array\n * @param {import(\"../color.js\").Color|string} color Color as array of numbers or string\n * @return {Array<number>} Vec2 array containing the color in compressed form\n */\nexport function packColor(color) {\n  const array = asArray(color);\n  const r = array[0] * 256;\n  const g = array[1];\n  const b = array[2] * 256;\n  const a = Math.round(array[3] * 255);\n  return [r + g, b + a];\n}\n\nconst UNPACK_COLOR_FN = `vec4 unpackColor(vec2 packedColor) {\n  return fract(packedColor[1] / 256.0) * vec4(\n    fract(floor(packedColor[0] / 256.0) / 256.0),\n    fract(packedColor[0] / 256.0),\n    fract(floor(packedColor[1] / 256.0) / 256.0),\n    1.0\n  );\n}`;\n\n/**\n * @param {ValueTypes} type Value type\n * @return {1|2|3|4} The amount of components for this value\n */\nfunction getGlslSizeFromType(type) {\n  if (type === ValueTypes.COLOR) {\n    return 2;\n  }\n  if (type === ValueTypes.NUMBER_ARRAY) {\n    return 4;\n  }\n  return 1;\n}\n\n/**\n * @param {ValueTypes} type Value type\n * @return {'float'|'vec2'|'vec3'|'vec4'} The corresponding GLSL type for this value\n */\nfunction getGlslTypeFromType(type) {\n  const size = getGlslSizeFromType(type);\n  if (size > 1) {\n    return /** @type {'vec2'|'vec3'|'vec4'} */ (`vec${size}`);\n  }\n  return 'float';\n}\n\n/**\n * @param {import(\"../style/literal.js\").LiteralStyle} style Style\n * @param {ShaderBuilder} builder Shader builder\n * @param {import(\"../style/expressions.js\").ParsingContext} vertContext Vertex shader parsing context\n * @param {'shape-'|'circle-'|'icon-'} prefix Properties prefix\n */\nfunction parseCommonSymbolProperties(style, builder, vertContext, prefix) {\n  let radius;\n  if (`${prefix}radius` in style && prefix !== 'icon-') {\n    radius = expressionToGlsl(\n      vertContext,\n      style[`${prefix}radius`],\n      ValueTypes.NUMBER\n    );\n  } else if (`${prefix}radius1` in style && prefix === 'shape-') {\n    radius = expressionToGlsl(\n      vertContext,\n      style[`${prefix}radius1`],\n      ValueTypes.NUMBER\n    );\n  }\n  if (radius !== undefined) {\n    if (`${prefix}stroke-width` in style) {\n      radius = `(${radius} + ${expressionToGlsl(\n        vertContext,\n        style[`${prefix}stroke-width`],\n        ValueTypes.NUMBER\n      )} * 0.5)`;\n    }\n    builder.setSymbolSizeExpression(`vec2(${radius} * 2. + 0.5)`); // adding some padding for antialiasing\n  }\n  if (`${prefix}scale` in style) {\n    const scale = expressionToGlsl(\n      vertContext,\n      style[`${prefix}scale`],\n      ValueTypes.NUMBER | ValueTypes.NUMBER_ARRAY\n    );\n    builder.setSymbolSizeExpression(\n      `${builder.getSymbolSizeExpression()} * ${scale}`\n    );\n  }\n  if (`${prefix}displacement` in style) {\n    builder.setSymbolOffsetExpression(\n      expressionToGlsl(\n        vertContext,\n        style[`${prefix}displacement`],\n        ValueTypes.NUMBER_ARRAY\n      )\n    );\n  }\n  if (`${prefix}rotation` in style) {\n    builder.setSymbolRotationExpression(\n      expressionToGlsl(\n        vertContext,\n        style[`${prefix}rotation`],\n        ValueTypes.NUMBER\n      )\n    );\n  }\n  if (`${prefix}rotate-with-view` in style) {\n    builder.setSymbolRotateWithView(!!style[`${prefix}rotate-with-view`]);\n  }\n}\n\n/**\n * @param {string} distanceField The distance field expression\n * @param {string|null} fillColor The fill color expression; null if no fill\n * @param {string|null} strokeColor The stroke color expression; null if no stroke\n * @param {string|null} strokeWidth The stroke width expression; null if no stroke\n * @param {string|null} opacity The opacity expression; null if no stroke\n * @return {string} The final color expression, based on the distance field and given params\n */\nfunction getColorFromDistanceField(\n  distanceField,\n  fillColor,\n  strokeColor,\n  strokeWidth,\n  opacity\n) {\n  let color = 'vec4(0.)';\n  if (fillColor !== null) {\n    color = fillColor;\n  }\n  if (strokeColor !== null && strokeWidth !== null) {\n    const strokeFillRatio = `smoothstep(-${strokeWidth} + 0.63, -${strokeWidth} - 0.58, ${distanceField})`;\n    color = `mix(${strokeColor}, ${color}, ${strokeFillRatio})`;\n  }\n  const shapeOpacity = `(1.0 - smoothstep(-0.63, 0.58, ${distanceField}))`;\n  let result = `${color} * ${shapeOpacity}`;\n  if (opacity !== null) {\n    result = `${result} * ${opacity}`;\n  }\n  return result;\n}\n\n/**\n * @param {import(\"../style/literal.js\").LiteralStyle} style Style\n * @param {ShaderBuilder} builder Shader builder\n * @param {Object<string,import(\"../webgl/Helper\").UniformValue>} uniforms Uniforms\n * @param {import(\"../style/expressions.js\").ParsingContext} vertContext Vertex shader parsing context\n * @param {import(\"../style/expressions.js\").ParsingContext} fragContext Fragment shader parsing context\n */\nfunction parseCircleProperties(\n  style,\n  builder,\n  uniforms,\n  vertContext,\n  fragContext\n) {\n  // this function takes in screen coordinates in pixels and returns the signed distance field\n  // (0 on the boundary, negative inside the circle, positive outside, values in pixels)\n  fragContext.functions[\n    'circleDistanceField'\n  ] = `float circleDistanceField(vec2 point, float radius) {\n  return length(point) - radius;\n}`;\n\n  parseCommonSymbolProperties(style, builder, vertContext, 'circle-');\n\n  // OPACITY\n  let opacity = null;\n  if ('circle-opacity' in style) {\n    opacity = expressionToGlsl(\n      fragContext,\n      style['circle-opacity'],\n      ValueTypes.NUMBER\n    );\n  }\n\n  // SCALE\n  let currentPoint = 'coordsPx';\n  if ('circle-scale' in style) {\n    const scale = expressionToGlsl(\n      fragContext,\n      style['circle-scale'],\n      ValueTypes.NUMBER | ValueTypes.NUMBER_ARRAY\n    );\n    currentPoint = `coordsPx / ${scale}`;\n  }\n\n  // FILL COLOR\n  let fillColor = null;\n  if ('circle-fill-color' in style) {\n    fillColor = expressionToGlsl(\n      fragContext,\n      style['circle-fill-color'],\n      ValueTypes.COLOR\n    );\n  }\n\n  // STROKE COLOR\n  let strokeColor = null;\n  if ('circle-stroke-color' in style) {\n    strokeColor = expressionToGlsl(\n      fragContext,\n      style['circle-stroke-color'],\n      ValueTypes.COLOR\n    );\n  }\n\n  // RADIUS\n  let radius = expressionToGlsl(\n    fragContext,\n    style['circle-radius'],\n    ValueTypes.NUMBER\n  );\n\n  // STROKE WIDTH\n  let strokeWidth = null;\n  if ('circle-stroke-width' in style) {\n    strokeWidth = expressionToGlsl(\n      fragContext,\n      style['circle-stroke-width'],\n      ValueTypes.NUMBER\n    );\n    radius = `(${radius} + ${strokeWidth} * 0.5)`;\n  }\n\n  // FINAL COLOR\n  const distanceField = `circleDistanceField(${currentPoint}, ${radius})`;\n  const colorExpression = getColorFromDistanceField(\n    distanceField,\n    fillColor,\n    strokeColor,\n    strokeWidth,\n    opacity\n  );\n  builder.setSymbolColorExpression(colorExpression);\n}\n\n/**\n * @param {import(\"../style/literal.js\").LiteralStyle} style Style\n * @param {ShaderBuilder} builder Shader builder\n * @param {Object<string,import(\"../webgl/Helper\").UniformValue>} uniforms Uniforms\n * @param {import(\"../style/expressions.js\").ParsingContext} vertContext Vertex shader parsing context\n * @param {import(\"../style/expressions.js\").ParsingContext} fragContext Fragment shader parsing context\n */\nfunction parseShapeProperties(\n  style,\n  builder,\n  uniforms,\n  vertContext,\n  fragContext\n) {\n  fragContext.functions['round'] = `float round(float v) {\n  return sign(v) * floor(abs(v) + 0.5);\n}`;\n\n  // these functions take in screen coordinates in pixels and returns the signed distance field\n  // (0 on the boundary, negative inside the circle, positive outside, values in pixels)\n  // inspired by https://github.com/zranger1/PixelblazePatterns/blob/master/Toolkit/sdf2d.md#n-sided-regular-polygon\n  fragContext.functions[\n    'starDistanceField'\n  ] = `float starDistanceField(vec2 point, float numPoints, float radiusIn, float radiusOut, float angle) {\n  float startAngle = -PI * 0.5 + angle; // tip starts upwards and rotates clockwise with angle\n  float c = cos(startAngle);\n  float s = sin(startAngle);\n  vec2 pointRotated = vec2(c * point.x - s * point.y, s * point.x + c * point.y); \n  float alpha = TWO_PI / numPoints; // the angle of one sector\n  float beta = atan(pointRotated.y, pointRotated.x);\n  float gamma = round(beta / alpha) * alpha; // angle in sector\n  c = cos(-gamma);\n  s = sin(-gamma);\n  vec2 inSector = vec2(c * pointRotated.x - s * pointRotated.y, abs(s * pointRotated.x + c * pointRotated.y));\n  vec2 tipToPoint = inSector + vec2(-radiusOut, 0.);\n  vec2 edgeNormal = vec2(radiusIn * sin(alpha * 0.5), -radiusIn * cos(alpha * 0.5) + radiusOut);\n  return dot(normalize(edgeNormal), tipToPoint);\n}`;\n  fragContext.functions[\n    'regularDistanceField'\n  ] = `float regularDistanceField(vec2 point, float numPoints, float radius, float angle) {\n  float startAngle = -PI * 0.5 + angle; // tip starts upwards and rotates clockwise with angle\n  float c = cos(startAngle);\n  float s = sin(startAngle);\n  vec2 pointRotated = vec2(c * point.x - s * point.y, s * point.x + c * point.y); \n  float alpha = TWO_PI / numPoints; // the angle of one sector\n  float radiusIn = radius * cos(PI / numPoints);\n  float beta = atan(pointRotated.y, pointRotated.x);\n  float gamma = round((beta - alpha * 0.5) / alpha) * alpha + alpha * 0.5; // angle in sector from mid\n  c = cos(-gamma);\n  s = sin(-gamma);\n  vec2 inSector = vec2(c * pointRotated.x - s * pointRotated.y, abs(s * pointRotated.x + c * pointRotated.y));\n  return inSector.x - radiusIn;\n}`;\n\n  parseCommonSymbolProperties(style, builder, vertContext, 'shape-');\n\n  // OPACITY\n  let opacity = null;\n  if ('shape-opacity' in style) {\n    opacity = expressionToGlsl(\n      fragContext,\n      style['shape-opacity'],\n      ValueTypes.NUMBER\n    );\n  }\n\n  // SCALE\n  let currentPoint = 'coordsPx';\n  if ('shape-scale' in style) {\n    const scale = expressionToGlsl(\n      fragContext,\n      style['shape-scale'],\n      ValueTypes.NUMBER | ValueTypes.NUMBER_ARRAY\n    );\n    currentPoint = `coordsPx / ${scale}`;\n  }\n\n  // FILL COLOR\n  let fillColor = null;\n  if ('shape-fill-color' in style) {\n    fillColor = expressionToGlsl(\n      fragContext,\n      style['shape-fill-color'],\n      ValueTypes.COLOR\n    );\n  }\n\n  // STROKE COLOR\n  let strokeColor = null;\n  if ('shape-stroke-color' in style) {\n    strokeColor = expressionToGlsl(\n      fragContext,\n      style['shape-stroke-color'],\n      ValueTypes.COLOR\n    );\n  }\n\n  // STROKE WIDTH\n  let strokeWidth = null;\n  if ('shape-stroke-width' in style) {\n    strokeWidth = expressionToGlsl(\n      fragContext,\n      style['shape-stroke-width'],\n      ValueTypes.NUMBER\n    );\n  }\n\n  // SHAPE TYPE\n  const numPoints = expressionToGlsl(\n    fragContext,\n    style['shape-points'],\n    ValueTypes.NUMBER\n  );\n  let angle = '0.';\n  if ('shape-angle' in style) {\n    angle = expressionToGlsl(\n      fragContext,\n      style['shape-angle'],\n      ValueTypes.NUMBER\n    );\n  }\n  let shapeField;\n  if ('shape-radius' in style) {\n    let radius = expressionToGlsl(\n      fragContext,\n      style['shape-radius'],\n      ValueTypes.NUMBER\n    );\n    if (strokeWidth !== null) {\n      radius = `${radius} + ${strokeWidth} * 0.5`;\n    }\n    shapeField = `regularDistanceField(${currentPoint}, ${numPoints}, ${radius}, ${angle})`;\n  } else {\n    let radiusOuter = expressionToGlsl(\n      fragContext,\n      style['shape-radius1'],\n      ValueTypes.NUMBER\n    );\n    let radiusInner = expressionToGlsl(\n      fragContext,\n      style['shape-radius2'],\n      ValueTypes.NUMBER\n    );\n    if (strokeWidth !== null) {\n      radiusOuter = `${radiusOuter} + ${strokeWidth} * 0.5`;\n      radiusInner = `${radiusInner} + ${strokeWidth} * 0.5`;\n    }\n    shapeField = `starDistanceField(${currentPoint}, ${numPoints}, ${radiusInner}, ${radiusOuter}, ${angle})`;\n  }\n\n  // FINAL COLOR\n  const colorExpression = getColorFromDistanceField(\n    shapeField,\n    fillColor,\n    strokeColor,\n    strokeWidth,\n    opacity\n  );\n  builder.setSymbolColorExpression(colorExpression);\n}\n\n/**\n * @param {import(\"../style/literal.js\").LiteralStyle} style Style\n * @param {ShaderBuilder} builder Shader builder\n * @param {Object<string,import(\"../webgl/Helper\").UniformValue>} uniforms Uniforms\n * @param {import(\"../style/expressions.js\").ParsingContext} vertContext Vertex shader parsing context\n * @param {import(\"../style/expressions.js\").ParsingContext} fragContext Fragment shader parsing context\n */\nfunction parseIconProperties(\n  style,\n  builder,\n  uniforms,\n  vertContext,\n  fragContext\n) {\n  fragContext.functions[\n    'samplePremultiplied'\n  ] = `vec4 samplePremultiplied(sampler2D sampler, vec2 texCoord) {\n  vec4 color = texture2D(sampler, texCoord);\n  return vec4(color.rgb * color.a, color.a);\n}`;\n\n  // COLOR\n  let color = 'vec4(1.0)';\n  if ('icon-color' in style) {\n    color = expressionToGlsl(\n      fragContext,\n      style['icon-color'],\n      ValueTypes.COLOR\n    );\n  }\n\n  // OPACITY\n  if ('icon-opacity' in style) {\n    color = `${color} * ${expressionToGlsl(\n      fragContext,\n      style['icon-opacity'],\n      ValueTypes.NUMBER\n    )}`;\n  }\n\n  // IMAGE & SIZE\n  let image;\n  let size;\n  const textureId = getUid(style);\n  if ('icon-src' in style) {\n    image = new Image();\n    image.crossOrigin =\n      style['icon-cross-origin'] === undefined\n        ? 'anonymous'\n        : style['icon-cross-origin'];\n    image.src = style['icon-src'];\n    // the size is provided asynchronously using a uniform\n    uniforms[`u_texture${textureId}_size`] = () => {\n      return image.complete ? [image.width, image.height] : [0, 0];\n    };\n    size = `u_texture${textureId}_size`;\n    builder.addUniform(`vec2 u_texture${textureId}_size`);\n  } else {\n    image = style['icon-img'];\n    if (image instanceof HTMLImageElement) {\n      if (image.complete && image.width && image.height) {\n        size = arrayToGlsl([image.width, image.height]);\n      } else {\n        // the size is provided asynchronously using a uniform\n        uniforms[`u_texture${textureId}_size`] = () => {\n          return image.complete ? [image.width, image.height] : [0, 0];\n        };\n        size = `u_texture${textureId}_size`;\n      }\n    } else {\n      size = arrayToGlsl([image.width, image.height]);\n    }\n  }\n  uniforms[`u_texture${textureId}`] = image;\n  builder\n    .addUniform(`sampler2D u_texture${textureId}`)\n    .setSymbolColorExpression(\n      `${color} * samplePremultiplied(u_texture${textureId}, v_texCoord)`\n    )\n    .setSymbolSizeExpression(size);\n\n  // override size if width/height were specified\n  if ('icon-width' in style && 'icon-height' in style) {\n    builder.setSymbolSizeExpression(\n      `vec2(${expressionToGlsl(\n        vertContext,\n        style['icon-width'],\n        ValueTypes.NUMBER\n      )}, ${expressionToGlsl(\n        vertContext,\n        style['icon-height'],\n        ValueTypes.NUMBER\n      )})`\n    );\n  }\n\n  // tex coord\n  if ('icon-offset' in style && 'icon-size' in style) {\n    let offset = expressionToGlsl(\n      vertContext,\n      style['icon-offset'],\n      ValueTypes.NUMBER_ARRAY\n    );\n    const sampleSize = expressionToGlsl(\n      vertContext,\n      style['icon-size'],\n      ValueTypes.NUMBER_ARRAY\n    );\n    const fullsize = builder.getSymbolSizeExpression();\n    builder.setSymbolSizeExpression(sampleSize);\n\n    if ('icon-offset-origin' in style) {\n      switch (style['icon-offset-origin']) {\n        case 'top-right':\n          offset = `vec2(v_quadSizePx.x, 0.) + ${sampleSize} * vec2(-1., 0.) + ${offset} * vec2(-1., 1.)`;\n          break;\n        case 'bottom-left':\n          offset = `vec2(0., v_quadSizePx.y) + ${sampleSize} * vec2(0., -1.) + ${offset} * vec2(1., -1.)`;\n          break;\n        case 'bottom-right':\n          offset = `v_quadSizePx - ${sampleSize} - ${offset}`;\n          break;\n        default: // pass\n      }\n    }\n    builder.setTextureCoordinateExpression(\n      `(vec4((${offset}).xyxy) + vec4(0., 0., ${sampleSize})) / (${fullsize}).xyxy`\n    );\n  }\n\n  parseCommonSymbolProperties(style, builder, vertContext, 'icon-');\n\n  if ('icon-anchor' in style) {\n    const anchor = expressionToGlsl(\n      vertContext,\n      style['icon-anchor'],\n      ValueTypes.NUMBER_ARRAY\n    );\n    let scale = `1.0`;\n    if (`icon-scale` in style) {\n      scale = expressionToGlsl(\n        vertContext,\n        style[`icon-scale`],\n        ValueTypes.NUMBER | ValueTypes.NUMBER_ARRAY\n      );\n    }\n    let shiftPx;\n    if (\n      style['icon-anchor-x-units'] === 'pixels' &&\n      style['icon-anchor-y-units'] === 'pixels'\n    ) {\n      shiftPx = `${anchor} * ${scale}`;\n    } else if (style['icon-anchor-x-units'] === 'pixels') {\n      shiftPx = `${anchor} * vec2(vec2(${scale}).x, v_quadSizePx.y)`;\n    } else if (style['icon-anchor-y-units'] === 'pixels') {\n      shiftPx = `${anchor} * vec2(v_quadSizePx.x, vec2(${scale}).x)`;\n    } else {\n      shiftPx = `${anchor} * v_quadSizePx`;\n    }\n    // default origin is top-left\n    let offsetPx = `v_quadSizePx * vec2(0.5, -0.5) + ${shiftPx} * vec2(-1., 1.)`;\n    if ('icon-anchor-origin' in style) {\n      switch (style['icon-anchor-origin']) {\n        case 'top-right':\n          offsetPx = `v_quadSizePx * -0.5 + ${shiftPx}`;\n          break;\n        case 'bottom-left':\n          offsetPx = `v_quadSizePx * 0.5 - ${shiftPx}`;\n          break;\n        case 'bottom-right':\n          offsetPx = `v_quadSizePx * vec2(-0.5, 0.5) + ${shiftPx} * vec2(1., -1.)`;\n          break;\n        default: // pass\n      }\n    }\n    builder.setSymbolOffsetExpression(\n      `${builder.getSymbolOffsetExpression()} + ${offsetPx}`\n    );\n  }\n}\n\n/**\n * @param {import(\"../style/literal.js\").LiteralStyle} style Style\n * @param {ShaderBuilder} builder Shader Builder\n * @param {Object<string,import(\"../webgl/Helper\").UniformValue>} uniforms Uniforms\n * @param {import(\"../style/expressions.js\").ParsingContext} vertContext Vertex shader parsing context\n * @param {import(\"../style/expressions.js\").ParsingContext} fragContext Fragment shader parsing context\n */\nfunction parseStrokeProperties(\n  style,\n  builder,\n  uniforms,\n  vertContext,\n  fragContext\n) {\n  if ('stroke-color' in style) {\n    builder.setStrokeColorExpression(\n      expressionToGlsl(fragContext, style['stroke-color'], ValueTypes.COLOR)\n    );\n  }\n\n  if ('stroke-width' in style) {\n    builder.setStrokeWidthExpression(\n      expressionToGlsl(vertContext, style['stroke-width'], ValueTypes.NUMBER)\n    );\n  }\n\n  if ('stroke-offset' in style) {\n    builder.setStrokeOffsetExpression(\n      expressionToGlsl(vertContext, style['stroke-offset'], ValueTypes.NUMBER)\n    );\n  }\n\n  if ('stroke-line-cap' in style) {\n    builder.setStrokeCapExpression(\n      expressionToGlsl(vertContext, style['stroke-line-cap'], ValueTypes.STRING)\n    );\n  }\n\n  if ('stroke-line-join' in style) {\n    builder.setStrokeJoinExpression(\n      expressionToGlsl(\n        vertContext,\n        style['stroke-line-join'],\n        ValueTypes.STRING\n      )\n    );\n  }\n\n  if ('stroke-miter-limit' in style) {\n    builder.setStrokeMiterLimitExpression(\n      expressionToGlsl(\n        vertContext,\n        style['stroke-miter-limit'],\n        ValueTypes.NUMBER\n      )\n    );\n  }\n\n  if ('stroke-line-dash' in style) {\n    fragContext.functions[\n      'getSingleDashDistance'\n    ] = `float getSingleDashDistance(float distance, float radius, float dashOffset, float dashLength, float dashLengthTotal, float capType) {\n  float localDistance = mod(distance, dashLengthTotal);\n  float distanceSegment = abs(localDistance - dashOffset - dashLength * 0.5) - dashLength * 0.5;\n  distanceSegment = min(distanceSegment, dashLengthTotal - localDistance);\n  if (capType == ${stringToGlsl('square')}) {\n    distanceSegment -= v_width * 0.5;\n  } else if (capType == ${stringToGlsl('round')}) {\n    distanceSegment = min(distanceSegment, sqrt(distanceSegment * distanceSegment + radius * radius) - v_width * 0.5);\n  }\n  return distanceSegment;\n}`;\n\n    let dashPattern = style['stroke-line-dash'].map((v) =>\n      expressionToGlsl(fragContext, v, ValueTypes.NUMBER)\n    );\n    // if pattern has odd length, concatenate it with itself to be even\n    if (dashPattern.length % 2 === 1) {\n      dashPattern = [...dashPattern, ...dashPattern];\n    }\n\n    let offsetExpression = '0.';\n    if ('stroke-line-dash-offset' in style) {\n      offsetExpression = expressionToGlsl(\n        vertContext,\n        style['stroke-line-dash-offset'],\n        ValueTypes.NUMBER\n      );\n    }\n\n    // define a function for this dash specifically (identified using a simple hash)\n    // see https://stackoverflow.com/questions/7616461/generate-a-hash-from-string-in-javascript\n    let uniqueDashKey = JSON.stringify(style['stroke-line-dash'])\n      .split('')\n      .reduce((prev, curr) => (prev << 5) - prev + curr.charCodeAt(0), 0);\n    uniqueDashKey = uniqueDashKey >>> 0;\n    const dashFunctionName = `dashDistanceField_${uniqueDashKey}`;\n\n    const dashLengthsDef = dashPattern.map(\n      (v, i) => `float dashLength${i} = ${v};`\n    );\n    const totalLengthDef = dashPattern\n      .map((v, i) => `dashLength${i}`)\n      .join(' + ');\n    let currentDashOffset = '0.';\n    let distanceExpression = `getSingleDashDistance(distance, radius, ${currentDashOffset}, dashLength0, totalDashLength, capType)`;\n    for (let i = 2; i < dashPattern.length; i += 2) {\n      currentDashOffset = `${currentDashOffset} + dashLength${\n        i - 2\n      } + dashLength${i - 1}`;\n      distanceExpression = `min(${distanceExpression}, getSingleDashDistance(distance, radius, ${currentDashOffset}, dashLength${i}, totalDashLength, capType))`;\n    }\n\n    fragContext.functions[\n      dashFunctionName\n    ] = `float ${dashFunctionName}(float distance, float radius, float capType) {\n  ${dashLengthsDef.join('\\n  ')}\n  float totalDashLength = ${totalLengthDef};\n  return ${distanceExpression};\n}`;\n    builder.setStrokeDistanceFieldExpression(\n      `${dashFunctionName}(currentLengthPx + ${offsetExpression}, currentRadiusPx, capType)`\n    );\n  }\n}\n\n/**\n * @param {import(\"../style/literal.js\").LiteralStyle} style Style\n * @param {ShaderBuilder} builder Shader Builder\n * @param {Object<string,import(\"../webgl/Helper\").UniformValue>} uniforms Uniforms\n * @param {import(\"../style/expressions.js\").ParsingContext} vertContext Vertex shader parsing context\n * @param {import(\"../style/expressions.js\").ParsingContext} fragContext Fragment shader parsing context\n */\nfunction parseFillProperties(\n  style,\n  builder,\n  uniforms,\n  vertContext,\n  fragContext\n) {\n  if ('fill-color' in style) {\n    builder.setFillColorExpression(\n      expressionToGlsl(fragContext, style['fill-color'], ValueTypes.COLOR)\n    );\n  }\n}\n\n/**\n * @typedef {Object} StyleParseResult\n * @property {ShaderBuilder} builder Shader builder pre-configured according to a given style\n * @property {import(\"../render/webgl/VectorStyleRenderer.js\").UniformDefinitions} uniforms Uniform definitions\n * @property {import(\"../render/webgl/VectorStyleRenderer.js\").AttributeDefinitions} attributes Attribute definitions\n */\n\n/**\n * Parses a {@link import(\"../style/literal.js\").LiteralStyle} object and returns a {@link ShaderBuilder}\n * object that has been configured according to the given style, as well as `attributes` and `uniforms`\n * arrays to be fed to the `WebGLPointsRenderer` class.\n *\n * Also returns `uniforms` and `attributes` properties as expected by the\n * {@link module:ol/renderer/webgl/PointsLayer~WebGLPointsLayerRenderer}.\n *\n * @param {import(\"../style/literal.js\").LiteralStyle} style Literal style.\n * @return {StyleParseResult} Result containing shader params, attributes and uniforms.\n */\nexport function parseLiteralStyle(style) {\n  /**\n   * @type {import(\"../style/expressions.js\").ParsingContext}\n   */\n  const vertContext = {\n    inFragmentShader: false,\n    variables: [],\n    attributes: [],\n    functions: {},\n    style: style,\n  };\n\n  /**\n   * @type {import(\"../style/expressions.js\").ParsingContext}\n   */\n  const fragContext = {\n    inFragmentShader: true,\n    variables: vertContext.variables,\n    attributes: [],\n    functions: {},\n    style: style,\n  };\n\n  const builder = new ShaderBuilder();\n\n  /** @type {Object<string,import(\"../webgl/Helper\").UniformValue>} */\n  const uniforms = {};\n\n  if ('icon-src' in style || 'icon-img' in style) {\n    parseIconProperties(style, builder, uniforms, vertContext, fragContext);\n  } else if ('shape-points' in style) {\n    parseShapeProperties(style, builder, uniforms, vertContext, fragContext);\n  } else if ('circle-radius' in style) {\n    parseCircleProperties(style, builder, uniforms, vertContext, fragContext);\n  }\n  parseStrokeProperties(style, builder, uniforms, vertContext, fragContext);\n  parseFillProperties(style, builder, uniforms, vertContext, fragContext);\n\n  if (style.filter) {\n    const parsedFilter = expressionToGlsl(\n      fragContext,\n      style.filter,\n      ValueTypes.BOOLEAN\n    );\n    builder.setFragmentDiscardExpression(`!${parsedFilter}`);\n  }\n\n  // define one uniform per variable\n  fragContext.variables.forEach(function (variable) {\n    const uniformName = uniformNameForVariable(variable.name);\n    builder.addUniform(`${getGlslTypeFromType(variable.type)} ${uniformName}`);\n\n    let callback;\n    if (variable.type === ValueTypes.STRING) {\n      callback = () =>\n        getStringNumberEquivalent(\n          /** @type {string} */ (style.variables[variable.name])\n        );\n    } else if (variable.type === ValueTypes.COLOR) {\n      callback = () =>\n        packColor([\n          ...asArray(\n            /** @type {string|Array<number>} */ (\n              style.variables[variable.name]\n            ) || '#eee'\n          ),\n        ]);\n    } else if (variable.type === ValueTypes.BOOLEAN) {\n      callback = () =>\n        /** @type {boolean} */ (style.variables[variable.name]) ? 1.0 : 0.0;\n    } else {\n      callback = () => /** @type {number} */ (style.variables[variable.name]);\n    }\n    uniforms[uniformName] = callback;\n  });\n\n  // for each feature attribute used in the fragment shader, define a varying that will be used to pass data\n  // from the vertex to the fragment shader, as well as an attribute in the vertex shader (if not already present)\n  fragContext.attributes.forEach(function (attribute) {\n    if (!vertContext.attributes.find((a) => a.name === attribute.name)) {\n      vertContext.attributes.push(attribute);\n    }\n    let type = getGlslTypeFromType(attribute.type);\n    let expression = `a_${attribute.name}`;\n    if (attribute.type === ValueTypes.COLOR) {\n      type = 'vec4';\n      expression = `unpackColor(${expression})`;\n      builder.addVertexShaderFunction(UNPACK_COLOR_FN);\n    }\n    builder.addVarying(`v_${attribute.name}`, type, expression);\n  });\n\n  // for each feature attribute used in the vertex shader, define an attribute in the vertex shader.\n  vertContext.attributes.forEach(function (attribute) {\n    builder.addAttribute(\n      `${getGlslTypeFromType(attribute.type)} a_${attribute.name}`\n    );\n  });\n\n  const attributes = vertContext.attributes.map(function (attribute) {\n    let callback;\n    if (attribute.callback) {\n      callback = attribute.callback;\n    } else if (attribute.type === ValueTypes.STRING) {\n      callback = (feature) =>\n        getStringNumberEquivalent(feature.get(attribute.name));\n    } else if (attribute.type === ValueTypes.COLOR) {\n      callback = (feature) =>\n        packColor([...asArray(feature.get(attribute.name) || '#eee')]);\n    } else if (attribute.type === ValueTypes.BOOLEAN) {\n      callback = (feature) => (feature.get(attribute.name) ? 1.0 : 0.0);\n    } else {\n      callback = (feature) => feature.get(attribute.name);\n    }\n\n    return {\n      name: attribute.name,\n      size: getGlslSizeFromType(attribute.type),\n      callback,\n    };\n  });\n\n  // add functions that were collected in the parsing contexts\n  for (const functionName in vertContext.functions) {\n    builder.addVertexShaderFunction(vertContext.functions[functionName]);\n  }\n  for (const functionName in fragContext.functions) {\n    builder.addFragmentShaderFunction(fragContext.functions[functionName]);\n  }\n\n  return {\n    builder: builder,\n    attributes: attributes.reduce(\n      (prev, curr) => ({\n        ...prev,\n        [curr.name]: {callback: curr.callback, size: curr.size},\n      }),\n      {}\n    ),\n    uniforms: uniforms,\n  };\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}