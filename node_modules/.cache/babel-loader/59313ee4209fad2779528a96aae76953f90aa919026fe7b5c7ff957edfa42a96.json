{"ast":null,"code":"/**\n * @module ol/TileCache\n */\nimport LRUCache from './structs/LRUCache.js';\nimport { fromKey, getKey } from './tilecoord.js';\nclass TileCache extends LRUCache {\n  clear() {\n    while (this.getCount() > 0) {\n      this.pop().release();\n    }\n    super.clear();\n  }\n\n  /**\n   * @param {!Object<string, boolean>} usedTiles Used tiles.\n   */\n  expireCache(usedTiles) {\n    while (this.canExpireCache()) {\n      const tile = this.peekLast();\n      if (tile.getKey() in usedTiles) {\n        break;\n      } else {\n        this.pop().release();\n      }\n    }\n  }\n\n  /**\n   * Prune all tiles from the cache that don't have the same z as the newest tile.\n   */\n  pruneExceptNewestZ() {\n    if (this.getCount() === 0) {\n      return;\n    }\n    const key = this.peekFirstKey();\n    const tileCoord = fromKey(key);\n    const z = tileCoord[0];\n    this.forEach(tile => {\n      if (tile.tileCoord[0] !== z) {\n        this.remove(getKey(tile.tileCoord));\n        tile.release();\n      }\n    });\n  }\n}\nexport default TileCache;","map":{"version":3,"names":["LRUCache","fromKey","getKey","TileCache","clear","getCount","pop","release","expireCache","usedTiles","canExpireCache","tile","peekLast","pruneExceptNewestZ","key","peekFirstKey","tileCoord","z","forEach","remove"],"sources":["E:/Desktop/SceneryPlatform_v3.0_LTS/node_modules/ol/TileCache.js"],"sourcesContent":["/**\n * @module ol/TileCache\n */\nimport LRUCache from './structs/LRUCache.js';\nimport {fromKey, getKey} from './tilecoord.js';\n\nclass TileCache extends LRUCache {\n  clear() {\n    while (this.getCount() > 0) {\n      this.pop().release();\n    }\n    super.clear();\n  }\n\n  /**\n   * @param {!Object<string, boolean>} usedTiles Used tiles.\n   */\n  expireCache(usedTiles) {\n    while (this.canExpireCache()) {\n      const tile = this.peekLast();\n      if (tile.getKey() in usedTiles) {\n        break;\n      } else {\n        this.pop().release();\n      }\n    }\n  }\n\n  /**\n   * Prune all tiles from the cache that don't have the same z as the newest tile.\n   */\n  pruneExceptNewestZ() {\n    if (this.getCount() === 0) {\n      return;\n    }\n    const key = this.peekFirstKey();\n    const tileCoord = fromKey(key);\n    const z = tileCoord[0];\n    this.forEach((tile) => {\n      if (tile.tileCoord[0] !== z) {\n        this.remove(getKey(tile.tileCoord));\n        tile.release();\n      }\n    });\n  }\n}\n\nexport default TileCache;\n"],"mappings":"AAAA;AACA;AACA;AACA,OAAOA,QAAQ,MAAM,uBAAuB;AAC5C,SAAQC,OAAO,EAAEC,MAAM,QAAO,gBAAgB;AAE9C,MAAMC,SAAS,SAASH,QAAQ,CAAC;EAC/BI,KAAKA,CAAA,EAAG;IACN,OAAO,IAAI,CAACC,QAAQ,CAAC,CAAC,GAAG,CAAC,EAAE;MAC1B,IAAI,CAACC,GAAG,CAAC,CAAC,CAACC,OAAO,CAAC,CAAC;IACtB;IACA,KAAK,CAACH,KAAK,CAAC,CAAC;EACf;;EAEA;AACF;AACA;EACEI,WAAWA,CAACC,SAAS,EAAE;IACrB,OAAO,IAAI,CAACC,cAAc,CAAC,CAAC,EAAE;MAC5B,MAAMC,IAAI,GAAG,IAAI,CAACC,QAAQ,CAAC,CAAC;MAC5B,IAAID,IAAI,CAACT,MAAM,CAAC,CAAC,IAAIO,SAAS,EAAE;QAC9B;MACF,CAAC,MAAM;QACL,IAAI,CAACH,GAAG,CAAC,CAAC,CAACC,OAAO,CAAC,CAAC;MACtB;IACF;EACF;;EAEA;AACF;AACA;EACEM,kBAAkBA,CAAA,EAAG;IACnB,IAAI,IAAI,CAACR,QAAQ,CAAC,CAAC,KAAK,CAAC,EAAE;MACzB;IACF;IACA,MAAMS,GAAG,GAAG,IAAI,CAACC,YAAY,CAAC,CAAC;IAC/B,MAAMC,SAAS,GAAGf,OAAO,CAACa,GAAG,CAAC;IAC9B,MAAMG,CAAC,GAAGD,SAAS,CAAC,CAAC,CAAC;IACtB,IAAI,CAACE,OAAO,CAAEP,IAAI,IAAK;MACrB,IAAIA,IAAI,CAACK,SAAS,CAAC,CAAC,CAAC,KAAKC,CAAC,EAAE;QAC3B,IAAI,CAACE,MAAM,CAACjB,MAAM,CAACS,IAAI,CAACK,SAAS,CAAC,CAAC;QACnCL,IAAI,CAACJ,OAAO,CAAC,CAAC;MAChB;IACF,CAAC,CAAC;EACJ;AACF;AAEA,eAAeJ,SAAS"},"metadata":{},"sourceType":"module","externalDependencies":[]}