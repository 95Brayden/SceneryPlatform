{"ast":null,"code":"const indexOfMatch = require(\"./index-of-match.js\");\nconst indexOfMatchEnd = require(\"./index-of-match-end.js\");\nconst countSubstring = require(\"./count-substring.js\");\nfunction findTagByName(xml, tagName, options) {\n  const debug = options && options.debug || false;\n  const nested = !(options && typeof options.nested === false);\n  const startIndex = options && options.startIndex || 0;\n  if (debug) console.log(\"[xml-utils] starting findTagByName with\", tagName, \" and \", options);\n  const start = indexOfMatch(xml, `\\<${tagName}[ \\n\\>\\/]`, startIndex);\n  if (debug) console.log(\"[xml-utils] start:\", start);\n  if (start === -1) return undefined;\n  const afterStart = xml.slice(start + tagName.length);\n  let relativeEnd = indexOfMatchEnd(afterStart, \"^[^<]*[ /]>\", 0);\n  const selfClosing = relativeEnd !== -1 && afterStart[relativeEnd - 1] === \"/\";\n  if (debug) console.log(\"[xml-utils] selfClosing:\", selfClosing);\n  if (selfClosing === false) {\n    // check if tag has subtags with the same name\n    if (nested) {\n      let startIndex = 0;\n      let openings = 1;\n      let closings = 0;\n      while ((relativeEnd = indexOfMatchEnd(afterStart, \"[ /]\" + tagName + \">\", startIndex)) !== -1) {\n        const clip = afterStart.substring(startIndex, relativeEnd + 1);\n        openings += countSubstring(clip, \"<\" + tagName + \"[ \\n\\t>]\");\n        closings += countSubstring(clip, \"</\" + tagName + \">\");\n        // we can't have more openings than closings\n        if (closings >= openings) break;\n        startIndex = relativeEnd;\n      }\n    } else {\n      relativeEnd = indexOfMatchEnd(afterStart, \"[ /]\" + tagName + \">\", 0);\n    }\n  }\n  const end = start + tagName.length + relativeEnd + 1;\n  if (debug) console.log(\"[xml-utils] end:\", end);\n  if (end === -1) return undefined;\n  const outer = xml.slice(start, end);\n  // tag is like <gml:identifier codeSpace=\"OGP\">urn:ogc:def:crs:EPSG::32617</gml:identifier>\n\n  let inner;\n  if (selfClosing) {\n    inner = null;\n  } else {\n    inner = outer.slice(outer.indexOf(\">\") + 1, outer.lastIndexOf(\"<\"));\n  }\n  return {\n    inner,\n    outer,\n    start,\n    end\n  };\n}\nmodule.exports = findTagByName;\nmodule.exports.default = findTagByName;","map":{"version":3,"names":["indexOfMatch","require","indexOfMatchEnd","countSubstring","findTagByName","xml","tagName","options","debug","nested","startIndex","console","log","start","undefined","afterStart","slice","length","relativeEnd","selfClosing","openings","closings","clip","substring","end","outer","inner","indexOf","lastIndexOf","module","exports","default"],"sources":["E:/Desktop/SceneryPlatform_v3.0_LTS/node_modules/xml-utils/find-tag-by-name.js"],"sourcesContent":["const indexOfMatch = require(\"./index-of-match.js\");\nconst indexOfMatchEnd = require(\"./index-of-match-end.js\");\nconst countSubstring = require(\"./count-substring.js\");\n\nfunction findTagByName(xml, tagName, options) {\n  const debug = (options && options.debug) || false;\n  const nested = !(options && typeof options.nested === false);\n\n  const startIndex = (options && options.startIndex) || 0;\n\n  if (debug) console.log(\"[xml-utils] starting findTagByName with\", tagName, \" and \", options);\n\n  const start = indexOfMatch(xml, `\\<${tagName}[ \\n\\>\\/]`, startIndex);\n  if (debug) console.log(\"[xml-utils] start:\", start);\n  if (start === -1) return undefined;\n\n  const afterStart = xml.slice(start + tagName.length);\n\n  let relativeEnd = indexOfMatchEnd(afterStart, \"^[^<]*[ /]>\", 0);\n\n  const selfClosing = relativeEnd !== -1 && afterStart[relativeEnd - 1] === \"/\";\n  if (debug) console.log(\"[xml-utils] selfClosing:\", selfClosing);\n\n  if (selfClosing === false) {\n    // check if tag has subtags with the same name\n    if (nested) {\n      let startIndex = 0;\n      let openings = 1;\n      let closings = 0;\n      while ((relativeEnd = indexOfMatchEnd(afterStart, \"[ /]\" + tagName + \">\", startIndex)) !== -1) {\n        const clip = afterStart.substring(startIndex, relativeEnd + 1);\n        openings += countSubstring(clip, \"<\" + tagName + \"[ \\n\\t>]\");\n        closings += countSubstring(clip, \"</\" + tagName + \">\");\n        // we can't have more openings than closings\n        if (closings >= openings) break;\n        startIndex = relativeEnd;\n      }\n    } else {\n      relativeEnd = indexOfMatchEnd(afterStart, \"[ /]\" + tagName + \">\", 0);\n    }\n  }\n\n  const end = start + tagName.length + relativeEnd + 1;\n  if (debug) console.log(\"[xml-utils] end:\", end);\n  if (end === -1) return undefined;\n\n  const outer = xml.slice(start, end);\n  // tag is like <gml:identifier codeSpace=\"OGP\">urn:ogc:def:crs:EPSG::32617</gml:identifier>\n\n  let inner;\n  if (selfClosing) {\n    inner = null;\n  } else {\n    inner = outer.slice(outer.indexOf(\">\") + 1, outer.lastIndexOf(\"<\"));\n  }\n\n  return { inner, outer, start, end };\n}\n\nmodule.exports = findTagByName;\nmodule.exports.default = findTagByName;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}