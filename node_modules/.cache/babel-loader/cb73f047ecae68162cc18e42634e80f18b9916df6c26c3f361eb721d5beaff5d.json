{"ast":null,"code":"/**\n * @module ol/geom/SimpleGeometry\n */\nimport Geometry from './Geometry.js';\nimport { abstract } from '../util.js';\nimport { createOrUpdateFromFlatCoordinates, getCenter } from '../extent.js';\nimport { rotate, scale, transform2D, translate } from './flat/transform.js';\n\n/**\n * @classdesc\n * Abstract base class; only used for creating subclasses; do not instantiate\n * in apps, as cannot be rendered.\n *\n * @abstract\n * @api\n */\nclass SimpleGeometry extends Geometry {\n  constructor() {\n    super();\n\n    /**\n     * @protected\n     * @type {import(\"./Geometry.js\").GeometryLayout}\n     */\n    this.layout = 'XY';\n\n    /**\n     * @protected\n     * @type {number}\n     */\n    this.stride = 2;\n\n    /**\n     * @protected\n     * @type {Array<number>}\n     */\n    this.flatCoordinates = null;\n  }\n\n  /**\n   * @param {import(\"../extent.js\").Extent} extent Extent.\n   * @protected\n   * @return {import(\"../extent.js\").Extent} extent Extent.\n   */\n  computeExtent(extent) {\n    return createOrUpdateFromFlatCoordinates(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride, extent);\n  }\n\n  /**\n   * @abstract\n   * @return {Array<*> | null} Coordinates.\n   */\n  getCoordinates() {\n    return abstract();\n  }\n\n  /**\n   * Return the first coordinate of the geometry.\n   * @return {import(\"../coordinate.js\").Coordinate} First coordinate.\n   * @api\n   */\n  getFirstCoordinate() {\n    return this.flatCoordinates.slice(0, this.stride);\n  }\n\n  /**\n   * @return {Array<number>} Flat coordinates.\n   */\n  getFlatCoordinates() {\n    return this.flatCoordinates;\n  }\n\n  /**\n   * Return the last coordinate of the geometry.\n   * @return {import(\"../coordinate.js\").Coordinate} Last point.\n   * @api\n   */\n  getLastCoordinate() {\n    return this.flatCoordinates.slice(this.flatCoordinates.length - this.stride);\n  }\n\n  /**\n   * Return the {@link import(\"./Geometry.js\").GeometryLayout layout} of the geometry.\n   * @return {import(\"./Geometry.js\").GeometryLayout} Layout.\n   * @api\n   */\n  getLayout() {\n    return this.layout;\n  }\n\n  /**\n   * Create a simplified version of this geometry using the Douglas Peucker algorithm.\n   * @param {number} squaredTolerance Squared tolerance.\n   * @return {SimpleGeometry} Simplified geometry.\n   */\n  getSimplifiedGeometry(squaredTolerance) {\n    if (this.simplifiedGeometryRevision !== this.getRevision()) {\n      this.simplifiedGeometryMaxMinSquaredTolerance = 0;\n      this.simplifiedGeometryRevision = this.getRevision();\n    }\n    // If squaredTolerance is negative or if we know that simplification will not\n    // have any effect then just return this.\n    if (squaredTolerance < 0 || this.simplifiedGeometryMaxMinSquaredTolerance !== 0 && squaredTolerance <= this.simplifiedGeometryMaxMinSquaredTolerance) {\n      return this;\n    }\n    const simplifiedGeometry = this.getSimplifiedGeometryInternal(squaredTolerance);\n    const simplifiedFlatCoordinates = simplifiedGeometry.getFlatCoordinates();\n    if (simplifiedFlatCoordinates.length < this.flatCoordinates.length) {\n      return simplifiedGeometry;\n    }\n    // Simplification did not actually remove any coordinates.  We now know\n    // that any calls to getSimplifiedGeometry with a squaredTolerance less\n    // than or equal to the current squaredTolerance will also not have any\n    // effect.  This allows us to short circuit simplification (saving CPU\n    // cycles) and prevents the cache of simplified geometries from filling\n    // up with useless identical copies of this geometry (saving memory).\n    this.simplifiedGeometryMaxMinSquaredTolerance = squaredTolerance;\n    return this;\n  }\n\n  /**\n   * @param {number} squaredTolerance Squared tolerance.\n   * @return {SimpleGeometry} Simplified geometry.\n   * @protected\n   */\n  getSimplifiedGeometryInternal(squaredTolerance) {\n    return this;\n  }\n\n  /**\n   * @return {number} Stride.\n   */\n  getStride() {\n    return this.stride;\n  }\n\n  /**\n   * @param {import(\"./Geometry.js\").GeometryLayout} layout Layout.\n   * @param {Array<number>} flatCoordinates Flat coordinates.\n   */\n  setFlatCoordinates(layout, flatCoordinates) {\n    this.stride = getStrideForLayout(layout);\n    this.layout = layout;\n    this.flatCoordinates = flatCoordinates;\n  }\n\n  /**\n   * @abstract\n   * @param {!Array<*>} coordinates Coordinates.\n   * @param {import(\"./Geometry.js\").GeometryLayout} [layout] Layout.\n   */\n  setCoordinates(coordinates, layout) {\n    abstract();\n  }\n\n  /**\n   * @param {import(\"./Geometry.js\").GeometryLayout|undefined} layout Layout.\n   * @param {Array<*>} coordinates Coordinates.\n   * @param {number} nesting Nesting.\n   * @protected\n   */\n  setLayout(layout, coordinates, nesting) {\n    /** @type {number} */\n    let stride;\n    if (layout) {\n      stride = getStrideForLayout(layout);\n    } else {\n      for (let i = 0; i < nesting; ++i) {\n        if (coordinates.length === 0) {\n          this.layout = 'XY';\n          this.stride = 2;\n          return;\n        }\n        coordinates = /** @type {Array} */coordinates[0];\n      }\n      stride = coordinates.length;\n      layout = getLayoutForStride(stride);\n    }\n    this.layout = layout;\n    this.stride = stride;\n  }\n\n  /**\n   * Apply a transform function to the coordinates of the geometry.\n   * The geometry is modified in place.\n   * If you do not want the geometry modified in place, first `clone()` it and\n   * then use this function on the clone.\n   * @param {import(\"../proj.js\").TransformFunction} transformFn Transform function.\n   * Called with a flat array of geometry coordinates.\n   * @api\n   */\n  applyTransform(transformFn) {\n    if (this.flatCoordinates) {\n      transformFn(this.flatCoordinates, this.flatCoordinates, this.stride);\n      this.changed();\n    }\n  }\n\n  /**\n   * Rotate the geometry around a given coordinate. This modifies the geometry\n   * coordinates in place.\n   * @param {number} angle Rotation angle in counter-clockwise radians.\n   * @param {import(\"../coordinate.js\").Coordinate} anchor The rotation center.\n   * @api\n   */\n  rotate(angle, anchor) {\n    const flatCoordinates = this.getFlatCoordinates();\n    if (flatCoordinates) {\n      const stride = this.getStride();\n      rotate(flatCoordinates, 0, flatCoordinates.length, stride, angle, anchor, flatCoordinates);\n      this.changed();\n    }\n  }\n\n  /**\n   * Scale the geometry (with an optional origin).  This modifies the geometry\n   * coordinates in place.\n   * @param {number} sx The scaling factor in the x-direction.\n   * @param {number} [sy] The scaling factor in the y-direction (defaults to sx).\n   * @param {import(\"../coordinate.js\").Coordinate} [anchor] The scale origin (defaults to the center\n   *     of the geometry extent).\n   * @api\n   */\n  scale(sx, sy, anchor) {\n    if (sy === undefined) {\n      sy = sx;\n    }\n    if (!anchor) {\n      anchor = getCenter(this.getExtent());\n    }\n    const flatCoordinates = this.getFlatCoordinates();\n    if (flatCoordinates) {\n      const stride = this.getStride();\n      scale(flatCoordinates, 0, flatCoordinates.length, stride, sx, sy, anchor, flatCoordinates);\n      this.changed();\n    }\n  }\n\n  /**\n   * Translate the geometry.  This modifies the geometry coordinates in place.  If\n   * instead you want a new geometry, first `clone()` this geometry.\n   * @param {number} deltaX Delta X.\n   * @param {number} deltaY Delta Y.\n   * @api\n   */\n  translate(deltaX, deltaY) {\n    const flatCoordinates = this.getFlatCoordinates();\n    if (flatCoordinates) {\n      const stride = this.getStride();\n      translate(flatCoordinates, 0, flatCoordinates.length, stride, deltaX, deltaY, flatCoordinates);\n      this.changed();\n    }\n  }\n}\n\n/**\n * @param {number} stride Stride.\n * @return {import(\"./Geometry.js\").GeometryLayout} layout Layout.\n */\nfunction getLayoutForStride(stride) {\n  let layout;\n  if (stride == 2) {\n    layout = 'XY';\n  } else if (stride == 3) {\n    layout = 'XYZ';\n  } else if (stride == 4) {\n    layout = 'XYZM';\n  }\n  return (/** @type {import(\"./Geometry.js\").GeometryLayout} */layout\n  );\n}\n\n/**\n * @param {import(\"./Geometry.js\").GeometryLayout} layout Layout.\n * @return {number} Stride.\n */\nexport function getStrideForLayout(layout) {\n  let stride;\n  if (layout == 'XY') {\n    stride = 2;\n  } else if (layout == 'XYZ' || layout == 'XYM') {\n    stride = 3;\n  } else if (layout == 'XYZM') {\n    stride = 4;\n  }\n  return (/** @type {number} */stride\n  );\n}\n\n/**\n * @param {SimpleGeometry} simpleGeometry Simple geometry.\n * @param {import(\"../transform.js\").Transform} transform Transform.\n * @param {Array<number>} [dest] Destination.\n * @return {Array<number>} Transformed flat coordinates.\n */\nexport function transformGeom2D(simpleGeometry, transform, dest) {\n  const flatCoordinates = simpleGeometry.getFlatCoordinates();\n  if (!flatCoordinates) {\n    return null;\n  }\n  const stride = simpleGeometry.getStride();\n  return transform2D(flatCoordinates, 0, flatCoordinates.length, stride, transform, dest);\n}\nexport default SimpleGeometry;","map":{"version":3,"names":["Geometry","abstract","createOrUpdateFromFlatCoordinates","getCenter","rotate","scale","transform2D","translate","SimpleGeometry","constructor","layout","stride","flatCoordinates","computeExtent","extent","length","getCoordinates","getFirstCoordinate","slice","getFlatCoordinates","getLastCoordinate","getLayout","getSimplifiedGeometry","squaredTolerance","simplifiedGeometryRevision","getRevision","simplifiedGeometryMaxMinSquaredTolerance","simplifiedGeometry","getSimplifiedGeometryInternal","simplifiedFlatCoordinates","getStride","setFlatCoordinates","getStrideForLayout","setCoordinates","coordinates","setLayout","nesting","i","getLayoutForStride","applyTransform","transformFn","changed","angle","anchor","sx","sy","undefined","getExtent","deltaX","deltaY","transformGeom2D","simpleGeometry","transform","dest"],"sources":["E:/Desktop/scenerymonitor/node_modules/ol/geom/SimpleGeometry.js"],"sourcesContent":["/**\n * @module ol/geom/SimpleGeometry\n */\nimport Geometry from './Geometry.js';\nimport {abstract} from '../util.js';\nimport {createOrUpdateFromFlatCoordinates, getCenter} from '../extent.js';\nimport {rotate, scale, transform2D, translate} from './flat/transform.js';\n\n/**\n * @classdesc\n * Abstract base class; only used for creating subclasses; do not instantiate\n * in apps, as cannot be rendered.\n *\n * @abstract\n * @api\n */\nclass SimpleGeometry extends Geometry {\n  constructor() {\n    super();\n\n    /**\n     * @protected\n     * @type {import(\"./Geometry.js\").GeometryLayout}\n     */\n    this.layout = 'XY';\n\n    /**\n     * @protected\n     * @type {number}\n     */\n    this.stride = 2;\n\n    /**\n     * @protected\n     * @type {Array<number>}\n     */\n    this.flatCoordinates = null;\n  }\n\n  /**\n   * @param {import(\"../extent.js\").Extent} extent Extent.\n   * @protected\n   * @return {import(\"../extent.js\").Extent} extent Extent.\n   */\n  computeExtent(extent) {\n    return createOrUpdateFromFlatCoordinates(\n      this.flatCoordinates,\n      0,\n      this.flatCoordinates.length,\n      this.stride,\n      extent\n    );\n  }\n\n  /**\n   * @abstract\n   * @return {Array<*> | null} Coordinates.\n   */\n  getCoordinates() {\n    return abstract();\n  }\n\n  /**\n   * Return the first coordinate of the geometry.\n   * @return {import(\"../coordinate.js\").Coordinate} First coordinate.\n   * @api\n   */\n  getFirstCoordinate() {\n    return this.flatCoordinates.slice(0, this.stride);\n  }\n\n  /**\n   * @return {Array<number>} Flat coordinates.\n   */\n  getFlatCoordinates() {\n    return this.flatCoordinates;\n  }\n\n  /**\n   * Return the last coordinate of the geometry.\n   * @return {import(\"../coordinate.js\").Coordinate} Last point.\n   * @api\n   */\n  getLastCoordinate() {\n    return this.flatCoordinates.slice(\n      this.flatCoordinates.length - this.stride\n    );\n  }\n\n  /**\n   * Return the {@link import(\"./Geometry.js\").GeometryLayout layout} of the geometry.\n   * @return {import(\"./Geometry.js\").GeometryLayout} Layout.\n   * @api\n   */\n  getLayout() {\n    return this.layout;\n  }\n\n  /**\n   * Create a simplified version of this geometry using the Douglas Peucker algorithm.\n   * @param {number} squaredTolerance Squared tolerance.\n   * @return {SimpleGeometry} Simplified geometry.\n   */\n  getSimplifiedGeometry(squaredTolerance) {\n    if (this.simplifiedGeometryRevision !== this.getRevision()) {\n      this.simplifiedGeometryMaxMinSquaredTolerance = 0;\n      this.simplifiedGeometryRevision = this.getRevision();\n    }\n    // If squaredTolerance is negative or if we know that simplification will not\n    // have any effect then just return this.\n    if (\n      squaredTolerance < 0 ||\n      (this.simplifiedGeometryMaxMinSquaredTolerance !== 0 &&\n        squaredTolerance <= this.simplifiedGeometryMaxMinSquaredTolerance)\n    ) {\n      return this;\n    }\n\n    const simplifiedGeometry =\n      this.getSimplifiedGeometryInternal(squaredTolerance);\n    const simplifiedFlatCoordinates = simplifiedGeometry.getFlatCoordinates();\n    if (simplifiedFlatCoordinates.length < this.flatCoordinates.length) {\n      return simplifiedGeometry;\n    }\n    // Simplification did not actually remove any coordinates.  We now know\n    // that any calls to getSimplifiedGeometry with a squaredTolerance less\n    // than or equal to the current squaredTolerance will also not have any\n    // effect.  This allows us to short circuit simplification (saving CPU\n    // cycles) and prevents the cache of simplified geometries from filling\n    // up with useless identical copies of this geometry (saving memory).\n    this.simplifiedGeometryMaxMinSquaredTolerance = squaredTolerance;\n    return this;\n  }\n\n  /**\n   * @param {number} squaredTolerance Squared tolerance.\n   * @return {SimpleGeometry} Simplified geometry.\n   * @protected\n   */\n  getSimplifiedGeometryInternal(squaredTolerance) {\n    return this;\n  }\n\n  /**\n   * @return {number} Stride.\n   */\n  getStride() {\n    return this.stride;\n  }\n\n  /**\n   * @param {import(\"./Geometry.js\").GeometryLayout} layout Layout.\n   * @param {Array<number>} flatCoordinates Flat coordinates.\n   */\n  setFlatCoordinates(layout, flatCoordinates) {\n    this.stride = getStrideForLayout(layout);\n    this.layout = layout;\n    this.flatCoordinates = flatCoordinates;\n  }\n\n  /**\n   * @abstract\n   * @param {!Array<*>} coordinates Coordinates.\n   * @param {import(\"./Geometry.js\").GeometryLayout} [layout] Layout.\n   */\n  setCoordinates(coordinates, layout) {\n    abstract();\n  }\n\n  /**\n   * @param {import(\"./Geometry.js\").GeometryLayout|undefined} layout Layout.\n   * @param {Array<*>} coordinates Coordinates.\n   * @param {number} nesting Nesting.\n   * @protected\n   */\n  setLayout(layout, coordinates, nesting) {\n    /** @type {number} */\n    let stride;\n    if (layout) {\n      stride = getStrideForLayout(layout);\n    } else {\n      for (let i = 0; i < nesting; ++i) {\n        if (coordinates.length === 0) {\n          this.layout = 'XY';\n          this.stride = 2;\n          return;\n        }\n        coordinates = /** @type {Array} */ (coordinates[0]);\n      }\n      stride = coordinates.length;\n      layout = getLayoutForStride(stride);\n    }\n    this.layout = layout;\n    this.stride = stride;\n  }\n\n  /**\n   * Apply a transform function to the coordinates of the geometry.\n   * The geometry is modified in place.\n   * If you do not want the geometry modified in place, first `clone()` it and\n   * then use this function on the clone.\n   * @param {import(\"../proj.js\").TransformFunction} transformFn Transform function.\n   * Called with a flat array of geometry coordinates.\n   * @api\n   */\n  applyTransform(transformFn) {\n    if (this.flatCoordinates) {\n      transformFn(this.flatCoordinates, this.flatCoordinates, this.stride);\n      this.changed();\n    }\n  }\n\n  /**\n   * Rotate the geometry around a given coordinate. This modifies the geometry\n   * coordinates in place.\n   * @param {number} angle Rotation angle in counter-clockwise radians.\n   * @param {import(\"../coordinate.js\").Coordinate} anchor The rotation center.\n   * @api\n   */\n  rotate(angle, anchor) {\n    const flatCoordinates = this.getFlatCoordinates();\n    if (flatCoordinates) {\n      const stride = this.getStride();\n      rotate(\n        flatCoordinates,\n        0,\n        flatCoordinates.length,\n        stride,\n        angle,\n        anchor,\n        flatCoordinates\n      );\n      this.changed();\n    }\n  }\n\n  /**\n   * Scale the geometry (with an optional origin).  This modifies the geometry\n   * coordinates in place.\n   * @param {number} sx The scaling factor in the x-direction.\n   * @param {number} [sy] The scaling factor in the y-direction (defaults to sx).\n   * @param {import(\"../coordinate.js\").Coordinate} [anchor] The scale origin (defaults to the center\n   *     of the geometry extent).\n   * @api\n   */\n  scale(sx, sy, anchor) {\n    if (sy === undefined) {\n      sy = sx;\n    }\n    if (!anchor) {\n      anchor = getCenter(this.getExtent());\n    }\n    const flatCoordinates = this.getFlatCoordinates();\n    if (flatCoordinates) {\n      const stride = this.getStride();\n      scale(\n        flatCoordinates,\n        0,\n        flatCoordinates.length,\n        stride,\n        sx,\n        sy,\n        anchor,\n        flatCoordinates\n      );\n      this.changed();\n    }\n  }\n\n  /**\n   * Translate the geometry.  This modifies the geometry coordinates in place.  If\n   * instead you want a new geometry, first `clone()` this geometry.\n   * @param {number} deltaX Delta X.\n   * @param {number} deltaY Delta Y.\n   * @api\n   */\n  translate(deltaX, deltaY) {\n    const flatCoordinates = this.getFlatCoordinates();\n    if (flatCoordinates) {\n      const stride = this.getStride();\n      translate(\n        flatCoordinates,\n        0,\n        flatCoordinates.length,\n        stride,\n        deltaX,\n        deltaY,\n        flatCoordinates\n      );\n      this.changed();\n    }\n  }\n}\n\n/**\n * @param {number} stride Stride.\n * @return {import(\"./Geometry.js\").GeometryLayout} layout Layout.\n */\nfunction getLayoutForStride(stride) {\n  let layout;\n  if (stride == 2) {\n    layout = 'XY';\n  } else if (stride == 3) {\n    layout = 'XYZ';\n  } else if (stride == 4) {\n    layout = 'XYZM';\n  }\n  return /** @type {import(\"./Geometry.js\").GeometryLayout} */ (layout);\n}\n\n/**\n * @param {import(\"./Geometry.js\").GeometryLayout} layout Layout.\n * @return {number} Stride.\n */\nexport function getStrideForLayout(layout) {\n  let stride;\n  if (layout == 'XY') {\n    stride = 2;\n  } else if (layout == 'XYZ' || layout == 'XYM') {\n    stride = 3;\n  } else if (layout == 'XYZM') {\n    stride = 4;\n  }\n  return /** @type {number} */ (stride);\n}\n\n/**\n * @param {SimpleGeometry} simpleGeometry Simple geometry.\n * @param {import(\"../transform.js\").Transform} transform Transform.\n * @param {Array<number>} [dest] Destination.\n * @return {Array<number>} Transformed flat coordinates.\n */\nexport function transformGeom2D(simpleGeometry, transform, dest) {\n  const flatCoordinates = simpleGeometry.getFlatCoordinates();\n  if (!flatCoordinates) {\n    return null;\n  }\n  const stride = simpleGeometry.getStride();\n  return transform2D(\n    flatCoordinates,\n    0,\n    flatCoordinates.length,\n    stride,\n    transform,\n    dest\n  );\n}\n\nexport default SimpleGeometry;\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}