{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\n/**\n * @module ol/geom/flat/orient\n */\nimport { coordinates as reverseCoordinates } from './reverse.js';\n\n/**\n * Is the linear ring oriented clockwise in a coordinate system with a bottom-left\n * coordinate origin? For a coordinate system with a top-left coordinate origin,\n * the ring's orientation is clockwise when this function returns false.\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {number} end End.\n * @param {number} stride Stride.\n * @return {boolean} Is clockwise.\n */\nexport function linearRingIsClockwise(flatCoordinates, offset, end, stride) {\n  // https://stackoverflow.com/q/1165647/clockwise-method#1165943\n  // https://github.com/OSGeo/gdal/blob/master/gdal/ogr/ogrlinearring.cpp\n  let edge = 0;\n  let x1 = flatCoordinates[end - stride];\n  let y1 = flatCoordinates[end - stride + 1];\n  for (; offset < end; offset += stride) {\n    const x2 = flatCoordinates[offset];\n    const y2 = flatCoordinates[offset + 1];\n    edge += (x2 - x1) * (y2 + y1);\n    x1 = x2;\n    y1 = y2;\n  }\n  return edge === 0 ? undefined : edge > 0;\n}\n\n/**\n * Determines if linear rings are oriented.  By default, left-hand orientation\n * is tested (first ring must be clockwise, remaining rings counter-clockwise).\n * To test for right-hand orientation, use the `right` argument.\n *\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array<number>} ends Array of end indexes.\n * @param {number} stride Stride.\n * @param {boolean} [right] Test for right-hand orientation\n *     (counter-clockwise exterior ring and clockwise interior rings).\n * @return {boolean} Rings are correctly oriented.\n */\nexport function linearRingsAreOriented(flatCoordinates, offset, ends, stride, right) {\n  right = right !== undefined ? right : false;\n  for (let i = 0, ii = ends.length; i < ii; ++i) {\n    const end = ends[i];\n    const isClockwise = linearRingIsClockwise(flatCoordinates, offset, end, stride);\n    if (i === 0) {\n      if (right && isClockwise || !right && !isClockwise) {\n        return false;\n      }\n    } else {\n      if (right && !isClockwise || !right && isClockwise) {\n        return false;\n      }\n    }\n    offset = end;\n  }\n  return true;\n}\n\n/**\n * Determines if linear rings are oriented.  By default, left-hand orientation\n * is tested (first ring must be clockwise, remaining rings counter-clockwise).\n * To test for right-hand orientation, use the `right` argument.\n *\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array<Array<number>>} endss Array of array of end indexes.\n * @param {number} stride Stride.\n * @param {boolean} [right] Test for right-hand orientation\n *     (counter-clockwise exterior ring and clockwise interior rings).\n * @return {boolean} Rings are correctly oriented.\n */\nexport function linearRingssAreOriented(flatCoordinates, offset, endss, stride, right) {\n  for (let i = 0, ii = endss.length; i < ii; ++i) {\n    const ends = endss[i];\n    if (!linearRingsAreOriented(flatCoordinates, offset, ends, stride, right)) {\n      return false;\n    }\n    if (ends.length) {\n      offset = ends[ends.length - 1];\n    }\n  }\n  return true;\n}\n\n/**\n * Orient coordinates in a flat array of linear rings.  By default, rings\n * are oriented following the left-hand rule (clockwise for exterior and\n * counter-clockwise for interior rings).  To orient according to the\n * right-hand rule, use the `right` argument.\n *\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array<number>} ends Ends.\n * @param {number} stride Stride.\n * @param {boolean} [right] Follow the right-hand rule for orientation.\n * @return {number} End.\n */\nexport function orientLinearRings(flatCoordinates, offset, ends, stride, right) {\n  right = right !== undefined ? right : false;\n  for (let i = 0, ii = ends.length; i < ii; ++i) {\n    const end = ends[i];\n    const isClockwise = linearRingIsClockwise(flatCoordinates, offset, end, stride);\n    const reverse = i === 0 ? right && isClockwise || !right && !isClockwise : right && !isClockwise || !right && isClockwise;\n    if (reverse) {\n      reverseCoordinates(flatCoordinates, offset, end, stride);\n    }\n    offset = end;\n  }\n  return offset;\n}\n\n/**\n * Orient coordinates in a flat array of linear rings.  By default, rings\n * are oriented following the left-hand rule (clockwise for exterior and\n * counter-clockwise for interior rings).  To orient according to the\n * right-hand rule, use the `right` argument.\n *\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array<Array<number>>} endss Array of array of end indexes.\n * @param {number} stride Stride.\n * @param {boolean} [right] Follow the right-hand rule for orientation.\n * @return {number} End.\n */\nexport function orientLinearRingsArray(flatCoordinates, offset, endss, stride, right) {\n  for (let i = 0, ii = endss.length; i < ii; ++i) {\n    offset = orientLinearRings(flatCoordinates, offset, endss[i], stride, right);\n  }\n  return offset;\n}\n\n/**\n * Return a two-dimensional endss\n * @param {Array<number>} flatCoordinates Flat coordinates\n * @param {Array<number>} ends Linear ring end indexes\n * @return {Array<Array<number>>} Two dimensional endss array that can\n * be used to construct a MultiPolygon\n */\nexport function inflateEnds(flatCoordinates, ends) {\n  const endss = [];\n  let offset = 0;\n  let prevEndIndex = 0;\n  for (let i = 0, ii = ends.length; i < ii; ++i) {\n    const end = ends[i];\n    // classifies an array of rings into polygons with outer rings and holes\n    if (!linearRingIsClockwise(flatCoordinates, offset, end, 2)) {\n      endss.push(ends.slice(prevEndIndex, i + 1));\n    } else {\n      if (endss.length === 0) {\n        continue;\n      }\n      endss[endss.length - 1].push(ends[prevEndIndex]);\n    }\n    prevEndIndex = i + 1;\n    offset = end;\n  }\n  return endss;\n}","map":{"version":3,"names":["coordinates","reverseCoordinates","linearRingIsClockwise","flatCoordinates","offset","end","stride","edge","x1","y1","x2","y2","undefined","linearRingsAreOriented","ends","right","i","ii","length","isClockwise","linearRingssAreOriented","endss","orientLinearRings","reverse","orientLinearRingsArray","inflateEnds","prevEndIndex","push","slice"],"sources":["E:/Desktop/SceneryPlatform_v3.0_LTS/node_modules/ol/geom/flat/orient.js"],"sourcesContent":["/**\n * @module ol/geom/flat/orient\n */\nimport {coordinates as reverseCoordinates} from './reverse.js';\n\n/**\n * Is the linear ring oriented clockwise in a coordinate system with a bottom-left\n * coordinate origin? For a coordinate system with a top-left coordinate origin,\n * the ring's orientation is clockwise when this function returns false.\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {number} end End.\n * @param {number} stride Stride.\n * @return {boolean} Is clockwise.\n */\nexport function linearRingIsClockwise(flatCoordinates, offset, end, stride) {\n  // https://stackoverflow.com/q/1165647/clockwise-method#1165943\n  // https://github.com/OSGeo/gdal/blob/master/gdal/ogr/ogrlinearring.cpp\n  let edge = 0;\n  let x1 = flatCoordinates[end - stride];\n  let y1 = flatCoordinates[end - stride + 1];\n  for (; offset < end; offset += stride) {\n    const x2 = flatCoordinates[offset];\n    const y2 = flatCoordinates[offset + 1];\n    edge += (x2 - x1) * (y2 + y1);\n    x1 = x2;\n    y1 = y2;\n  }\n  return edge === 0 ? undefined : edge > 0;\n}\n\n/**\n * Determines if linear rings are oriented.  By default, left-hand orientation\n * is tested (first ring must be clockwise, remaining rings counter-clockwise).\n * To test for right-hand orientation, use the `right` argument.\n *\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array<number>} ends Array of end indexes.\n * @param {number} stride Stride.\n * @param {boolean} [right] Test for right-hand orientation\n *     (counter-clockwise exterior ring and clockwise interior rings).\n * @return {boolean} Rings are correctly oriented.\n */\nexport function linearRingsAreOriented(\n  flatCoordinates,\n  offset,\n  ends,\n  stride,\n  right\n) {\n  right = right !== undefined ? right : false;\n  for (let i = 0, ii = ends.length; i < ii; ++i) {\n    const end = ends[i];\n    const isClockwise = linearRingIsClockwise(\n      flatCoordinates,\n      offset,\n      end,\n      stride\n    );\n    if (i === 0) {\n      if ((right && isClockwise) || (!right && !isClockwise)) {\n        return false;\n      }\n    } else {\n      if ((right && !isClockwise) || (!right && isClockwise)) {\n        return false;\n      }\n    }\n    offset = end;\n  }\n  return true;\n}\n\n/**\n * Determines if linear rings are oriented.  By default, left-hand orientation\n * is tested (first ring must be clockwise, remaining rings counter-clockwise).\n * To test for right-hand orientation, use the `right` argument.\n *\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array<Array<number>>} endss Array of array of end indexes.\n * @param {number} stride Stride.\n * @param {boolean} [right] Test for right-hand orientation\n *     (counter-clockwise exterior ring and clockwise interior rings).\n * @return {boolean} Rings are correctly oriented.\n */\nexport function linearRingssAreOriented(\n  flatCoordinates,\n  offset,\n  endss,\n  stride,\n  right\n) {\n  for (let i = 0, ii = endss.length; i < ii; ++i) {\n    const ends = endss[i];\n    if (!linearRingsAreOriented(flatCoordinates, offset, ends, stride, right)) {\n      return false;\n    }\n    if (ends.length) {\n      offset = ends[ends.length - 1];\n    }\n  }\n  return true;\n}\n\n/**\n * Orient coordinates in a flat array of linear rings.  By default, rings\n * are oriented following the left-hand rule (clockwise for exterior and\n * counter-clockwise for interior rings).  To orient according to the\n * right-hand rule, use the `right` argument.\n *\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array<number>} ends Ends.\n * @param {number} stride Stride.\n * @param {boolean} [right] Follow the right-hand rule for orientation.\n * @return {number} End.\n */\nexport function orientLinearRings(\n  flatCoordinates,\n  offset,\n  ends,\n  stride,\n  right\n) {\n  right = right !== undefined ? right : false;\n  for (let i = 0, ii = ends.length; i < ii; ++i) {\n    const end = ends[i];\n    const isClockwise = linearRingIsClockwise(\n      flatCoordinates,\n      offset,\n      end,\n      stride\n    );\n    const reverse =\n      i === 0\n        ? (right && isClockwise) || (!right && !isClockwise)\n        : (right && !isClockwise) || (!right && isClockwise);\n    if (reverse) {\n      reverseCoordinates(flatCoordinates, offset, end, stride);\n    }\n    offset = end;\n  }\n  return offset;\n}\n\n/**\n * Orient coordinates in a flat array of linear rings.  By default, rings\n * are oriented following the left-hand rule (clockwise for exterior and\n * counter-clockwise for interior rings).  To orient according to the\n * right-hand rule, use the `right` argument.\n *\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array<Array<number>>} endss Array of array of end indexes.\n * @param {number} stride Stride.\n * @param {boolean} [right] Follow the right-hand rule for orientation.\n * @return {number} End.\n */\nexport function orientLinearRingsArray(\n  flatCoordinates,\n  offset,\n  endss,\n  stride,\n  right\n) {\n  for (let i = 0, ii = endss.length; i < ii; ++i) {\n    offset = orientLinearRings(\n      flatCoordinates,\n      offset,\n      endss[i],\n      stride,\n      right\n    );\n  }\n  return offset;\n}\n\n/**\n * Return a two-dimensional endss\n * @param {Array<number>} flatCoordinates Flat coordinates\n * @param {Array<number>} ends Linear ring end indexes\n * @return {Array<Array<number>>} Two dimensional endss array that can\n * be used to construct a MultiPolygon\n */\nexport function inflateEnds(flatCoordinates, ends) {\n  const endss = [];\n  let offset = 0;\n  let prevEndIndex = 0;\n  for (let i = 0, ii = ends.length; i < ii; ++i) {\n    const end = ends[i];\n    // classifies an array of rings into polygons with outer rings and holes\n    if (!linearRingIsClockwise(flatCoordinates, offset, end, 2)) {\n      endss.push(ends.slice(prevEndIndex, i + 1));\n    } else {\n      if (endss.length === 0) {\n        continue;\n      }\n      endss[endss.length - 1].push(ends[prevEndIndex]);\n    }\n    prevEndIndex = i + 1;\n    offset = end;\n  }\n  return endss;\n}\n"],"mappings":";AAAA;AACA;AACA;AACA,SAAQA,WAAW,IAAIC,kBAAkB,QAAO,cAAc;;AAE9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASC,qBAAqBA,CAACC,eAAe,EAAEC,MAAM,EAAEC,GAAG,EAAEC,MAAM,EAAE;EAC1E;EACA;EACA,IAAIC,IAAI,GAAG,CAAC;EACZ,IAAIC,EAAE,GAAGL,eAAe,CAACE,GAAG,GAAGC,MAAM,CAAC;EACtC,IAAIG,EAAE,GAAGN,eAAe,CAACE,GAAG,GAAGC,MAAM,GAAG,CAAC,CAAC;EAC1C,OAAOF,MAAM,GAAGC,GAAG,EAAED,MAAM,IAAIE,MAAM,EAAE;IACrC,MAAMI,EAAE,GAAGP,eAAe,CAACC,MAAM,CAAC;IAClC,MAAMO,EAAE,GAAGR,eAAe,CAACC,MAAM,GAAG,CAAC,CAAC;IACtCG,IAAI,IAAI,CAACG,EAAE,GAAGF,EAAE,KAAKG,EAAE,GAAGF,EAAE,CAAC;IAC7BD,EAAE,GAAGE,EAAE;IACPD,EAAE,GAAGE,EAAE;EACT;EACA,OAAOJ,IAAI,KAAK,CAAC,GAAGK,SAAS,GAAGL,IAAI,GAAG,CAAC;AAC1C;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASM,sBAAsBA,CACpCV,eAAe,EACfC,MAAM,EACNU,IAAI,EACJR,MAAM,EACNS,KAAK,EACL;EACAA,KAAK,GAAGA,KAAK,KAAKH,SAAS,GAAGG,KAAK,GAAG,KAAK;EAC3C,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEC,EAAE,GAAGH,IAAI,CAACI,MAAM,EAAEF,CAAC,GAAGC,EAAE,EAAE,EAAED,CAAC,EAAE;IAC7C,MAAMX,GAAG,GAAGS,IAAI,CAACE,CAAC,CAAC;IACnB,MAAMG,WAAW,GAAGjB,qBAAqB,CACvCC,eAAe,EACfC,MAAM,EACNC,GAAG,EACHC,MACF,CAAC;IACD,IAAIU,CAAC,KAAK,CAAC,EAAE;MACX,IAAKD,KAAK,IAAII,WAAW,IAAM,CAACJ,KAAK,IAAI,CAACI,WAAY,EAAE;QACtD,OAAO,KAAK;MACd;IACF,CAAC,MAAM;MACL,IAAKJ,KAAK,IAAI,CAACI,WAAW,IAAM,CAACJ,KAAK,IAAII,WAAY,EAAE;QACtD,OAAO,KAAK;MACd;IACF;IACAf,MAAM,GAAGC,GAAG;EACd;EACA,OAAO,IAAI;AACb;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASe,uBAAuBA,CACrCjB,eAAe,EACfC,MAAM,EACNiB,KAAK,EACLf,MAAM,EACNS,KAAK,EACL;EACA,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEC,EAAE,GAAGI,KAAK,CAACH,MAAM,EAAEF,CAAC,GAAGC,EAAE,EAAE,EAAED,CAAC,EAAE;IAC9C,MAAMF,IAAI,GAAGO,KAAK,CAACL,CAAC,CAAC;IACrB,IAAI,CAACH,sBAAsB,CAACV,eAAe,EAAEC,MAAM,EAAEU,IAAI,EAAER,MAAM,EAAES,KAAK,CAAC,EAAE;MACzE,OAAO,KAAK;IACd;IACA,IAAID,IAAI,CAACI,MAAM,EAAE;MACfd,MAAM,GAAGU,IAAI,CAACA,IAAI,CAACI,MAAM,GAAG,CAAC,CAAC;IAChC;EACF;EACA,OAAO,IAAI;AACb;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASI,iBAAiBA,CAC/BnB,eAAe,EACfC,MAAM,EACNU,IAAI,EACJR,MAAM,EACNS,KAAK,EACL;EACAA,KAAK,GAAGA,KAAK,KAAKH,SAAS,GAAGG,KAAK,GAAG,KAAK;EAC3C,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEC,EAAE,GAAGH,IAAI,CAACI,MAAM,EAAEF,CAAC,GAAGC,EAAE,EAAE,EAAED,CAAC,EAAE;IAC7C,MAAMX,GAAG,GAAGS,IAAI,CAACE,CAAC,CAAC;IACnB,MAAMG,WAAW,GAAGjB,qBAAqB,CACvCC,eAAe,EACfC,MAAM,EACNC,GAAG,EACHC,MACF,CAAC;IACD,MAAMiB,OAAO,GACXP,CAAC,KAAK,CAAC,GACFD,KAAK,IAAII,WAAW,IAAM,CAACJ,KAAK,IAAI,CAACI,WAAY,GACjDJ,KAAK,IAAI,CAACI,WAAW,IAAM,CAACJ,KAAK,IAAII,WAAY;IACxD,IAAII,OAAO,EAAE;MACXtB,kBAAkB,CAACE,eAAe,EAAEC,MAAM,EAAEC,GAAG,EAAEC,MAAM,CAAC;IAC1D;IACAF,MAAM,GAAGC,GAAG;EACd;EACA,OAAOD,MAAM;AACf;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASoB,sBAAsBA,CACpCrB,eAAe,EACfC,MAAM,EACNiB,KAAK,EACLf,MAAM,EACNS,KAAK,EACL;EACA,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEC,EAAE,GAAGI,KAAK,CAACH,MAAM,EAAEF,CAAC,GAAGC,EAAE,EAAE,EAAED,CAAC,EAAE;IAC9CZ,MAAM,GAAGkB,iBAAiB,CACxBnB,eAAe,EACfC,MAAM,EACNiB,KAAK,CAACL,CAAC,CAAC,EACRV,MAAM,EACNS,KACF,CAAC;EACH;EACA,OAAOX,MAAM;AACf;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASqB,WAAWA,CAACtB,eAAe,EAAEW,IAAI,EAAE;EACjD,MAAMO,KAAK,GAAG,EAAE;EAChB,IAAIjB,MAAM,GAAG,CAAC;EACd,IAAIsB,YAAY,GAAG,CAAC;EACpB,KAAK,IAAIV,CAAC,GAAG,CAAC,EAAEC,EAAE,GAAGH,IAAI,CAACI,MAAM,EAAEF,CAAC,GAAGC,EAAE,EAAE,EAAED,CAAC,EAAE;IAC7C,MAAMX,GAAG,GAAGS,IAAI,CAACE,CAAC,CAAC;IACnB;IACA,IAAI,CAACd,qBAAqB,CAACC,eAAe,EAAEC,MAAM,EAAEC,GAAG,EAAE,CAAC,CAAC,EAAE;MAC3DgB,KAAK,CAACM,IAAI,CAACb,IAAI,CAACc,KAAK,CAACF,YAAY,EAAEV,CAAC,GAAG,CAAC,CAAC,CAAC;IAC7C,CAAC,MAAM;MACL,IAAIK,KAAK,CAACH,MAAM,KAAK,CAAC,EAAE;QACtB;MACF;MACAG,KAAK,CAACA,KAAK,CAACH,MAAM,GAAG,CAAC,CAAC,CAACS,IAAI,CAACb,IAAI,CAACY,YAAY,CAAC,CAAC;IAClD;IACAA,YAAY,GAAGV,CAAC,GAAG,CAAC;IACpBZ,MAAM,GAAGC,GAAG;EACd;EACA,OAAOgB,KAAK;AACd"},"metadata":{},"sourceType":"module","externalDependencies":[]}