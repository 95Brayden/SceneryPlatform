{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\n/**\n * @module ol/expr/expression\n */\n\nimport { ascending } from '../array.js';\n\n/**\n * @fileoverview This module includes types and functions for parsing array encoded expressions.\n * The result of parsing an encoded expression is one of the specific expression classes.\n * During parsing, information is added to the parsing context about the data accessed by the\n * expression.\n */\n\nlet numTypes = 0;\nexport const NoneType = 0;\nexport const BooleanType = 1 << numTypes++;\nexport const NumberType = 1 << numTypes++;\nexport const StringType = 1 << numTypes++;\nexport const ColorType = 1 << numTypes++;\nexport const NumberArrayType = 1 << numTypes++;\nexport const AnyType = Math.pow(2, numTypes) - 1;\nconst typeNames = {\n  [BooleanType]: 'boolean',\n  [NumberType]: 'number',\n  [StringType]: 'string',\n  [ColorType]: 'color',\n  [NumberArrayType]: 'number[]'\n};\nconst namedTypes = Object.keys(typeNames).map(Number).sort(ascending);\n\n/**\n * Get a string representation for a type.\n * @param {number} type The type.\n * @return {string} The type name.\n */\nexport function typeName(type) {\n  const names = [];\n  for (const namedType of namedTypes) {\n    if (includesType(type, namedType)) {\n      names.push(typeNames[namedType]);\n    }\n  }\n  if (names.length === 0) {\n    return 'untyped';\n  }\n  if (names.length < 3) {\n    return names.join(' or ');\n  }\n  return names.slice(0, -1).join(', ') + ', or ' + names[names.length - 1];\n}\n\n/**\n * @param {number} broad The broad type.\n * @param {number} specific The specific type.\n * @return {boolean} The broad type includes the specific type.\n */\nexport function includesType(broad, specific) {\n  return (broad & specific) === specific;\n}\n\n/**\n * @param {number} oneType One type.\n * @param {number} otherType Another type.\n * @return {boolean} The set of types overlap (share a common specific type)\n */\nexport function overlapsType(oneType, otherType) {\n  return !!(oneType & otherType);\n}\n\n/**\n * @param {number} type The type.\n * @param {number} expected The expected type.\n * @return {boolean} The given type is exactly the expected type.\n */\nexport function isType(type, expected) {\n  return type === expected;\n}\n\n/**\n * @typedef {boolean|number|string|Array<number>} LiteralValue\n */\n\nexport class LiteralExpression {\n  /**\n   * @param {number} type The value type.\n   * @param {LiteralValue} value The literal value.\n   */\n  constructor(type, value) {\n    this.type = type;\n    this.value = value;\n  }\n}\nexport class CallExpression {\n  /**\n   * @param {number} type The return type.\n   * @param {string} operator The operator.\n   * @param {...Expression} args The arguments.\n   */\n  constructor(type, operator, ...args) {\n    this.type = type;\n    this.operator = operator;\n    this.args = args;\n  }\n}\n\n/**\n * @typedef {LiteralExpression|CallExpression} Expression\n */\n\n/**\n * @typedef {Object} ParsingContext\n * @property {Set<string>} variables Variables referenced with the 'var' operator.\n * @property {Set<string>} properties Properties referenced with the 'get' operator.\n */\n\n/**\n * @return {ParsingContext} A new parsing context.\n */\nexport function newParsingContext() {\n  return {\n    variables: new Set(),\n    properties: new Set()\n  };\n}\n\n/**\n * @typedef {LiteralValue|Array} EncodedExpression\n */\n\n/**\n * @param {EncodedExpression} encoded The encoded expression.\n * @param {ParsingContext} context The parsing context.\n * @return {Expression} The parsed expression result.\n */\nexport function parse(encoded, context) {\n  switch (typeof encoded) {\n    case 'boolean':\n      {\n        return new LiteralExpression(BooleanType, encoded);\n      }\n    case 'number':\n      {\n        return new LiteralExpression(NumberType, encoded);\n      }\n    case 'string':\n      {\n        return new LiteralExpression(StringType, encoded);\n      }\n    default:\n      {\n        // pass\n      }\n  }\n  if (!Array.isArray(encoded)) {\n    throw new Error('Expression must be an array or a primitive value');\n  }\n  if (encoded.length === 0) {\n    throw new Error('Empty expression');\n  }\n  if (typeof encoded[0] === 'string') {\n    return parseCallExpression(encoded, context);\n  }\n  for (const item of encoded) {\n    if (typeof item !== 'number') {\n      throw new Error('Expected an array of numbers');\n    }\n  }\n  let type = NumberArrayType;\n  if (encoded.length === 3 || encoded.length === 4) {\n    type |= ColorType;\n  }\n  return new LiteralExpression(type, encoded);\n}\n\n/**\n * @type {Object<string, string>}\n */\nexport const Ops = {\n  Number: 'number',\n  String: 'string',\n  Get: 'get',\n  Var: 'var',\n  Any: 'any',\n  All: 'all',\n  Not: '!',\n  Resolution: 'resolution',\n  Equal: '==',\n  NotEqual: '!=',\n  GreaterThan: '>',\n  GreaterThanOrEqualTo: '>=',\n  LessThan: '<',\n  LessThanOrEqualTo: '<=',\n  Multiply: '*',\n  Divide: '/',\n  Add: '+',\n  Subtract: '-',\n  Clamp: 'clamp',\n  Mod: '%',\n  Pow: '^',\n  Abs: 'abs',\n  Floor: 'floor',\n  Ceil: 'ceil',\n  Round: 'round',\n  Sin: 'sin',\n  Cos: 'cos',\n  Atan: 'atan',\n  Sqrt: 'sqrt',\n  Match: 'match'\n};\n\n/**\n * @typedef {function(Array, ParsingContext):Expression} Parser\n */\n\n/**\n * @type {Object<string, Parser>}\n */\nconst parsers = {\n  [Ops.Number]: createParser(withArgs(1, Infinity, AnyType), NumberType),\n  [Ops.String]: createParser(withArgs(1, Infinity, AnyType), StringType),\n  [Ops.Get]: createParser(withGetArgs, AnyType),\n  [Ops.Var]: createParser(withVarArgs, AnyType),\n  [Ops.Resolution]: createParser(withNoArgs, NumberType),\n  [Ops.Any]: createParser(withArgs(2, Infinity, BooleanType), BooleanType),\n  [Ops.All]: createParser(withArgs(2, Infinity, BooleanType), BooleanType),\n  [Ops.Not]: createParser(withArgs(1, 1, BooleanType), BooleanType),\n  [Ops.Equal]: createParser(withArgs(2, 2, AnyType), BooleanType),\n  [Ops.NotEqual]: createParser(withArgs(2, 2, AnyType), BooleanType),\n  [Ops.GreaterThan]: createParser(withArgs(2, 2, AnyType), BooleanType),\n  [Ops.GreaterThanOrEqualTo]: createParser(withArgs(2, 2, AnyType), BooleanType),\n  [Ops.LessThan]: createParser(withArgs(2, 2, AnyType), BooleanType),\n  [Ops.LessThanOrEqualTo]: createParser(withArgs(2, 2, AnyType), BooleanType),\n  [Ops.Multiply]: createParser(withArgs(2, Infinity, NumberType), NumberType),\n  [Ops.Divide]: createParser(withArgs(2, 2, NumberType), NumberType),\n  [Ops.Add]: createParser(withArgs(2, Infinity, NumberType), NumberType),\n  [Ops.Subtract]: createParser(withArgs(2, 2, NumberType), NumberType),\n  [Ops.Clamp]: createParser(withArgs(3, 3, NumberType), NumberType),\n  [Ops.Mod]: createParser(withArgs(2, 2, NumberType), NumberType),\n  [Ops.Pow]: createParser(withArgs(2, 2, NumberType), NumberType),\n  [Ops.Abs]: createParser(withArgs(1, 1, NumberType), NumberType),\n  [Ops.Floor]: createParser(withArgs(1, 1, NumberType), NumberType),\n  [Ops.Ceil]: createParser(withArgs(1, 1, NumberType), NumberType),\n  [Ops.Round]: createParser(withArgs(1, 1, NumberType), NumberType),\n  [Ops.Sin]: createParser(withArgs(1, 1, NumberType), NumberType),\n  [Ops.Cos]: createParser(withArgs(1, 1, NumberType), NumberType),\n  [Ops.Atan]: createParser(withArgs(1, 2, NumberType), NumberType),\n  [Ops.Sqrt]: createParser(withArgs(1, 1, NumberType), NumberType),\n  [Ops.Match]: createParser(withArgs(4, Infinity, StringType | NumberType), AnyType)\n};\n\n/**\n * @typedef {function(Array, ParsingContext):Array<Expression>} ArgValidator\n */\n\n/**\n * @type ArgValidator\n */\nfunction withGetArgs(encoded, context) {\n  if (encoded.length !== 2) {\n    throw new Error('Expected 1 argument for get operation');\n  }\n  const arg = parse(encoded[1], context);\n  if (!(arg instanceof LiteralExpression)) {\n    throw new Error('Expected a literal argument for get operation');\n  }\n  if (typeof arg.value !== 'string') {\n    throw new Error('Expected a string argument for get operation');\n  }\n  context.properties.add(arg.value);\n  return [arg];\n}\n\n/**\n * @type ArgValidator\n */\nfunction withVarArgs(encoded, context) {\n  if (encoded.length !== 2) {\n    throw new Error('Expected 1 argument for var operation');\n  }\n  const arg = parse(encoded[1], context);\n  if (!(arg instanceof LiteralExpression)) {\n    throw new Error('Expected a literal argument for var operation');\n  }\n  if (typeof arg.value !== 'string') {\n    throw new Error('Expected a string argument for get operation');\n  }\n  context.variables.add(arg.value);\n  return [arg];\n}\n\n/**\n * @type ArgValidator\n */\nfunction withNoArgs(encoded, context) {\n  const operation = encoded[0];\n  if (encoded.length !== 1) {\n    throw new Error(`Expected no arguments for ${operation} operation`);\n  }\n  return [];\n}\n\n/**\n * @param {number} minArgs The minimum number of arguments.\n * @param {number} maxArgs The maximum number of arguments.\n * @param {number} argType The argument type.\n * @return {ArgValidator} The argument validator\n */\nfunction withArgs(minArgs, maxArgs, argType) {\n  return function (encoded, context) {\n    const operation = encoded[0];\n    const argCount = encoded.length - 1;\n    if (minArgs === maxArgs) {\n      if (argCount !== minArgs) {\n        const plural = minArgs === 1 ? '' : 's';\n        throw new Error(`Expected ${minArgs} argument${plural} for operation ${operation}, got ${argCount}`);\n      }\n    } else if (argCount < minArgs || argCount > maxArgs) {\n      throw new Error(`Expected ${minArgs} to ${maxArgs} arguments for operation ${operation}, got ${argCount}`);\n    }\n\n    /**\n     * @type {Array<Expression>}\n     */\n    const args = new Array(argCount);\n    for (let i = 0; i < argCount; ++i) {\n      const expression = parse(encoded[i + 1], context);\n      if (!overlapsType(argType, expression.type)) {\n        const gotType = typeName(argType);\n        const expectedType = typeName(expression.type);\n        throw new Error(`Unexpected type for argument ${i} of ${operation} operation` + ` : got ${gotType} but expected ${expectedType}`);\n      }\n      args[i] = expression;\n    }\n    return args;\n  };\n}\n\n/**\n * @param {ArgValidator} argValidator The argument validator.\n * @param {number} returnType The return type.\n * @return {Parser} The parser.\n */\nfunction createParser(argValidator, returnType) {\n  return function (encoded, context) {\n    const operator = encoded[0];\n    const args = argValidator(encoded, context);\n    return new CallExpression(returnType, operator, ...args);\n  };\n}\n\n/**\n * @param {Array} encoded The encoded expression.\n * @param {ParsingContext} context The parsing context.\n * @return {Expression} The parsed expression.\n */\nfunction parseCallExpression(encoded, context) {\n  const operator = encoded[0];\n  const parser = parsers[operator];\n  if (!parser) {\n    throw new Error(`Unknown operator: ${operator}`);\n  }\n  return parser(encoded, context);\n}","map":{"version":3,"names":["ascending","numTypes","NoneType","BooleanType","NumberType","StringType","ColorType","NumberArrayType","AnyType","Math","pow","typeNames","namedTypes","Object","keys","map","Number","sort","typeName","type","names","namedType","includesType","push","length","join","slice","broad","specific","overlapsType","oneType","otherType","isType","expected","LiteralExpression","constructor","value","CallExpression","operator","args","newParsingContext","variables","Set","properties","parse","encoded","context","Array","isArray","Error","parseCallExpression","item","Ops","String","Get","Var","Any","All","Not","Resolution","Equal","NotEqual","GreaterThan","GreaterThanOrEqualTo","LessThan","LessThanOrEqualTo","Multiply","Divide","Add","Subtract","Clamp","Mod","Pow","Abs","Floor","Ceil","Round","Sin","Cos","Atan","Sqrt","Match","parsers","createParser","withArgs","Infinity","withGetArgs","withVarArgs","withNoArgs","arg","add","operation","minArgs","maxArgs","argType","argCount","plural","i","expression","gotType","expectedType","argValidator","returnType","parser"],"sources":["E:/Desktop/SceneryPlatform_v3.0_LTS/node_modules/ol/expr/expression.js"],"sourcesContent":["/**\n * @module ol/expr/expression\n */\n\nimport {ascending} from '../array.js';\n\n/**\n * @fileoverview This module includes types and functions for parsing array encoded expressions.\n * The result of parsing an encoded expression is one of the specific expression classes.\n * During parsing, information is added to the parsing context about the data accessed by the\n * expression.\n */\n\nlet numTypes = 0;\nexport const NoneType = 0;\nexport const BooleanType = 1 << numTypes++;\nexport const NumberType = 1 << numTypes++;\nexport const StringType = 1 << numTypes++;\nexport const ColorType = 1 << numTypes++;\nexport const NumberArrayType = 1 << numTypes++;\nexport const AnyType = Math.pow(2, numTypes) - 1;\n\nconst typeNames = {\n  [BooleanType]: 'boolean',\n  [NumberType]: 'number',\n  [StringType]: 'string',\n  [ColorType]: 'color',\n  [NumberArrayType]: 'number[]',\n};\n\nconst namedTypes = Object.keys(typeNames).map(Number).sort(ascending);\n\n/**\n * Get a string representation for a type.\n * @param {number} type The type.\n * @return {string} The type name.\n */\nexport function typeName(type) {\n  const names = [];\n  for (const namedType of namedTypes) {\n    if (includesType(type, namedType)) {\n      names.push(typeNames[namedType]);\n    }\n  }\n  if (names.length === 0) {\n    return 'untyped';\n  }\n  if (names.length < 3) {\n    return names.join(' or ');\n  }\n  return names.slice(0, -1).join(', ') + ', or ' + names[names.length - 1];\n}\n\n/**\n * @param {number} broad The broad type.\n * @param {number} specific The specific type.\n * @return {boolean} The broad type includes the specific type.\n */\nexport function includesType(broad, specific) {\n  return (broad & specific) === specific;\n}\n\n/**\n * @param {number} oneType One type.\n * @param {number} otherType Another type.\n * @return {boolean} The set of types overlap (share a common specific type)\n */\nexport function overlapsType(oneType, otherType) {\n  return !!(oneType & otherType);\n}\n\n/**\n * @param {number} type The type.\n * @param {number} expected The expected type.\n * @return {boolean} The given type is exactly the expected type.\n */\nexport function isType(type, expected) {\n  return type === expected;\n}\n\n/**\n * @typedef {boolean|number|string|Array<number>} LiteralValue\n */\n\nexport class LiteralExpression {\n  /**\n   * @param {number} type The value type.\n   * @param {LiteralValue} value The literal value.\n   */\n  constructor(type, value) {\n    this.type = type;\n    this.value = value;\n  }\n}\n\nexport class CallExpression {\n  /**\n   * @param {number} type The return type.\n   * @param {string} operator The operator.\n   * @param {...Expression} args The arguments.\n   */\n  constructor(type, operator, ...args) {\n    this.type = type;\n    this.operator = operator;\n    this.args = args;\n  }\n}\n\n/**\n * @typedef {LiteralExpression|CallExpression} Expression\n */\n\n/**\n * @typedef {Object} ParsingContext\n * @property {Set<string>} variables Variables referenced with the 'var' operator.\n * @property {Set<string>} properties Properties referenced with the 'get' operator.\n */\n\n/**\n * @return {ParsingContext} A new parsing context.\n */\nexport function newParsingContext() {\n  return {\n    variables: new Set(),\n    properties: new Set(),\n  };\n}\n\n/**\n * @typedef {LiteralValue|Array} EncodedExpression\n */\n\n/**\n * @param {EncodedExpression} encoded The encoded expression.\n * @param {ParsingContext} context The parsing context.\n * @return {Expression} The parsed expression result.\n */\nexport function parse(encoded, context) {\n  switch (typeof encoded) {\n    case 'boolean': {\n      return new LiteralExpression(BooleanType, encoded);\n    }\n    case 'number': {\n      return new LiteralExpression(NumberType, encoded);\n    }\n    case 'string': {\n      return new LiteralExpression(StringType, encoded);\n    }\n    default: {\n      // pass\n    }\n  }\n\n  if (!Array.isArray(encoded)) {\n    throw new Error('Expression must be an array or a primitive value');\n  }\n\n  if (encoded.length === 0) {\n    throw new Error('Empty expression');\n  }\n\n  if (typeof encoded[0] === 'string') {\n    return parseCallExpression(encoded, context);\n  }\n\n  for (const item of encoded) {\n    if (typeof item !== 'number') {\n      throw new Error('Expected an array of numbers');\n    }\n  }\n\n  let type = NumberArrayType;\n  if (encoded.length === 3 || encoded.length === 4) {\n    type |= ColorType;\n  }\n\n  return new LiteralExpression(type, encoded);\n}\n\n/**\n * @type {Object<string, string>}\n */\nexport const Ops = {\n  Number: 'number',\n  String: 'string',\n  Get: 'get',\n  Var: 'var',\n  Any: 'any',\n  All: 'all',\n  Not: '!',\n  Resolution: 'resolution',\n  Equal: '==',\n  NotEqual: '!=',\n  GreaterThan: '>',\n  GreaterThanOrEqualTo: '>=',\n  LessThan: '<',\n  LessThanOrEqualTo: '<=',\n  Multiply: '*',\n  Divide: '/',\n  Add: '+',\n  Subtract: '-',\n  Clamp: 'clamp',\n  Mod: '%',\n  Pow: '^',\n  Abs: 'abs',\n  Floor: 'floor',\n  Ceil: 'ceil',\n  Round: 'round',\n  Sin: 'sin',\n  Cos: 'cos',\n  Atan: 'atan',\n  Sqrt: 'sqrt',\n  Match: 'match',\n};\n\n/**\n * @typedef {function(Array, ParsingContext):Expression} Parser\n */\n\n/**\n * @type {Object<string, Parser>}\n */\nconst parsers = {\n  [Ops.Number]: createParser(withArgs(1, Infinity, AnyType), NumberType),\n  [Ops.String]: createParser(withArgs(1, Infinity, AnyType), StringType),\n  [Ops.Get]: createParser(withGetArgs, AnyType),\n  [Ops.Var]: createParser(withVarArgs, AnyType),\n  [Ops.Resolution]: createParser(withNoArgs, NumberType),\n  [Ops.Any]: createParser(withArgs(2, Infinity, BooleanType), BooleanType),\n  [Ops.All]: createParser(withArgs(2, Infinity, BooleanType), BooleanType),\n  [Ops.Not]: createParser(withArgs(1, 1, BooleanType), BooleanType),\n  [Ops.Equal]: createParser(withArgs(2, 2, AnyType), BooleanType),\n  [Ops.NotEqual]: createParser(withArgs(2, 2, AnyType), BooleanType),\n  [Ops.GreaterThan]: createParser(withArgs(2, 2, AnyType), BooleanType),\n  [Ops.GreaterThanOrEqualTo]: createParser(\n    withArgs(2, 2, AnyType),\n    BooleanType\n  ),\n  [Ops.LessThan]: createParser(withArgs(2, 2, AnyType), BooleanType),\n  [Ops.LessThanOrEqualTo]: createParser(withArgs(2, 2, AnyType), BooleanType),\n  [Ops.Multiply]: createParser(withArgs(2, Infinity, NumberType), NumberType),\n  [Ops.Divide]: createParser(withArgs(2, 2, NumberType), NumberType),\n  [Ops.Add]: createParser(withArgs(2, Infinity, NumberType), NumberType),\n  [Ops.Subtract]: createParser(withArgs(2, 2, NumberType), NumberType),\n  [Ops.Clamp]: createParser(withArgs(3, 3, NumberType), NumberType),\n  [Ops.Mod]: createParser(withArgs(2, 2, NumberType), NumberType),\n  [Ops.Pow]: createParser(withArgs(2, 2, NumberType), NumberType),\n  [Ops.Abs]: createParser(withArgs(1, 1, NumberType), NumberType),\n  [Ops.Floor]: createParser(withArgs(1, 1, NumberType), NumberType),\n  [Ops.Ceil]: createParser(withArgs(1, 1, NumberType), NumberType),\n  [Ops.Round]: createParser(withArgs(1, 1, NumberType), NumberType),\n  [Ops.Sin]: createParser(withArgs(1, 1, NumberType), NumberType),\n  [Ops.Cos]: createParser(withArgs(1, 1, NumberType), NumberType),\n  [Ops.Atan]: createParser(withArgs(1, 2, NumberType), NumberType),\n  [Ops.Sqrt]: createParser(withArgs(1, 1, NumberType), NumberType),\n  [Ops.Match]: createParser(\n    withArgs(4, Infinity, StringType | NumberType),\n    AnyType\n  ),\n};\n\n/**\n * @typedef {function(Array, ParsingContext):Array<Expression>} ArgValidator\n */\n\n/**\n * @type ArgValidator\n */\nfunction withGetArgs(encoded, context) {\n  if (encoded.length !== 2) {\n    throw new Error('Expected 1 argument for get operation');\n  }\n  const arg = parse(encoded[1], context);\n  if (!(arg instanceof LiteralExpression)) {\n    throw new Error('Expected a literal argument for get operation');\n  }\n  if (typeof arg.value !== 'string') {\n    throw new Error('Expected a string argument for get operation');\n  }\n  context.properties.add(arg.value);\n  return [arg];\n}\n\n/**\n * @type ArgValidator\n */\nfunction withVarArgs(encoded, context) {\n  if (encoded.length !== 2) {\n    throw new Error('Expected 1 argument for var operation');\n  }\n  const arg = parse(encoded[1], context);\n  if (!(arg instanceof LiteralExpression)) {\n    throw new Error('Expected a literal argument for var operation');\n  }\n  if (typeof arg.value !== 'string') {\n    throw new Error('Expected a string argument for get operation');\n  }\n  context.variables.add(arg.value);\n  return [arg];\n}\n\n/**\n * @type ArgValidator\n */\nfunction withNoArgs(encoded, context) {\n  const operation = encoded[0];\n  if (encoded.length !== 1) {\n    throw new Error(`Expected no arguments for ${operation} operation`);\n  }\n  return [];\n}\n\n/**\n * @param {number} minArgs The minimum number of arguments.\n * @param {number} maxArgs The maximum number of arguments.\n * @param {number} argType The argument type.\n * @return {ArgValidator} The argument validator\n */\nfunction withArgs(minArgs, maxArgs, argType) {\n  return function (encoded, context) {\n    const operation = encoded[0];\n    const argCount = encoded.length - 1;\n    if (minArgs === maxArgs) {\n      if (argCount !== minArgs) {\n        const plural = minArgs === 1 ? '' : 's';\n        throw new Error(\n          `Expected ${minArgs} argument${plural} for operation ${operation}, got ${argCount}`\n        );\n      }\n    } else if (argCount < minArgs || argCount > maxArgs) {\n      throw new Error(\n        `Expected ${minArgs} to ${maxArgs} arguments for operation ${operation}, got ${argCount}`\n      );\n    }\n\n    /**\n     * @type {Array<Expression>}\n     */\n    const args = new Array(argCount);\n    for (let i = 0; i < argCount; ++i) {\n      const expression = parse(encoded[i + 1], context);\n      if (!overlapsType(argType, expression.type)) {\n        const gotType = typeName(argType);\n        const expectedType = typeName(expression.type);\n        throw new Error(\n          `Unexpected type for argument ${i} of ${operation} operation` +\n            ` : got ${gotType} but expected ${expectedType}`\n        );\n      }\n      args[i] = expression;\n    }\n\n    return args;\n  };\n}\n\n/**\n * @param {ArgValidator} argValidator The argument validator.\n * @param {number} returnType The return type.\n * @return {Parser} The parser.\n */\nfunction createParser(argValidator, returnType) {\n  return function (encoded, context) {\n    const operator = encoded[0];\n    const args = argValidator(encoded, context);\n    return new CallExpression(returnType, operator, ...args);\n  };\n}\n\n/**\n * @param {Array} encoded The encoded expression.\n * @param {ParsingContext} context The parsing context.\n * @return {Expression} The parsed expression.\n */\nfunction parseCallExpression(encoded, context) {\n  const operator = encoded[0];\n\n  const parser = parsers[operator];\n  if (!parser) {\n    throw new Error(`Unknown operator: ${operator}`);\n  }\n  return parser(encoded, context);\n}\n"],"mappings":";AAAA;AACA;AACA;;AAEA,SAAQA,SAAS,QAAO,aAAa;;AAErC;AACA;AACA;AACA;AACA;AACA;;AAEA,IAAIC,QAAQ,GAAG,CAAC;AAChB,OAAO,MAAMC,QAAQ,GAAG,CAAC;AACzB,OAAO,MAAMC,WAAW,GAAG,CAAC,IAAIF,QAAQ,EAAE;AAC1C,OAAO,MAAMG,UAAU,GAAG,CAAC,IAAIH,QAAQ,EAAE;AACzC,OAAO,MAAMI,UAAU,GAAG,CAAC,IAAIJ,QAAQ,EAAE;AACzC,OAAO,MAAMK,SAAS,GAAG,CAAC,IAAIL,QAAQ,EAAE;AACxC,OAAO,MAAMM,eAAe,GAAG,CAAC,IAAIN,QAAQ,EAAE;AAC9C,OAAO,MAAMO,OAAO,GAAGC,IAAI,CAACC,GAAG,CAAC,CAAC,EAAET,QAAQ,CAAC,GAAG,CAAC;AAEhD,MAAMU,SAAS,GAAG;EAChB,CAACR,WAAW,GAAG,SAAS;EACxB,CAACC,UAAU,GAAG,QAAQ;EACtB,CAACC,UAAU,GAAG,QAAQ;EACtB,CAACC,SAAS,GAAG,OAAO;EACpB,CAACC,eAAe,GAAG;AACrB,CAAC;AAED,MAAMK,UAAU,GAAGC,MAAM,CAACC,IAAI,CAACH,SAAS,CAAC,CAACI,GAAG,CAACC,MAAM,CAAC,CAACC,IAAI,CAACjB,SAAS,CAAC;;AAErE;AACA;AACA;AACA;AACA;AACA,OAAO,SAASkB,QAAQA,CAACC,IAAI,EAAE;EAC7B,MAAMC,KAAK,GAAG,EAAE;EAChB,KAAK,MAAMC,SAAS,IAAIT,UAAU,EAAE;IAClC,IAAIU,YAAY,CAACH,IAAI,EAAEE,SAAS,CAAC,EAAE;MACjCD,KAAK,CAACG,IAAI,CAACZ,SAAS,CAACU,SAAS,CAAC,CAAC;IAClC;EACF;EACA,IAAID,KAAK,CAACI,MAAM,KAAK,CAAC,EAAE;IACtB,OAAO,SAAS;EAClB;EACA,IAAIJ,KAAK,CAACI,MAAM,GAAG,CAAC,EAAE;IACpB,OAAOJ,KAAK,CAACK,IAAI,CAAC,MAAM,CAAC;EAC3B;EACA,OAAOL,KAAK,CAACM,KAAK,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,CAACD,IAAI,CAAC,IAAI,CAAC,GAAG,OAAO,GAAGL,KAAK,CAACA,KAAK,CAACI,MAAM,GAAG,CAAC,CAAC;AAC1E;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASF,YAAYA,CAACK,KAAK,EAAEC,QAAQ,EAAE;EAC5C,OAAO,CAACD,KAAK,GAAGC,QAAQ,MAAMA,QAAQ;AACxC;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASC,YAAYA,CAACC,OAAO,EAAEC,SAAS,EAAE;EAC/C,OAAO,CAAC,EAAED,OAAO,GAAGC,SAAS,CAAC;AAChC;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASC,MAAMA,CAACb,IAAI,EAAEc,QAAQ,EAAE;EACrC,OAAOd,IAAI,KAAKc,QAAQ;AAC1B;;AAEA;AACA;AACA;;AAEA,OAAO,MAAMC,iBAAiB,CAAC;EAC7B;AACF;AACA;AACA;EACEC,WAAWA,CAAChB,IAAI,EAAEiB,KAAK,EAAE;IACvB,IAAI,CAACjB,IAAI,GAAGA,IAAI;IAChB,IAAI,CAACiB,KAAK,GAAGA,KAAK;EACpB;AACF;AAEA,OAAO,MAAMC,cAAc,CAAC;EAC1B;AACF;AACA;AACA;AACA;EACEF,WAAWA,CAAChB,IAAI,EAAEmB,QAAQ,EAAE,GAAGC,IAAI,EAAE;IACnC,IAAI,CAACpB,IAAI,GAAGA,IAAI;IAChB,IAAI,CAACmB,QAAQ,GAAGA,QAAQ;IACxB,IAAI,CAACC,IAAI,GAAGA,IAAI;EAClB;AACF;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO,SAASC,iBAAiBA,CAAA,EAAG;EAClC,OAAO;IACLC,SAAS,EAAE,IAAIC,GAAG,CAAC,CAAC;IACpBC,UAAU,EAAE,IAAID,GAAG,CAAC;EACtB,CAAC;AACH;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASE,KAAKA,CAACC,OAAO,EAAEC,OAAO,EAAE;EACtC,QAAQ,OAAOD,OAAO;IACpB,KAAK,SAAS;MAAE;QACd,OAAO,IAAIX,iBAAiB,CAAC/B,WAAW,EAAE0C,OAAO,CAAC;MACpD;IACA,KAAK,QAAQ;MAAE;QACb,OAAO,IAAIX,iBAAiB,CAAC9B,UAAU,EAAEyC,OAAO,CAAC;MACnD;IACA,KAAK,QAAQ;MAAE;QACb,OAAO,IAAIX,iBAAiB,CAAC7B,UAAU,EAAEwC,OAAO,CAAC;MACnD;IACA;MAAS;QACP;MAAA;EAEJ;EAEA,IAAI,CAACE,KAAK,CAACC,OAAO,CAACH,OAAO,CAAC,EAAE;IAC3B,MAAM,IAAII,KAAK,CAAC,kDAAkD,CAAC;EACrE;EAEA,IAAIJ,OAAO,CAACrB,MAAM,KAAK,CAAC,EAAE;IACxB,MAAM,IAAIyB,KAAK,CAAC,kBAAkB,CAAC;EACrC;EAEA,IAAI,OAAOJ,OAAO,CAAC,CAAC,CAAC,KAAK,QAAQ,EAAE;IAClC,OAAOK,mBAAmB,CAACL,OAAO,EAAEC,OAAO,CAAC;EAC9C;EAEA,KAAK,MAAMK,IAAI,IAAIN,OAAO,EAAE;IAC1B,IAAI,OAAOM,IAAI,KAAK,QAAQ,EAAE;MAC5B,MAAM,IAAIF,KAAK,CAAC,8BAA8B,CAAC;IACjD;EACF;EAEA,IAAI9B,IAAI,GAAGZ,eAAe;EAC1B,IAAIsC,OAAO,CAACrB,MAAM,KAAK,CAAC,IAAIqB,OAAO,CAACrB,MAAM,KAAK,CAAC,EAAE;IAChDL,IAAI,IAAIb,SAAS;EACnB;EAEA,OAAO,IAAI4B,iBAAiB,CAACf,IAAI,EAAE0B,OAAO,CAAC;AAC7C;;AAEA;AACA;AACA;AACA,OAAO,MAAMO,GAAG,GAAG;EACjBpC,MAAM,EAAE,QAAQ;EAChBqC,MAAM,EAAE,QAAQ;EAChBC,GAAG,EAAE,KAAK;EACVC,GAAG,EAAE,KAAK;EACVC,GAAG,EAAE,KAAK;EACVC,GAAG,EAAE,KAAK;EACVC,GAAG,EAAE,GAAG;EACRC,UAAU,EAAE,YAAY;EACxBC,KAAK,EAAE,IAAI;EACXC,QAAQ,EAAE,IAAI;EACdC,WAAW,EAAE,GAAG;EAChBC,oBAAoB,EAAE,IAAI;EAC1BC,QAAQ,EAAE,GAAG;EACbC,iBAAiB,EAAE,IAAI;EACvBC,QAAQ,EAAE,GAAG;EACbC,MAAM,EAAE,GAAG;EACXC,GAAG,EAAE,GAAG;EACRC,QAAQ,EAAE,GAAG;EACbC,KAAK,EAAE,OAAO;EACdC,GAAG,EAAE,GAAG;EACRC,GAAG,EAAE,GAAG;EACRC,GAAG,EAAE,KAAK;EACVC,KAAK,EAAE,OAAO;EACdC,IAAI,EAAE,MAAM;EACZC,KAAK,EAAE,OAAO;EACdC,GAAG,EAAE,KAAK;EACVC,GAAG,EAAE,KAAK;EACVC,IAAI,EAAE,MAAM;EACZC,IAAI,EAAE,MAAM;EACZC,KAAK,EAAE;AACT,CAAC;;AAED;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAMC,OAAO,GAAG;EACd,CAAC9B,GAAG,CAACpC,MAAM,GAAGmE,YAAY,CAACC,QAAQ,CAAC,CAAC,EAAEC,QAAQ,EAAE7E,OAAO,CAAC,EAAEJ,UAAU,CAAC;EACtE,CAACgD,GAAG,CAACC,MAAM,GAAG8B,YAAY,CAACC,QAAQ,CAAC,CAAC,EAAEC,QAAQ,EAAE7E,OAAO,CAAC,EAAEH,UAAU,CAAC;EACtE,CAAC+C,GAAG,CAACE,GAAG,GAAG6B,YAAY,CAACG,WAAW,EAAE9E,OAAO,CAAC;EAC7C,CAAC4C,GAAG,CAACG,GAAG,GAAG4B,YAAY,CAACI,WAAW,EAAE/E,OAAO,CAAC;EAC7C,CAAC4C,GAAG,CAACO,UAAU,GAAGwB,YAAY,CAACK,UAAU,EAAEpF,UAAU,CAAC;EACtD,CAACgD,GAAG,CAACI,GAAG,GAAG2B,YAAY,CAACC,QAAQ,CAAC,CAAC,EAAEC,QAAQ,EAAElF,WAAW,CAAC,EAAEA,WAAW,CAAC;EACxE,CAACiD,GAAG,CAACK,GAAG,GAAG0B,YAAY,CAACC,QAAQ,CAAC,CAAC,EAAEC,QAAQ,EAAElF,WAAW,CAAC,EAAEA,WAAW,CAAC;EACxE,CAACiD,GAAG,CAACM,GAAG,GAAGyB,YAAY,CAACC,QAAQ,CAAC,CAAC,EAAE,CAAC,EAAEjF,WAAW,CAAC,EAAEA,WAAW,CAAC;EACjE,CAACiD,GAAG,CAACQ,KAAK,GAAGuB,YAAY,CAACC,QAAQ,CAAC,CAAC,EAAE,CAAC,EAAE5E,OAAO,CAAC,EAAEL,WAAW,CAAC;EAC/D,CAACiD,GAAG,CAACS,QAAQ,GAAGsB,YAAY,CAACC,QAAQ,CAAC,CAAC,EAAE,CAAC,EAAE5E,OAAO,CAAC,EAAEL,WAAW,CAAC;EAClE,CAACiD,GAAG,CAACU,WAAW,GAAGqB,YAAY,CAACC,QAAQ,CAAC,CAAC,EAAE,CAAC,EAAE5E,OAAO,CAAC,EAAEL,WAAW,CAAC;EACrE,CAACiD,GAAG,CAACW,oBAAoB,GAAGoB,YAAY,CACtCC,QAAQ,CAAC,CAAC,EAAE,CAAC,EAAE5E,OAAO,CAAC,EACvBL,WACF,CAAC;EACD,CAACiD,GAAG,CAACY,QAAQ,GAAGmB,YAAY,CAACC,QAAQ,CAAC,CAAC,EAAE,CAAC,EAAE5E,OAAO,CAAC,EAAEL,WAAW,CAAC;EAClE,CAACiD,GAAG,CAACa,iBAAiB,GAAGkB,YAAY,CAACC,QAAQ,CAAC,CAAC,EAAE,CAAC,EAAE5E,OAAO,CAAC,EAAEL,WAAW,CAAC;EAC3E,CAACiD,GAAG,CAACc,QAAQ,GAAGiB,YAAY,CAACC,QAAQ,CAAC,CAAC,EAAEC,QAAQ,EAAEjF,UAAU,CAAC,EAAEA,UAAU,CAAC;EAC3E,CAACgD,GAAG,CAACe,MAAM,GAAGgB,YAAY,CAACC,QAAQ,CAAC,CAAC,EAAE,CAAC,EAAEhF,UAAU,CAAC,EAAEA,UAAU,CAAC;EAClE,CAACgD,GAAG,CAACgB,GAAG,GAAGe,YAAY,CAACC,QAAQ,CAAC,CAAC,EAAEC,QAAQ,EAAEjF,UAAU,CAAC,EAAEA,UAAU,CAAC;EACtE,CAACgD,GAAG,CAACiB,QAAQ,GAAGc,YAAY,CAACC,QAAQ,CAAC,CAAC,EAAE,CAAC,EAAEhF,UAAU,CAAC,EAAEA,UAAU,CAAC;EACpE,CAACgD,GAAG,CAACkB,KAAK,GAAGa,YAAY,CAACC,QAAQ,CAAC,CAAC,EAAE,CAAC,EAAEhF,UAAU,CAAC,EAAEA,UAAU,CAAC;EACjE,CAACgD,GAAG,CAACmB,GAAG,GAAGY,YAAY,CAACC,QAAQ,CAAC,CAAC,EAAE,CAAC,EAAEhF,UAAU,CAAC,EAAEA,UAAU,CAAC;EAC/D,CAACgD,GAAG,CAACoB,GAAG,GAAGW,YAAY,CAACC,QAAQ,CAAC,CAAC,EAAE,CAAC,EAAEhF,UAAU,CAAC,EAAEA,UAAU,CAAC;EAC/D,CAACgD,GAAG,CAACqB,GAAG,GAAGU,YAAY,CAACC,QAAQ,CAAC,CAAC,EAAE,CAAC,EAAEhF,UAAU,CAAC,EAAEA,UAAU,CAAC;EAC/D,CAACgD,GAAG,CAACsB,KAAK,GAAGS,YAAY,CAACC,QAAQ,CAAC,CAAC,EAAE,CAAC,EAAEhF,UAAU,CAAC,EAAEA,UAAU,CAAC;EACjE,CAACgD,GAAG,CAACuB,IAAI,GAAGQ,YAAY,CAACC,QAAQ,CAAC,CAAC,EAAE,CAAC,EAAEhF,UAAU,CAAC,EAAEA,UAAU,CAAC;EAChE,CAACgD,GAAG,CAACwB,KAAK,GAAGO,YAAY,CAACC,QAAQ,CAAC,CAAC,EAAE,CAAC,EAAEhF,UAAU,CAAC,EAAEA,UAAU,CAAC;EACjE,CAACgD,GAAG,CAACyB,GAAG,GAAGM,YAAY,CAACC,QAAQ,CAAC,CAAC,EAAE,CAAC,EAAEhF,UAAU,CAAC,EAAEA,UAAU,CAAC;EAC/D,CAACgD,GAAG,CAAC0B,GAAG,GAAGK,YAAY,CAACC,QAAQ,CAAC,CAAC,EAAE,CAAC,EAAEhF,UAAU,CAAC,EAAEA,UAAU,CAAC;EAC/D,CAACgD,GAAG,CAAC2B,IAAI,GAAGI,YAAY,CAACC,QAAQ,CAAC,CAAC,EAAE,CAAC,EAAEhF,UAAU,CAAC,EAAEA,UAAU,CAAC;EAChE,CAACgD,GAAG,CAAC4B,IAAI,GAAGG,YAAY,CAACC,QAAQ,CAAC,CAAC,EAAE,CAAC,EAAEhF,UAAU,CAAC,EAAEA,UAAU,CAAC;EAChE,CAACgD,GAAG,CAAC6B,KAAK,GAAGE,YAAY,CACvBC,QAAQ,CAAC,CAAC,EAAEC,QAAQ,EAAEhF,UAAU,GAAGD,UAAU,CAAC,EAC9CI,OACF;AACF,CAAC;;AAED;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS8E,WAAWA,CAACzC,OAAO,EAAEC,OAAO,EAAE;EACrC,IAAID,OAAO,CAACrB,MAAM,KAAK,CAAC,EAAE;IACxB,MAAM,IAAIyB,KAAK,CAAC,uCAAuC,CAAC;EAC1D;EACA,MAAMwC,GAAG,GAAG7C,KAAK,CAACC,OAAO,CAAC,CAAC,CAAC,EAAEC,OAAO,CAAC;EACtC,IAAI,EAAE2C,GAAG,YAAYvD,iBAAiB,CAAC,EAAE;IACvC,MAAM,IAAIe,KAAK,CAAC,+CAA+C,CAAC;EAClE;EACA,IAAI,OAAOwC,GAAG,CAACrD,KAAK,KAAK,QAAQ,EAAE;IACjC,MAAM,IAAIa,KAAK,CAAC,8CAA8C,CAAC;EACjE;EACAH,OAAO,CAACH,UAAU,CAAC+C,GAAG,CAACD,GAAG,CAACrD,KAAK,CAAC;EACjC,OAAO,CAACqD,GAAG,CAAC;AACd;;AAEA;AACA;AACA;AACA,SAASF,WAAWA,CAAC1C,OAAO,EAAEC,OAAO,EAAE;EACrC,IAAID,OAAO,CAACrB,MAAM,KAAK,CAAC,EAAE;IACxB,MAAM,IAAIyB,KAAK,CAAC,uCAAuC,CAAC;EAC1D;EACA,MAAMwC,GAAG,GAAG7C,KAAK,CAACC,OAAO,CAAC,CAAC,CAAC,EAAEC,OAAO,CAAC;EACtC,IAAI,EAAE2C,GAAG,YAAYvD,iBAAiB,CAAC,EAAE;IACvC,MAAM,IAAIe,KAAK,CAAC,+CAA+C,CAAC;EAClE;EACA,IAAI,OAAOwC,GAAG,CAACrD,KAAK,KAAK,QAAQ,EAAE;IACjC,MAAM,IAAIa,KAAK,CAAC,8CAA8C,CAAC;EACjE;EACAH,OAAO,CAACL,SAAS,CAACiD,GAAG,CAACD,GAAG,CAACrD,KAAK,CAAC;EAChC,OAAO,CAACqD,GAAG,CAAC;AACd;;AAEA;AACA;AACA;AACA,SAASD,UAAUA,CAAC3C,OAAO,EAAEC,OAAO,EAAE;EACpC,MAAM6C,SAAS,GAAG9C,OAAO,CAAC,CAAC,CAAC;EAC5B,IAAIA,OAAO,CAACrB,MAAM,KAAK,CAAC,EAAE;IACxB,MAAM,IAAIyB,KAAK,CAAE,6BAA4B0C,SAAU,YAAW,CAAC;EACrE;EACA,OAAO,EAAE;AACX;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,SAASP,QAAQA,CAACQ,OAAO,EAAEC,OAAO,EAAEC,OAAO,EAAE;EAC3C,OAAO,UAAUjD,OAAO,EAAEC,OAAO,EAAE;IACjC,MAAM6C,SAAS,GAAG9C,OAAO,CAAC,CAAC,CAAC;IAC5B,MAAMkD,QAAQ,GAAGlD,OAAO,CAACrB,MAAM,GAAG,CAAC;IACnC,IAAIoE,OAAO,KAAKC,OAAO,EAAE;MACvB,IAAIE,QAAQ,KAAKH,OAAO,EAAE;QACxB,MAAMI,MAAM,GAAGJ,OAAO,KAAK,CAAC,GAAG,EAAE,GAAG,GAAG;QACvC,MAAM,IAAI3C,KAAK,CACZ,YAAW2C,OAAQ,YAAWI,MAAO,kBAAiBL,SAAU,SAAQI,QAAS,EACpF,CAAC;MACH;IACF,CAAC,MAAM,IAAIA,QAAQ,GAAGH,OAAO,IAAIG,QAAQ,GAAGF,OAAO,EAAE;MACnD,MAAM,IAAI5C,KAAK,CACZ,YAAW2C,OAAQ,OAAMC,OAAQ,4BAA2BF,SAAU,SAAQI,QAAS,EAC1F,CAAC;IACH;;IAEA;AACJ;AACA;IACI,MAAMxD,IAAI,GAAG,IAAIQ,KAAK,CAACgD,QAAQ,CAAC;IAChC,KAAK,IAAIE,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGF,QAAQ,EAAE,EAAEE,CAAC,EAAE;MACjC,MAAMC,UAAU,GAAGtD,KAAK,CAACC,OAAO,CAACoD,CAAC,GAAG,CAAC,CAAC,EAAEnD,OAAO,CAAC;MACjD,IAAI,CAACjB,YAAY,CAACiE,OAAO,EAAEI,UAAU,CAAC/E,IAAI,CAAC,EAAE;QAC3C,MAAMgF,OAAO,GAAGjF,QAAQ,CAAC4E,OAAO,CAAC;QACjC,MAAMM,YAAY,GAAGlF,QAAQ,CAACgF,UAAU,CAAC/E,IAAI,CAAC;QAC9C,MAAM,IAAI8B,KAAK,CACZ,gCAA+BgD,CAAE,OAAMN,SAAU,YAAW,GAC1D,UAASQ,OAAQ,iBAAgBC,YAAa,EACnD,CAAC;MACH;MACA7D,IAAI,CAAC0D,CAAC,CAAC,GAAGC,UAAU;IACtB;IAEA,OAAO3D,IAAI;EACb,CAAC;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA,SAAS4C,YAAYA,CAACkB,YAAY,EAAEC,UAAU,EAAE;EAC9C,OAAO,UAAUzD,OAAO,EAAEC,OAAO,EAAE;IACjC,MAAMR,QAAQ,GAAGO,OAAO,CAAC,CAAC,CAAC;IAC3B,MAAMN,IAAI,GAAG8D,YAAY,CAACxD,OAAO,EAAEC,OAAO,CAAC;IAC3C,OAAO,IAAIT,cAAc,CAACiE,UAAU,EAAEhE,QAAQ,EAAE,GAAGC,IAAI,CAAC;EAC1D,CAAC;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA,SAASW,mBAAmBA,CAACL,OAAO,EAAEC,OAAO,EAAE;EAC7C,MAAMR,QAAQ,GAAGO,OAAO,CAAC,CAAC,CAAC;EAE3B,MAAM0D,MAAM,GAAGrB,OAAO,CAAC5C,QAAQ,CAAC;EAChC,IAAI,CAACiE,MAAM,EAAE;IACX,MAAM,IAAItD,KAAK,CAAE,qBAAoBX,QAAS,EAAC,CAAC;EAClD;EACA,OAAOiE,MAAM,CAAC1D,OAAO,EAAEC,OAAO,CAAC;AACjC"},"metadata":{},"sourceType":"module","externalDependencies":[]}