{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\n/**\n * @module ol/MapBrowserEventHandler\n */\n\nimport EventType from './events/EventType.js';\nimport MapBrowserEvent from './MapBrowserEvent.js';\nimport MapBrowserEventType from './MapBrowserEventType.js';\nimport PointerEventType from './pointer/EventType.js';\nimport Target from './events/Target.js';\nimport { PASSIVE_EVENT_LISTENERS } from './has.js';\nimport { listen, unlistenByKey } from './events.js';\nclass MapBrowserEventHandler extends Target {\n  /**\n   * @param {import(\"./Map.js\").default} map The map with the viewport to listen to events on.\n   * @param {number} [moveTolerance] The minimal distance the pointer must travel to trigger a move.\n   */\n  constructor(map, moveTolerance) {\n    super(map);\n\n    /**\n     * This is the element that we will listen to the real events on.\n     * @type {import(\"./Map.js\").default}\n     * @private\n     */\n    this.map_ = map;\n\n    /**\n     * @type {ReturnType<typeof setTimeout>}\n     * @private\n     */\n    this.clickTimeoutId_;\n\n    /**\n     * Emulate dblclick and singleclick. Will be true when only one pointer is active.\n     * @type {boolean}\n     */\n    this.emulateClicks_ = false;\n\n    /**\n     * @type {boolean}\n     * @private\n     */\n    this.dragging_ = false;\n\n    /**\n     * @type {!Array<import(\"./events.js\").EventsKey>}\n     * @private\n     */\n    this.dragListenerKeys_ = [];\n\n    /**\n     * @type {number}\n     * @private\n     */\n    this.moveTolerance_ = moveTolerance === undefined ? 1 : moveTolerance;\n\n    /**\n     * The most recent \"down\" type event (or null if none have occurred).\n     * Set on pointerdown.\n     * @type {PointerEvent|null}\n     * @private\n     */\n    this.down_ = null;\n    const element = this.map_.getViewport();\n\n    /**\n     * @type {Array<PointerEvent>}\n     * @private\n     */\n    this.activePointers_ = [];\n\n    /**\n     * @type {!Object<number, Event>}\n     * @private\n     */\n    this.trackedTouches_ = {};\n    this.element_ = element;\n\n    /**\n     * @type {?import(\"./events.js\").EventsKey}\n     * @private\n     */\n    this.pointerdownListenerKey_ = listen(element, PointerEventType.POINTERDOWN, this.handlePointerDown_, this);\n\n    /**\n     * @type {PointerEvent}\n     * @private\n     */\n    this.originalPointerMoveEvent_;\n\n    /**\n     * @type {?import(\"./events.js\").EventsKey}\n     * @private\n     */\n    this.relayedListenerKey_ = listen(element, PointerEventType.POINTERMOVE, this.relayMoveEvent_, this);\n\n    /**\n     * @private\n     */\n    this.boundHandleTouchMove_ = this.handleTouchMove_.bind(this);\n    this.element_.addEventListener(EventType.TOUCHMOVE, this.boundHandleTouchMove_, PASSIVE_EVENT_LISTENERS ? {\n      passive: false\n    } : false);\n  }\n\n  /**\n   * @param {PointerEvent} pointerEvent Pointer\n   * event.\n   * @private\n   */\n  emulateClick_(pointerEvent) {\n    let newEvent = new MapBrowserEvent(MapBrowserEventType.CLICK, this.map_, pointerEvent);\n    this.dispatchEvent(newEvent);\n    if (this.clickTimeoutId_ !== undefined) {\n      // double-click\n      clearTimeout(this.clickTimeoutId_);\n      this.clickTimeoutId_ = undefined;\n      newEvent = new MapBrowserEvent(MapBrowserEventType.DBLCLICK, this.map_, pointerEvent);\n      this.dispatchEvent(newEvent);\n    } else {\n      // click\n      this.clickTimeoutId_ = setTimeout(() => {\n        this.clickTimeoutId_ = undefined;\n        const newEvent = new MapBrowserEvent(MapBrowserEventType.SINGLECLICK, this.map_, pointerEvent);\n        this.dispatchEvent(newEvent);\n      }, 250);\n    }\n  }\n\n  /**\n   * Keeps track on how many pointers are currently active.\n   *\n   * @param {PointerEvent} pointerEvent Pointer\n   * event.\n   * @private\n   */\n  updateActivePointers_(pointerEvent) {\n    const event = pointerEvent;\n    const id = event.pointerId;\n    if (event.type == MapBrowserEventType.POINTERUP || event.type == MapBrowserEventType.POINTERCANCEL) {\n      delete this.trackedTouches_[id];\n      for (const pointerId in this.trackedTouches_) {\n        if (this.trackedTouches_[pointerId].target !== event.target) {\n          // Some platforms assign a new pointerId when the target changes.\n          // If this happens, delete one tracked pointer. If there is more\n          // than one tracked pointer for the old target, it will be cleared\n          // by subsequent POINTERUP events from other pointers.\n          delete this.trackedTouches_[pointerId];\n          break;\n        }\n      }\n    } else if (event.type == MapBrowserEventType.POINTERDOWN || event.type == MapBrowserEventType.POINTERMOVE) {\n      this.trackedTouches_[id] = event;\n    }\n    this.activePointers_ = Object.values(this.trackedTouches_);\n  }\n\n  /**\n   * @param {PointerEvent} pointerEvent Pointer\n   * event.\n   * @private\n   */\n  handlePointerUp_(pointerEvent) {\n    this.updateActivePointers_(pointerEvent);\n    const newEvent = new MapBrowserEvent(MapBrowserEventType.POINTERUP, this.map_, pointerEvent, undefined, undefined, this.activePointers_);\n    this.dispatchEvent(newEvent);\n\n    // We emulate click events on left mouse button click, touch contact, and pen\n    // contact. isMouseActionButton returns true in these cases (evt.button is set\n    // to 0).\n    // See http://www.w3.org/TR/pointerevents/#button-states\n    // We only fire click, singleclick, and doubleclick if nobody has called\n    // event.preventDefault().\n    if (this.emulateClicks_ && !newEvent.defaultPrevented && !this.dragging_ && this.isMouseActionButton_(pointerEvent)) {\n      this.emulateClick_(this.down_);\n    }\n    if (this.activePointers_.length === 0) {\n      this.dragListenerKeys_.forEach(unlistenByKey);\n      this.dragListenerKeys_.length = 0;\n      this.dragging_ = false;\n      this.down_ = null;\n    }\n  }\n\n  /**\n   * @param {PointerEvent} pointerEvent Pointer\n   * event.\n   * @return {boolean} If the left mouse button was pressed.\n   * @private\n   */\n  isMouseActionButton_(pointerEvent) {\n    return pointerEvent.button === 0;\n  }\n\n  /**\n   * @param {PointerEvent} pointerEvent Pointer\n   * event.\n   * @private\n   */\n  handlePointerDown_(pointerEvent) {\n    this.emulateClicks_ = this.activePointers_.length === 0;\n    this.updateActivePointers_(pointerEvent);\n    const newEvent = new MapBrowserEvent(MapBrowserEventType.POINTERDOWN, this.map_, pointerEvent, undefined, undefined, this.activePointers_);\n    this.dispatchEvent(newEvent);\n    this.down_ = new PointerEvent(pointerEvent.type, pointerEvent);\n    Object.defineProperty(this.down_, 'target', {\n      writable: false,\n      value: pointerEvent.target\n    });\n    if (this.dragListenerKeys_.length === 0) {\n      const doc = this.map_.getOwnerDocument();\n      this.dragListenerKeys_.push(listen(doc, MapBrowserEventType.POINTERMOVE, this.handlePointerMove_, this), listen(doc, MapBrowserEventType.POINTERUP, this.handlePointerUp_, this),\n      /* Note that the listener for `pointercancel is set up on\n       * `pointerEventHandler_` and not `documentPointerEventHandler_` like\n       * the `pointerup` and `pointermove` listeners.\n       *\n       * The reason for this is the following: `TouchSource.vacuumTouches_()`\n       * issues `pointercancel` events, when there was no `touchend` for a\n       * `touchstart`. Now, let's say a first `touchstart` is registered on\n       * `pointerEventHandler_`. The `documentPointerEventHandler_` is set up.\n       * But `documentPointerEventHandler_` doesn't know about the first\n       * `touchstart`. If there is no `touchend` for the `touchstart`, we can\n       * only receive a `touchcancel` from `pointerEventHandler_`, because it is\n       * only registered there.\n       */\n      listen(this.element_, MapBrowserEventType.POINTERCANCEL, this.handlePointerUp_, this));\n      if (this.element_.getRootNode && this.element_.getRootNode() !== doc) {\n        this.dragListenerKeys_.push(listen(this.element_.getRootNode(), MapBrowserEventType.POINTERUP, this.handlePointerUp_, this));\n      }\n    }\n  }\n\n  /**\n   * @param {PointerEvent} pointerEvent Pointer\n   * event.\n   * @private\n   */\n  handlePointerMove_(pointerEvent) {\n    // Between pointerdown and pointerup, pointermove events are triggered.\n    // To avoid a 'false' touchmove event to be dispatched, we test if the pointer\n    // moved a significant distance.\n    if (this.isMoving_(pointerEvent)) {\n      this.updateActivePointers_(pointerEvent);\n      this.dragging_ = true;\n      const newEvent = new MapBrowserEvent(MapBrowserEventType.POINTERDRAG, this.map_, pointerEvent, this.dragging_, undefined, this.activePointers_);\n      this.dispatchEvent(newEvent);\n    }\n  }\n\n  /**\n   * Wrap and relay a pointermove event.\n   * @param {PointerEvent} pointerEvent Pointer\n   * event.\n   * @private\n   */\n  relayMoveEvent_(pointerEvent) {\n    this.originalPointerMoveEvent_ = pointerEvent;\n    const dragging = !!(this.down_ && this.isMoving_(pointerEvent));\n    this.dispatchEvent(new MapBrowserEvent(MapBrowserEventType.POINTERMOVE, this.map_, pointerEvent, dragging));\n  }\n\n  /**\n   * Flexible handling of a `touch-action: none` css equivalent: because calling\n   * `preventDefault()` on a `pointermove` event does not stop native page scrolling\n   * and zooming, we also listen for `touchmove` and call `preventDefault()` on it\n   * when an interaction (currently `DragPan` handles the event.\n   * @param {TouchEvent} event Event.\n   * @private\n   */\n  handleTouchMove_(event) {\n    // Due to https://github.com/mpizenberg/elm-pep/issues/2, `this.originalPointerMoveEvent_`\n    // may not be initialized yet when we get here on a platform without native pointer events,\n    // when elm-pep is used as pointer events polyfill.\n    const originalEvent = this.originalPointerMoveEvent_;\n    if ((!originalEvent || originalEvent.defaultPrevented) && (typeof event.cancelable !== 'boolean' || event.cancelable === true)) {\n      event.preventDefault();\n    }\n  }\n\n  /**\n   * @param {PointerEvent} pointerEvent Pointer\n   * event.\n   * @return {boolean} Is moving.\n   * @private\n   */\n  isMoving_(pointerEvent) {\n    return this.dragging_ || Math.abs(pointerEvent.clientX - this.down_.clientX) > this.moveTolerance_ || Math.abs(pointerEvent.clientY - this.down_.clientY) > this.moveTolerance_;\n  }\n\n  /**\n   * Clean up.\n   */\n  disposeInternal() {\n    if (this.relayedListenerKey_) {\n      unlistenByKey(this.relayedListenerKey_);\n      this.relayedListenerKey_ = null;\n    }\n    this.element_.removeEventListener(EventType.TOUCHMOVE, this.boundHandleTouchMove_);\n    if (this.pointerdownListenerKey_) {\n      unlistenByKey(this.pointerdownListenerKey_);\n      this.pointerdownListenerKey_ = null;\n    }\n    this.dragListenerKeys_.forEach(unlistenByKey);\n    this.dragListenerKeys_.length = 0;\n    this.element_ = null;\n    super.disposeInternal();\n  }\n}\nexport default MapBrowserEventHandler;","map":{"version":3,"names":["EventType","MapBrowserEvent","MapBrowserEventType","PointerEventType","Target","PASSIVE_EVENT_LISTENERS","listen","unlistenByKey","MapBrowserEventHandler","constructor","map","moveTolerance","map_","clickTimeoutId_","emulateClicks_","dragging_","dragListenerKeys_","moveTolerance_","undefined","down_","element","getViewport","activePointers_","trackedTouches_","element_","pointerdownListenerKey_","POINTERDOWN","handlePointerDown_","originalPointerMoveEvent_","relayedListenerKey_","POINTERMOVE","relayMoveEvent_","boundHandleTouchMove_","handleTouchMove_","bind","addEventListener","TOUCHMOVE","passive","emulateClick_","pointerEvent","newEvent","CLICK","dispatchEvent","clearTimeout","DBLCLICK","setTimeout","SINGLECLICK","updateActivePointers_","event","id","pointerId","type","POINTERUP","POINTERCANCEL","target","Object","values","handlePointerUp_","defaultPrevented","isMouseActionButton_","length","forEach","button","PointerEvent","defineProperty","writable","value","doc","getOwnerDocument","push","handlePointerMove_","getRootNode","isMoving_","POINTERDRAG","dragging","originalEvent","cancelable","preventDefault","Math","abs","clientX","clientY","disposeInternal","removeEventListener"],"sources":["E:/Desktop/scenerymonitor/node_modules/ol/MapBrowserEventHandler.js"],"sourcesContent":["/**\n * @module ol/MapBrowserEventHandler\n */\n\nimport EventType from './events/EventType.js';\nimport MapBrowserEvent from './MapBrowserEvent.js';\nimport MapBrowserEventType from './MapBrowserEventType.js';\nimport PointerEventType from './pointer/EventType.js';\nimport Target from './events/Target.js';\nimport {PASSIVE_EVENT_LISTENERS} from './has.js';\nimport {listen, unlistenByKey} from './events.js';\n\nclass MapBrowserEventHandler extends Target {\n  /**\n   * @param {import(\"./Map.js\").default} map The map with the viewport to listen to events on.\n   * @param {number} [moveTolerance] The minimal distance the pointer must travel to trigger a move.\n   */\n  constructor(map, moveTolerance) {\n    super(map);\n\n    /**\n     * This is the element that we will listen to the real events on.\n     * @type {import(\"./Map.js\").default}\n     * @private\n     */\n    this.map_ = map;\n\n    /**\n     * @type {ReturnType<typeof setTimeout>}\n     * @private\n     */\n    this.clickTimeoutId_;\n\n    /**\n     * Emulate dblclick and singleclick. Will be true when only one pointer is active.\n     * @type {boolean}\n     */\n    this.emulateClicks_ = false;\n\n    /**\n     * @type {boolean}\n     * @private\n     */\n    this.dragging_ = false;\n\n    /**\n     * @type {!Array<import(\"./events.js\").EventsKey>}\n     * @private\n     */\n    this.dragListenerKeys_ = [];\n\n    /**\n     * @type {number}\n     * @private\n     */\n    this.moveTolerance_ = moveTolerance === undefined ? 1 : moveTolerance;\n\n    /**\n     * The most recent \"down\" type event (or null if none have occurred).\n     * Set on pointerdown.\n     * @type {PointerEvent|null}\n     * @private\n     */\n    this.down_ = null;\n\n    const element = this.map_.getViewport();\n\n    /**\n     * @type {Array<PointerEvent>}\n     * @private\n     */\n    this.activePointers_ = [];\n\n    /**\n     * @type {!Object<number, Event>}\n     * @private\n     */\n    this.trackedTouches_ = {};\n\n    this.element_ = element;\n\n    /**\n     * @type {?import(\"./events.js\").EventsKey}\n     * @private\n     */\n    this.pointerdownListenerKey_ = listen(\n      element,\n      PointerEventType.POINTERDOWN,\n      this.handlePointerDown_,\n      this\n    );\n\n    /**\n     * @type {PointerEvent}\n     * @private\n     */\n    this.originalPointerMoveEvent_;\n\n    /**\n     * @type {?import(\"./events.js\").EventsKey}\n     * @private\n     */\n    this.relayedListenerKey_ = listen(\n      element,\n      PointerEventType.POINTERMOVE,\n      this.relayMoveEvent_,\n      this\n    );\n\n    /**\n     * @private\n     */\n    this.boundHandleTouchMove_ = this.handleTouchMove_.bind(this);\n\n    this.element_.addEventListener(\n      EventType.TOUCHMOVE,\n      this.boundHandleTouchMove_,\n      PASSIVE_EVENT_LISTENERS ? {passive: false} : false\n    );\n  }\n\n  /**\n   * @param {PointerEvent} pointerEvent Pointer\n   * event.\n   * @private\n   */\n  emulateClick_(pointerEvent) {\n    let newEvent = new MapBrowserEvent(\n      MapBrowserEventType.CLICK,\n      this.map_,\n      pointerEvent\n    );\n    this.dispatchEvent(newEvent);\n    if (this.clickTimeoutId_ !== undefined) {\n      // double-click\n      clearTimeout(this.clickTimeoutId_);\n      this.clickTimeoutId_ = undefined;\n      newEvent = new MapBrowserEvent(\n        MapBrowserEventType.DBLCLICK,\n        this.map_,\n        pointerEvent\n      );\n      this.dispatchEvent(newEvent);\n    } else {\n      // click\n      this.clickTimeoutId_ = setTimeout(() => {\n        this.clickTimeoutId_ = undefined;\n        const newEvent = new MapBrowserEvent(\n          MapBrowserEventType.SINGLECLICK,\n          this.map_,\n          pointerEvent\n        );\n        this.dispatchEvent(newEvent);\n      }, 250);\n    }\n  }\n\n  /**\n   * Keeps track on how many pointers are currently active.\n   *\n   * @param {PointerEvent} pointerEvent Pointer\n   * event.\n   * @private\n   */\n  updateActivePointers_(pointerEvent) {\n    const event = pointerEvent;\n    const id = event.pointerId;\n\n    if (\n      event.type == MapBrowserEventType.POINTERUP ||\n      event.type == MapBrowserEventType.POINTERCANCEL\n    ) {\n      delete this.trackedTouches_[id];\n      for (const pointerId in this.trackedTouches_) {\n        if (this.trackedTouches_[pointerId].target !== event.target) {\n          // Some platforms assign a new pointerId when the target changes.\n          // If this happens, delete one tracked pointer. If there is more\n          // than one tracked pointer for the old target, it will be cleared\n          // by subsequent POINTERUP events from other pointers.\n          delete this.trackedTouches_[pointerId];\n          break;\n        }\n      }\n    } else if (\n      event.type == MapBrowserEventType.POINTERDOWN ||\n      event.type == MapBrowserEventType.POINTERMOVE\n    ) {\n      this.trackedTouches_[id] = event;\n    }\n    this.activePointers_ = Object.values(this.trackedTouches_);\n  }\n\n  /**\n   * @param {PointerEvent} pointerEvent Pointer\n   * event.\n   * @private\n   */\n  handlePointerUp_(pointerEvent) {\n    this.updateActivePointers_(pointerEvent);\n    const newEvent = new MapBrowserEvent(\n      MapBrowserEventType.POINTERUP,\n      this.map_,\n      pointerEvent,\n      undefined,\n      undefined,\n      this.activePointers_\n    );\n    this.dispatchEvent(newEvent);\n\n    // We emulate click events on left mouse button click, touch contact, and pen\n    // contact. isMouseActionButton returns true in these cases (evt.button is set\n    // to 0).\n    // See http://www.w3.org/TR/pointerevents/#button-states\n    // We only fire click, singleclick, and doubleclick if nobody has called\n    // event.preventDefault().\n    if (\n      this.emulateClicks_ &&\n      !newEvent.defaultPrevented &&\n      !this.dragging_ &&\n      this.isMouseActionButton_(pointerEvent)\n    ) {\n      this.emulateClick_(this.down_);\n    }\n\n    if (this.activePointers_.length === 0) {\n      this.dragListenerKeys_.forEach(unlistenByKey);\n      this.dragListenerKeys_.length = 0;\n      this.dragging_ = false;\n      this.down_ = null;\n    }\n  }\n\n  /**\n   * @param {PointerEvent} pointerEvent Pointer\n   * event.\n   * @return {boolean} If the left mouse button was pressed.\n   * @private\n   */\n  isMouseActionButton_(pointerEvent) {\n    return pointerEvent.button === 0;\n  }\n\n  /**\n   * @param {PointerEvent} pointerEvent Pointer\n   * event.\n   * @private\n   */\n  handlePointerDown_(pointerEvent) {\n    this.emulateClicks_ = this.activePointers_.length === 0;\n    this.updateActivePointers_(pointerEvent);\n    const newEvent = new MapBrowserEvent(\n      MapBrowserEventType.POINTERDOWN,\n      this.map_,\n      pointerEvent,\n      undefined,\n      undefined,\n      this.activePointers_\n    );\n    this.dispatchEvent(newEvent);\n\n    this.down_ = new PointerEvent(pointerEvent.type, pointerEvent);\n    Object.defineProperty(this.down_, 'target', {\n      writable: false,\n      value: pointerEvent.target,\n    });\n\n    if (this.dragListenerKeys_.length === 0) {\n      const doc = this.map_.getOwnerDocument();\n      this.dragListenerKeys_.push(\n        listen(\n          doc,\n          MapBrowserEventType.POINTERMOVE,\n          this.handlePointerMove_,\n          this\n        ),\n        listen(doc, MapBrowserEventType.POINTERUP, this.handlePointerUp_, this),\n        /* Note that the listener for `pointercancel is set up on\n         * `pointerEventHandler_` and not `documentPointerEventHandler_` like\n         * the `pointerup` and `pointermove` listeners.\n         *\n         * The reason for this is the following: `TouchSource.vacuumTouches_()`\n         * issues `pointercancel` events, when there was no `touchend` for a\n         * `touchstart`. Now, let's say a first `touchstart` is registered on\n         * `pointerEventHandler_`. The `documentPointerEventHandler_` is set up.\n         * But `documentPointerEventHandler_` doesn't know about the first\n         * `touchstart`. If there is no `touchend` for the `touchstart`, we can\n         * only receive a `touchcancel` from `pointerEventHandler_`, because it is\n         * only registered there.\n         */\n        listen(\n          this.element_,\n          MapBrowserEventType.POINTERCANCEL,\n          this.handlePointerUp_,\n          this\n        )\n      );\n      if (this.element_.getRootNode && this.element_.getRootNode() !== doc) {\n        this.dragListenerKeys_.push(\n          listen(\n            this.element_.getRootNode(),\n            MapBrowserEventType.POINTERUP,\n            this.handlePointerUp_,\n            this\n          )\n        );\n      }\n    }\n  }\n\n  /**\n   * @param {PointerEvent} pointerEvent Pointer\n   * event.\n   * @private\n   */\n  handlePointerMove_(pointerEvent) {\n    // Between pointerdown and pointerup, pointermove events are triggered.\n    // To avoid a 'false' touchmove event to be dispatched, we test if the pointer\n    // moved a significant distance.\n    if (this.isMoving_(pointerEvent)) {\n      this.updateActivePointers_(pointerEvent);\n      this.dragging_ = true;\n      const newEvent = new MapBrowserEvent(\n        MapBrowserEventType.POINTERDRAG,\n        this.map_,\n        pointerEvent,\n        this.dragging_,\n        undefined,\n        this.activePointers_\n      );\n      this.dispatchEvent(newEvent);\n    }\n  }\n\n  /**\n   * Wrap and relay a pointermove event.\n   * @param {PointerEvent} pointerEvent Pointer\n   * event.\n   * @private\n   */\n  relayMoveEvent_(pointerEvent) {\n    this.originalPointerMoveEvent_ = pointerEvent;\n    const dragging = !!(this.down_ && this.isMoving_(pointerEvent));\n    this.dispatchEvent(\n      new MapBrowserEvent(\n        MapBrowserEventType.POINTERMOVE,\n        this.map_,\n        pointerEvent,\n        dragging\n      )\n    );\n  }\n\n  /**\n   * Flexible handling of a `touch-action: none` css equivalent: because calling\n   * `preventDefault()` on a `pointermove` event does not stop native page scrolling\n   * and zooming, we also listen for `touchmove` and call `preventDefault()` on it\n   * when an interaction (currently `DragPan` handles the event.\n   * @param {TouchEvent} event Event.\n   * @private\n   */\n  handleTouchMove_(event) {\n    // Due to https://github.com/mpizenberg/elm-pep/issues/2, `this.originalPointerMoveEvent_`\n    // may not be initialized yet when we get here on a platform without native pointer events,\n    // when elm-pep is used as pointer events polyfill.\n    const originalEvent = this.originalPointerMoveEvent_;\n    if (\n      (!originalEvent || originalEvent.defaultPrevented) &&\n      (typeof event.cancelable !== 'boolean' || event.cancelable === true)\n    ) {\n      event.preventDefault();\n    }\n  }\n\n  /**\n   * @param {PointerEvent} pointerEvent Pointer\n   * event.\n   * @return {boolean} Is moving.\n   * @private\n   */\n  isMoving_(pointerEvent) {\n    return (\n      this.dragging_ ||\n      Math.abs(pointerEvent.clientX - this.down_.clientX) >\n        this.moveTolerance_ ||\n      Math.abs(pointerEvent.clientY - this.down_.clientY) > this.moveTolerance_\n    );\n  }\n\n  /**\n   * Clean up.\n   */\n  disposeInternal() {\n    if (this.relayedListenerKey_) {\n      unlistenByKey(this.relayedListenerKey_);\n      this.relayedListenerKey_ = null;\n    }\n    this.element_.removeEventListener(\n      EventType.TOUCHMOVE,\n      this.boundHandleTouchMove_\n    );\n\n    if (this.pointerdownListenerKey_) {\n      unlistenByKey(this.pointerdownListenerKey_);\n      this.pointerdownListenerKey_ = null;\n    }\n\n    this.dragListenerKeys_.forEach(unlistenByKey);\n    this.dragListenerKeys_.length = 0;\n\n    this.element_ = null;\n    super.disposeInternal();\n  }\n}\n\nexport default MapBrowserEventHandler;\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}