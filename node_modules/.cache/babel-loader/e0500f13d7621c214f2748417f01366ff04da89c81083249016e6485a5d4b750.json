{"ast":null,"code":"/**\n * @module ol/sphere\n */\nimport { toDegrees, toRadians } from './math.js';\n\n/**\n * Object literal with options for the {@link getLength} or {@link getArea}\n * functions.\n * @typedef {Object} SphereMetricOptions\n * @property {import(\"./proj.js\").ProjectionLike} [projection='EPSG:3857']\n * Projection of the  geometry.  By default, the geometry is assumed to be in\n * Web Mercator.\n * @property {number} [radius=6371008.8] Sphere radius.  By default, the\n * [mean Earth radius](https://en.wikipedia.org/wiki/Earth_radius#Mean_radius)\n * for the WGS84 ellipsoid is used.\n */\n\n/**\n * The mean Earth radius (1/3 * (2a + b)) for the WGS84 ellipsoid.\n * https://en.wikipedia.org/wiki/Earth_radius#Mean_radius\n * @type {number}\n */\nexport const DEFAULT_RADIUS = 6371008.8;\n\n/**\n * Get the great circle distance (in meters) between two geographic coordinates.\n * @param {Array} c1 Starting coordinate.\n * @param {Array} c2 Ending coordinate.\n * @param {number} [radius] The sphere radius to use.  Defaults to the Earth's\n *     mean radius using the WGS84 ellipsoid.\n * @return {number} The great circle distance between the points (in meters).\n * @api\n */\nexport function getDistance(c1, c2, radius) {\n  radius = radius || DEFAULT_RADIUS;\n  const lat1 = toRadians(c1[1]);\n  const lat2 = toRadians(c2[1]);\n  const deltaLatBy2 = (lat2 - lat1) / 2;\n  const deltaLonBy2 = toRadians(c2[0] - c1[0]) / 2;\n  const a = Math.sin(deltaLatBy2) * Math.sin(deltaLatBy2) + Math.sin(deltaLonBy2) * Math.sin(deltaLonBy2) * Math.cos(lat1) * Math.cos(lat2);\n  return 2 * radius * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));\n}\n\n/**\n * Get the cumulative great circle length of linestring coordinates (geographic).\n * @param {Array} coordinates Linestring coordinates.\n * @param {number} radius The sphere radius to use.\n * @return {number} The length (in meters).\n */\nfunction getLengthInternal(coordinates, radius) {\n  let length = 0;\n  for (let i = 0, ii = coordinates.length; i < ii - 1; ++i) {\n    length += getDistance(coordinates[i], coordinates[i + 1], radius);\n  }\n  return length;\n}\n\n/**\n * Get the spherical length of a geometry.  This length is the sum of the\n * great circle distances between coordinates.  For polygons, the length is\n * the sum of all rings.  For points, the length is zero.  For multi-part\n * geometries, the length is the sum of the length of each part.\n * @param {import(\"./geom/Geometry.js\").default} geometry A geometry.\n * @param {SphereMetricOptions} [options] Options for the\n * length calculation.  By default, geometries are assumed to be in 'EPSG:3857'.\n * You can change this by providing a `projection` option.\n * @return {number} The spherical length (in meters).\n * @api\n */\nexport function getLength(geometry, options) {\n  options = options || {};\n  const radius = options.radius || DEFAULT_RADIUS;\n  const projection = options.projection || 'EPSG:3857';\n  const type = geometry.getType();\n  if (type !== 'GeometryCollection') {\n    geometry = geometry.clone().transform(projection, 'EPSG:4326');\n  }\n  let length = 0;\n  let coordinates, coords, i, ii, j, jj;\n  switch (type) {\n    case 'Point':\n    case 'MultiPoint':\n      {\n        break;\n      }\n    case 'LineString':\n    case 'LinearRing':\n      {\n        coordinates = /** @type {import(\"./geom/SimpleGeometry.js\").default} */geometry.getCoordinates();\n        length = getLengthInternal(coordinates, radius);\n        break;\n      }\n    case 'MultiLineString':\n    case 'Polygon':\n      {\n        coordinates = /** @type {import(\"./geom/SimpleGeometry.js\").default} */geometry.getCoordinates();\n        for (i = 0, ii = coordinates.length; i < ii; ++i) {\n          length += getLengthInternal(coordinates[i], radius);\n        }\n        break;\n      }\n    case 'MultiPolygon':\n      {\n        coordinates = /** @type {import(\"./geom/SimpleGeometry.js\").default} */geometry.getCoordinates();\n        for (i = 0, ii = coordinates.length; i < ii; ++i) {\n          coords = coordinates[i];\n          for (j = 0, jj = coords.length; j < jj; ++j) {\n            length += getLengthInternal(coords[j], radius);\n          }\n        }\n        break;\n      }\n    case 'GeometryCollection':\n      {\n        const geometries = /** @type {import(\"./geom/GeometryCollection.js\").default} */geometry.getGeometries();\n        for (i = 0, ii = geometries.length; i < ii; ++i) {\n          length += getLength(geometries[i], options);\n        }\n        break;\n      }\n    default:\n      {\n        throw new Error('Unsupported geometry type: ' + type);\n      }\n  }\n  return length;\n}\n\n/**\n * Returns the spherical area for a list of coordinates.\n *\n * [Reference](https://trs.jpl.nasa.gov/handle/2014/40409)\n * Robert. G. Chamberlain and William H. Duquette, \"Some Algorithms for\n * Polygons on a Sphere\", JPL Publication 07-03, Jet Propulsion\n * Laboratory, Pasadena, CA, June 2007\n *\n * @param {Array<import(\"./coordinate.js\").Coordinate>} coordinates List of coordinates of a linear\n * ring. If the ring is oriented clockwise, the area will be positive,\n * otherwise it will be negative.\n * @param {number} radius The sphere radius.\n * @return {number} Area (in square meters).\n */\nfunction getAreaInternal(coordinates, radius) {\n  let area = 0;\n  const len = coordinates.length;\n  let x1 = coordinates[len - 1][0];\n  let y1 = coordinates[len - 1][1];\n  for (let i = 0; i < len; i++) {\n    const x2 = coordinates[i][0];\n    const y2 = coordinates[i][1];\n    area += toRadians(x2 - x1) * (2 + Math.sin(toRadians(y1)) + Math.sin(toRadians(y2)));\n    x1 = x2;\n    y1 = y2;\n  }\n  return area * radius * radius / 2.0;\n}\n\n/**\n * Get the spherical area of a geometry.  This is the area (in meters) assuming\n * that polygon edges are segments of great circles on a sphere.\n * @param {import(\"./geom/Geometry.js\").default} geometry A geometry.\n * @param {SphereMetricOptions} [options] Options for the area\n *     calculation.  By default, geometries are assumed to be in 'EPSG:3857'.\n *     You can change this by providing a `projection` option.\n * @return {number} The spherical area (in square meters).\n * @api\n */\nexport function getArea(geometry, options) {\n  options = options || {};\n  const radius = options.radius || DEFAULT_RADIUS;\n  const projection = options.projection || 'EPSG:3857';\n  const type = geometry.getType();\n  if (type !== 'GeometryCollection') {\n    geometry = geometry.clone().transform(projection, 'EPSG:4326');\n  }\n  let area = 0;\n  let coordinates, coords, i, ii, j, jj;\n  switch (type) {\n    case 'Point':\n    case 'MultiPoint':\n    case 'LineString':\n    case 'MultiLineString':\n    case 'LinearRing':\n      {\n        break;\n      }\n    case 'Polygon':\n      {\n        coordinates = /** @type {import(\"./geom/Polygon.js\").default} */geometry.getCoordinates();\n        area = Math.abs(getAreaInternal(coordinates[0], radius));\n        for (i = 1, ii = coordinates.length; i < ii; ++i) {\n          area -= Math.abs(getAreaInternal(coordinates[i], radius));\n        }\n        break;\n      }\n    case 'MultiPolygon':\n      {\n        coordinates = /** @type {import(\"./geom/SimpleGeometry.js\").default} */geometry.getCoordinates();\n        for (i = 0, ii = coordinates.length; i < ii; ++i) {\n          coords = coordinates[i];\n          area += Math.abs(getAreaInternal(coords[0], radius));\n          for (j = 1, jj = coords.length; j < jj; ++j) {\n            area -= Math.abs(getAreaInternal(coords[j], radius));\n          }\n        }\n        break;\n      }\n    case 'GeometryCollection':\n      {\n        const geometries = /** @type {import(\"./geom/GeometryCollection.js\").default} */geometry.getGeometries();\n        for (i = 0, ii = geometries.length; i < ii; ++i) {\n          area += getArea(geometries[i], options);\n        }\n        break;\n      }\n    default:\n      {\n        throw new Error('Unsupported geometry type: ' + type);\n      }\n  }\n  return area;\n}\n\n/**\n * Returns the coordinate at the given distance and bearing from `c1`.\n *\n * @param {import(\"./coordinate.js\").Coordinate} c1 The origin point (`[lon, lat]` in degrees).\n * @param {number} distance The great-circle distance between the origin\n *     point and the target point.\n * @param {number} bearing The bearing (in radians).\n * @param {number} [radius] The sphere radius to use.  Defaults to the Earth's\n *     mean radius using the WGS84 ellipsoid.\n * @return {import(\"./coordinate.js\").Coordinate} The target point.\n */\nexport function offset(c1, distance, bearing, radius) {\n  radius = radius || DEFAULT_RADIUS;\n  const lat1 = toRadians(c1[1]);\n  const lon1 = toRadians(c1[0]);\n  const dByR = distance / radius;\n  const lat = Math.asin(Math.sin(lat1) * Math.cos(dByR) + Math.cos(lat1) * Math.sin(dByR) * Math.cos(bearing));\n  const lon = lon1 + Math.atan2(Math.sin(bearing) * Math.sin(dByR) * Math.cos(lat1), Math.cos(dByR) - Math.sin(lat1) * Math.sin(lat));\n  return [toDegrees(lon), toDegrees(lat)];\n}","map":{"version":3,"names":["toDegrees","toRadians","DEFAULT_RADIUS","getDistance","c1","c2","radius","lat1","lat2","deltaLatBy2","deltaLonBy2","a","Math","sin","cos","atan2","sqrt","getLengthInternal","coordinates","length","i","ii","getLength","geometry","options","projection","type","getType","clone","transform","coords","j","jj","getCoordinates","geometries","getGeometries","Error","getAreaInternal","area","len","x1","y1","x2","y2","getArea","abs","offset","distance","bearing","lon1","dByR","lat","asin","lon"],"sources":["E:/Desktop/SceneryPlatform_v3.0_LTS/node_modules/ol/sphere.js"],"sourcesContent":["/**\n * @module ol/sphere\n */\nimport {toDegrees, toRadians} from './math.js';\n\n/**\n * Object literal with options for the {@link getLength} or {@link getArea}\n * functions.\n * @typedef {Object} SphereMetricOptions\n * @property {import(\"./proj.js\").ProjectionLike} [projection='EPSG:3857']\n * Projection of the  geometry.  By default, the geometry is assumed to be in\n * Web Mercator.\n * @property {number} [radius=6371008.8] Sphere radius.  By default, the\n * [mean Earth radius](https://en.wikipedia.org/wiki/Earth_radius#Mean_radius)\n * for the WGS84 ellipsoid is used.\n */\n\n/**\n * The mean Earth radius (1/3 * (2a + b)) for the WGS84 ellipsoid.\n * https://en.wikipedia.org/wiki/Earth_radius#Mean_radius\n * @type {number}\n */\nexport const DEFAULT_RADIUS = 6371008.8;\n\n/**\n * Get the great circle distance (in meters) between two geographic coordinates.\n * @param {Array} c1 Starting coordinate.\n * @param {Array} c2 Ending coordinate.\n * @param {number} [radius] The sphere radius to use.  Defaults to the Earth's\n *     mean radius using the WGS84 ellipsoid.\n * @return {number} The great circle distance between the points (in meters).\n * @api\n */\nexport function getDistance(c1, c2, radius) {\n  radius = radius || DEFAULT_RADIUS;\n  const lat1 = toRadians(c1[1]);\n  const lat2 = toRadians(c2[1]);\n  const deltaLatBy2 = (lat2 - lat1) / 2;\n  const deltaLonBy2 = toRadians(c2[0] - c1[0]) / 2;\n  const a =\n    Math.sin(deltaLatBy2) * Math.sin(deltaLatBy2) +\n    Math.sin(deltaLonBy2) *\n      Math.sin(deltaLonBy2) *\n      Math.cos(lat1) *\n      Math.cos(lat2);\n  return 2 * radius * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));\n}\n\n/**\n * Get the cumulative great circle length of linestring coordinates (geographic).\n * @param {Array} coordinates Linestring coordinates.\n * @param {number} radius The sphere radius to use.\n * @return {number} The length (in meters).\n */\nfunction getLengthInternal(coordinates, radius) {\n  let length = 0;\n  for (let i = 0, ii = coordinates.length; i < ii - 1; ++i) {\n    length += getDistance(coordinates[i], coordinates[i + 1], radius);\n  }\n  return length;\n}\n\n/**\n * Get the spherical length of a geometry.  This length is the sum of the\n * great circle distances between coordinates.  For polygons, the length is\n * the sum of all rings.  For points, the length is zero.  For multi-part\n * geometries, the length is the sum of the length of each part.\n * @param {import(\"./geom/Geometry.js\").default} geometry A geometry.\n * @param {SphereMetricOptions} [options] Options for the\n * length calculation.  By default, geometries are assumed to be in 'EPSG:3857'.\n * You can change this by providing a `projection` option.\n * @return {number} The spherical length (in meters).\n * @api\n */\nexport function getLength(geometry, options) {\n  options = options || {};\n  const radius = options.radius || DEFAULT_RADIUS;\n  const projection = options.projection || 'EPSG:3857';\n  const type = geometry.getType();\n  if (type !== 'GeometryCollection') {\n    geometry = geometry.clone().transform(projection, 'EPSG:4326');\n  }\n  let length = 0;\n  let coordinates, coords, i, ii, j, jj;\n  switch (type) {\n    case 'Point':\n    case 'MultiPoint': {\n      break;\n    }\n    case 'LineString':\n    case 'LinearRing': {\n      coordinates = /** @type {import(\"./geom/SimpleGeometry.js\").default} */ (\n        geometry\n      ).getCoordinates();\n      length = getLengthInternal(coordinates, radius);\n      break;\n    }\n    case 'MultiLineString':\n    case 'Polygon': {\n      coordinates = /** @type {import(\"./geom/SimpleGeometry.js\").default} */ (\n        geometry\n      ).getCoordinates();\n      for (i = 0, ii = coordinates.length; i < ii; ++i) {\n        length += getLengthInternal(coordinates[i], radius);\n      }\n      break;\n    }\n    case 'MultiPolygon': {\n      coordinates = /** @type {import(\"./geom/SimpleGeometry.js\").default} */ (\n        geometry\n      ).getCoordinates();\n      for (i = 0, ii = coordinates.length; i < ii; ++i) {\n        coords = coordinates[i];\n        for (j = 0, jj = coords.length; j < jj; ++j) {\n          length += getLengthInternal(coords[j], radius);\n        }\n      }\n      break;\n    }\n    case 'GeometryCollection': {\n      const geometries =\n        /** @type {import(\"./geom/GeometryCollection.js\").default} */ (\n          geometry\n        ).getGeometries();\n      for (i = 0, ii = geometries.length; i < ii; ++i) {\n        length += getLength(geometries[i], options);\n      }\n      break;\n    }\n    default: {\n      throw new Error('Unsupported geometry type: ' + type);\n    }\n  }\n  return length;\n}\n\n/**\n * Returns the spherical area for a list of coordinates.\n *\n * [Reference](https://trs.jpl.nasa.gov/handle/2014/40409)\n * Robert. G. Chamberlain and William H. Duquette, \"Some Algorithms for\n * Polygons on a Sphere\", JPL Publication 07-03, Jet Propulsion\n * Laboratory, Pasadena, CA, June 2007\n *\n * @param {Array<import(\"./coordinate.js\").Coordinate>} coordinates List of coordinates of a linear\n * ring. If the ring is oriented clockwise, the area will be positive,\n * otherwise it will be negative.\n * @param {number} radius The sphere radius.\n * @return {number} Area (in square meters).\n */\nfunction getAreaInternal(coordinates, radius) {\n  let area = 0;\n  const len = coordinates.length;\n  let x1 = coordinates[len - 1][0];\n  let y1 = coordinates[len - 1][1];\n  for (let i = 0; i < len; i++) {\n    const x2 = coordinates[i][0];\n    const y2 = coordinates[i][1];\n    area +=\n      toRadians(x2 - x1) *\n      (2 + Math.sin(toRadians(y1)) + Math.sin(toRadians(y2)));\n    x1 = x2;\n    y1 = y2;\n  }\n  return (area * radius * radius) / 2.0;\n}\n\n/**\n * Get the spherical area of a geometry.  This is the area (in meters) assuming\n * that polygon edges are segments of great circles on a sphere.\n * @param {import(\"./geom/Geometry.js\").default} geometry A geometry.\n * @param {SphereMetricOptions} [options] Options for the area\n *     calculation.  By default, geometries are assumed to be in 'EPSG:3857'.\n *     You can change this by providing a `projection` option.\n * @return {number} The spherical area (in square meters).\n * @api\n */\nexport function getArea(geometry, options) {\n  options = options || {};\n  const radius = options.radius || DEFAULT_RADIUS;\n  const projection = options.projection || 'EPSG:3857';\n  const type = geometry.getType();\n  if (type !== 'GeometryCollection') {\n    geometry = geometry.clone().transform(projection, 'EPSG:4326');\n  }\n  let area = 0;\n  let coordinates, coords, i, ii, j, jj;\n  switch (type) {\n    case 'Point':\n    case 'MultiPoint':\n    case 'LineString':\n    case 'MultiLineString':\n    case 'LinearRing': {\n      break;\n    }\n    case 'Polygon': {\n      coordinates = /** @type {import(\"./geom/Polygon.js\").default} */ (\n        geometry\n      ).getCoordinates();\n      area = Math.abs(getAreaInternal(coordinates[0], radius));\n      for (i = 1, ii = coordinates.length; i < ii; ++i) {\n        area -= Math.abs(getAreaInternal(coordinates[i], radius));\n      }\n      break;\n    }\n    case 'MultiPolygon': {\n      coordinates = /** @type {import(\"./geom/SimpleGeometry.js\").default} */ (\n        geometry\n      ).getCoordinates();\n      for (i = 0, ii = coordinates.length; i < ii; ++i) {\n        coords = coordinates[i];\n        area += Math.abs(getAreaInternal(coords[0], radius));\n        for (j = 1, jj = coords.length; j < jj; ++j) {\n          area -= Math.abs(getAreaInternal(coords[j], radius));\n        }\n      }\n      break;\n    }\n    case 'GeometryCollection': {\n      const geometries =\n        /** @type {import(\"./geom/GeometryCollection.js\").default} */ (\n          geometry\n        ).getGeometries();\n      for (i = 0, ii = geometries.length; i < ii; ++i) {\n        area += getArea(geometries[i], options);\n      }\n      break;\n    }\n    default: {\n      throw new Error('Unsupported geometry type: ' + type);\n    }\n  }\n  return area;\n}\n\n/**\n * Returns the coordinate at the given distance and bearing from `c1`.\n *\n * @param {import(\"./coordinate.js\").Coordinate} c1 The origin point (`[lon, lat]` in degrees).\n * @param {number} distance The great-circle distance between the origin\n *     point and the target point.\n * @param {number} bearing The bearing (in radians).\n * @param {number} [radius] The sphere radius to use.  Defaults to the Earth's\n *     mean radius using the WGS84 ellipsoid.\n * @return {import(\"./coordinate.js\").Coordinate} The target point.\n */\nexport function offset(c1, distance, bearing, radius) {\n  radius = radius || DEFAULT_RADIUS;\n  const lat1 = toRadians(c1[1]);\n  const lon1 = toRadians(c1[0]);\n  const dByR = distance / radius;\n  const lat = Math.asin(\n    Math.sin(lat1) * Math.cos(dByR) +\n      Math.cos(lat1) * Math.sin(dByR) * Math.cos(bearing)\n  );\n  const lon =\n    lon1 +\n    Math.atan2(\n      Math.sin(bearing) * Math.sin(dByR) * Math.cos(lat1),\n      Math.cos(dByR) - Math.sin(lat1) * Math.sin(lat)\n    );\n  return [toDegrees(lon), toDegrees(lat)];\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}